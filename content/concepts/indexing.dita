<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="concept_kl3_y5f_ps">
 <title>Indexing</title>
 <shortdesc>Couchbase Server speeds up data access with indexes. Indexing is especially important because items in production Couchbase clusters are distributed across many nodes, and any item may need to be accessed in order to satisfy a query. 
		</shortdesc>
 <conbody>
  <p>Couchbase supports a variety of global secondary indexes and view based indexes that may be used to improve performance at the cost of some processing overhead to maintain the index. Since index data is smaller than the documents themselves, it may be duplicated rather distributed across multiple nodes, reducing network access times by querying indexes locally. Couchbase provides the EXPLAIN command that enables detailed exploration of query execution and index use that can help guide decisions about what to index. In order to further reduce index processing overhead and satisfy a request as quickly as possible, Couchbase employs many clever strategies such as deferred index building (create multiple indexes with a single scan) and flexible index consistency settings for controlling stale-ness.</p>
   
   <p>Despite their name, global secondary indexes (GSI) can be used to create high performance primary or secondary indexes. Couchbase global secondary indexes are partitioned separately from data. Even though Couchbase data is distributed among nodes, for best performance developers and administrators typically create indexes on a selected set of nodes running the index service. Keeping the entire index on one node means that operational complexity remains constant as the cluster grows and also ensures that requests to the index can be satisfied using local data without incurring network latency.</p>
 <ul>
  <li><b>Composite Indexes</b> optimize access for queries that require data from multiple attributes. </li>
   <li><b>Covering Indexes</b> include all of the information needed to satisfy a query without accessing the data, so they are very fast.</li> 
   <li><b>Filtered Indexes</b> (or partial indexes) perform sampling that allows users to create an index on just a subset of the data by using the WHERE clause. This has the effect of reducing the index size and associated maintenance impacts in order to remain scalable and performant when handling large datasets.</li>  
   <li><b>Function-based Indexes</b> result from computing the value of an expression over a range of documents.</li>
   <li><b>Sub-document Indexes</b> are used to index embedded structures and complex objects. Sub-document indexes can significantly improve query performance on serialized JSON objects.</li> 
   <li><b>Spatial Indexes</b> speed up access to multidimensional numeric data. The spatial index is an R-Tree, a structure capable of representing multiple, potentially overlapping regions. Geometry information is supported using the GeoJSON specification. Spatial indexes can also be created on numeric data to define a multidimensional cube (hyper-cube), such as a relation of customer ages, incomes, and lifetime spend. The advantage of a spatial index compared to a compound index is that the spatial index can serve queries with the dimensions in any order. See this talk for more information.</li>
   <li><b>Full Text Indexes</b> allow developers to easily add full-text search capabilities to their application using CBFT (developer preview), search use cases  without deploying additional components, which reduces operational complexity.</li> 
   <li><b>MapReduce Views</b> can be also be used as indexes. When building a MapReduce view, a
        developer can custom tailor it to optimize support for a specific set of queries, usually
        complex queries that are best expressed with MapReduce view indexes are typically used for
        sorting and aggregation to produce real-time analytics over very large datasets. For
        example, a map-reduce view index would be useful in building an interactive report on sales
        data that can be explored by date, item, or region. A single map-reduce view index can be
        created by emitting separate rows that simultaneously aggregate the sales data according to
        each of the three separate dimensions.</li>
 </ul>
 </conbody>
</concept>
