<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_ihy_ddy_w5">
  <title>Memory optimized global indexes</title><shortdesc>Memory optimized global indexes enable in-memory index processing and index scans with the lowest latency. These indexes reside in memory and provide a fresh index that is up to date under aggressive mutation rates without impacting the incoming database workload. </shortdesc>
  <body>
    <section><title>Enabling memory optimized global indexes on the cluster</title>
      <p>Enable the memory optimized global indexes from the <uicontrol>Settings</uicontrol> tab on the Couchbase Web console. Under the Index Settings section, set <uicontrol>Use Memory-Optimized Indexes</uicontrol> to <userinput>ON</userinput>. The default value is OFF. <note>This value can only be set when adding the first index service node to your cluster.</note> Memory optimized indexes can be disabled only after all the index service nodes in the cluster are removed. </p>
    </section>
    <section><title>Handling out-of-memory conditions</title>
      <p>Memory optimized global indexes reside in memory. When an index service node runs out of configured index RAM quota, it affects the memory optimized indexes. The index service logs an error in the Couchbase Server log indicating the condition. </p>
<p>Memory optimized indexes on a node that has run out of memory continue to stay in the ONLINE state. However, the round-robin logic routes traffic away from this index node. If an index is in OFFLINE, DEFERRED, or BUILDING state, the index is not transitioned to the ONLINE state.</p>
      <p>When the node is restarted, indexes stay in the BUILDING state until the last persisted snapshot is read from disk into memory. The additional catchup is done in ONLINE state. Queries with <codeph>stale=false</codeph> or RYOW semantics fail if the timestamp specified exceeds the last timestamp processed by the specific index on the node. However, queries with <codeph>stale=ok</codeph> continue to execute normally. </p>
<p>To recover from an out of memory situation, use one or more of the following fixes:<ul>
  <li>Increase the index RAM quota sufficiently enough to give indexes the additional memory to process requests.</li>
  <li>Drop other indexes on the node to free up memory. On nodes with multiple indexes, drop the unimportant indexes to free memory.</li>
  <li>Drop buckets with indexes. Dropping a bucket automatically drops all the dependent indexes and has the same effect as dropping all indexes on a bucket.</li>
  <li>Flush buckets with indexes. Flushing a bucket deletes all data in a bucket. Even if there are pending updates that are not processed, flushing a bucket causes all indexes to drop their data. </li> 
</ul>
<note type="important">Deleting data selectively from buckets does not help, as mutations are processed in sequence and indexes can not process mutations in an out-of-memory condition.</note></p>
    </section>
    <section><title>Limitations</title>
      <p><ul>
        <li>Memory optimized indexes cannot co-exist with normal GSI indexes. This means, for the Developer Preview release, enabling memory optimized indexes (cluster-wide setting) automatically disables GSI indexes in the cluster. However, you can use MapReduce views to create persisted indexes.</li>
        <li>Memory-optimized global indexes are supported only for Couchbase buckets.</li>
        <li>No syntax changes to the N1QL statements, including BUILD INDEX, CREATE INDEX, DROP INDEX.</li>
      </ul></p>
    </section>
    <section><title>Node failure and failover</title>
      <p>Nodes with only index service won’t automatically failover, which is the same behavior as in version 4.0/4.1. However, when a node with <codeph>Use memory-optimized index=ON</codeph> restarts, it rebuilds the index starting from the last snapshot. The indexes are marked “ONLINE” while the mutations are processed to catch up.</p>
    </section>
    
  </body>
</topic>
