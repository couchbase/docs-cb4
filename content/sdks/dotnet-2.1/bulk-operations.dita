<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="concept_emk_nhq_44">
 <title>Bulk operations</title>
 <shortdesc>Bulk operations allow you to upsert or get a set of keys in parallel.</shortdesc>
 <conbody>
  <p> The <codeph>IBucket</codeph> interface provides two methods (with many overloads) for updating
			and retrieving documents based upon a range of IDs or keys. Internally the client
			processes these keys in parallel taking advantage of the computer architecture of the
			application server and fully utilizing the resources that are available. </p>
  <p>These methods are configurable through the overloads that take a <codeph><xref
     href="http://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions%28v=vs.110%29.aspx"
     format="html" scope="external">ParallelOptions</xref></codeph> object and the
    <codeph>range</codeph> parameters. Through these parameters you can specify the
    <codeph>MaxDegreeOfParallism</codeph>, an optional <codeph><xref
     href="http://msdn.microsoft.com/en-us/library/system.threading.cancellationtoken%28v=vs.110%29.aspx"
     format="html" scope="external">CancellationToken</xref></codeph>, and the size of the
   partition you want to be processed per iteration. The overload that does not supply these uses
   the defaults handled internally by the .NET framework.</p>
  <section id="upsert">
   <title>Upsert</title>
  	<p>Bulk upsert operations enable you to insert or replace a set of documents. The following
				example creates several documents in a <apiname>Dictionary</apiname> object and then
				inserts them all into the database by using only one <apiname>Upsert()</apiname>
				operation.</p>
   <codeblock outputclass="language-csharp">
     using (var bucket = _cluster.OpenBucket())
     {
         var items = new Dictionary&lt;string, dynamic&gt;
         {
             {"CouchbaseBucketTests.Test_Multi_Upsert.String", "string"},
             {"CouchbaseBucketTests.Test_Multi_Upsert.Json", new {Foo = "Bar", Baz = 2}},
             {"CouchbaseBucketTests.Test_Multi_Upsert.Int", 2},
             {"CouchbaseBucketTests.Test_Multi_Upsert.Number", 5.8},
             {"CouchbaseBucketTests.Test_Multi_Upsert.Binary", new[] {0x00, 0x00}}
         };

         var multiUpsert = bucket.Upsert(items);
         foreach (var item in multiUpsert)
         {
             Assert.IsTrue(item.Value.Success);
         }
     }
   </codeblock>
  </section>
  <section id="get">
   <title>Get</title>
			<p>Bulk get operations enable to you retrieve a set of documents in parallel. The following
				example puts a set of keys into a <codeph>List</codeph> object and then retrieves all of
				the corresponding documents by using only one <apiname>Get()</apiname> operation.</p>
   <codeblock outputclass="language-csharp">
    using (var bucket = _cluster.OpenBucket())
    {
        var items = new List&lt;string&gt;
        {
            "CouchbaseBucketTests.Test_Multi_Upsert.String",
            "CouchbaseBucketTests.Test_Multi_Upsert.Json",
            "CouchbaseBucketTests.Test_Multi_Upsert.Int",
            "CouchbaseBucketTests.Test_Multi_Upsert.Number",
            "CouchbaseBucketTests.Test_Multi_Upsert.Binary"
        };

        var multiGet = bucket.Get&lt;dynamic&gt;(items);
        foreach (var item in multiGet)
        {
            Assert.IsTrue(item.Value.Success);
        }
    }
   </codeblock>
  </section>
  <section>
   <title>Overloading the parallel options and partition size</title>
   <p>Here is an example of using one of the overloads that takes a <codeph><xref
						href="http://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions%28v=vs.110%29.aspx"
						format="html" scope="external">ParallelOptions</xref></codeph> object and
				specifies a <codeph>range</codeph> to partition the requests into two requests per
				iteration utilizing a maximum of 2 cores:</p>
   <codeblock outputclass="language-csharp">
     using (var bucket = _cluster.OpenBucket("beer-sample"))
     {
         var query = bucket.CreateQuery("beer", "brewery_beers");
         var results = bucket.Query&lt;dynamic&gt;(query);

         var keys = results.
             Rows.
             ConvertAll(x => x.id.Value).
             Cast&lt;string&gt;();

         var multiget = bucket.Get&lt;dynamic&gt;(keys.ToList(), new ParallelOptions
         {
             MaxDegreeOfParallelism = 2
         },
         2);
         Assert.AreEqual(results.TotalRows, multiget.Count);
     }
   </codeblock>
   <p>Note that this is a contrived example and you should use benchmarking and trial and error to
				determine the optimal parallel setting for your particular environment and use case.</p>
  </section>
 </conbody>
</concept>
