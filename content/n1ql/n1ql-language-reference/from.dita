<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_rnt_zfk_np">
 <title>FROM clause</title>
    <shortdesc>The <codeph>FROM</codeph> clause specifies the keyspaces and JOIN operations on
        them.</shortdesc>

 <body>
        <p><i>(Introduced in Couchbase Server 4.0)</i></p>
        <section id="section_afb_jnp_2cb">
            <title>Purpose</title>
            <p>In a <codeph>SELECT</codeph> query or subquery, the <codeph>FROM</codeph> clause
                specifies one or more of the following:<ul id="ul_x1s_nns_1db">
                    <li>Keyspaces</li>
                    <li>Subqueries (such as derived tables)</li>
                    <li>JOIN clauses</li>
                    <li>JOIN conditions</li>
                    <li>Expressions (nested collections, <codeph>CURL()</codeph>, or other
                        expressions)</li>
                </ul></p>
        </section>
        <section id="section_hgx_knp_2cb">
            <title>Prerequisites</title>
            <p>For you to select data from keyspace or expression, you must have the
                    <parmname>query_select</parmname> privilege on that keyspace. For more details
                about user roles, see <xref
                    href="../../security/security-authorization.dita#authorization"/>.</p>
        </section>
        <section id="section_fwj_nnp_2cb"><title>Syntax</title><p>
                <image placement="break" href="images/from-term.png" id="image_uy5_kzt_pz"/>
            </p><p>
                <codeblock>FROM <varname>from-keyspace</varname> [ [ AS ] <varname>alias1</varname> ] [ USE KEYS <varname>use-clause</varname> ]  
                    | "(" SELECT ")" [ [ AS ] <varname>alias2</varname> ]
                    | <varname>expr</varname> [ [ AS ] <varname>alias3</varname> ]
                    | <varname>from-term</varname> ( <varname>join-clause</varname> | <varname>nest-clause</varname> | <varname>unnest-clause</varname> )  </codeblock>
            </p><table frame="all" rowsep="1" colsep="1" id="table_vzt_j4s_1db"><title>Arguments</title>
                <tgroup cols="2" align="left">
                    <colspec colname="c1" colnum="1" colwidth="1*"/>
                    <colspec colname="c2" colnum="2" colwidth="3.9*"/>
                    <thead>
                        <row>
                            <entry>Argument / Clause</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><b><xref href="#topic_rnt_zfk_np/sec_from-keyspace" format="dita"
                                        >from-keyspace</xref></b><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                </p><p> . . . <b><xref href="#topic_rnt_zfk_np/section_ax5_2nx_1db"
                                            format="dita"><codeph>AS </codeph>alias</xref></b></p><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                </p><p>. . . <xref href="#topic_rnt_zfk_np/use-keys-clause"
                                        format="dita"><b><codeph>USE KEYS
                                        </codeph>use-clause</b></xref></p></entry>
                            <entry><xref href="identifiers.dita#topic_6">Identifier</xref> that
                                represents the keyspace for the query, such as<codeph> FROM
                                    `travel-sample`</codeph><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                </p><p>To assign a name to a keyspace or expression. </p><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                </p><p>To specify one or more document keys.</p></entry>
                        </row>
                        <row>
                            <entry><b><xref href="#topic_rnt_zfk_np/select-expr" format="dita">(
                                        select-expr )</xref></b></entry>
                            <entry>To specify a N1QL SELECT subquery</entry>
                        </row>
                        <row>
                            <entry><b><xref href="index.dita#n1ql-lang-ref/N1QL_Expressions"
                                        >expr</xref></b></entry>
                            <entry>A N1QL expression generating JSON documents or objects.</entry>
                        </row>
                        <row>
                            <entry><b><xref href="#topic_rnt_zfk_np/section_nkd_3nx_1db"
                                        format="dita">from-term</xref></b><dl>
                                    <dlentry>
                                        <dt/>
                                        <dd/>
                                    </dlentry>
                                </dl><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                </p><p>. . . <b><codeph> JOIN </codeph>join-clause</b></p><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd>
                                                <dl>
                                                  <dlentry>
                                                  <dt/>
                                                  <dd/>
                                                  </dlentry>
                                                </dl>
                                            </dd>
                                        </dlentry>
                                    </dl>
                                </p><p>. . . <b><codeph> NEST </codeph>nest-clause</b></p><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd>
                                                <dl>
                                                  <dlentry>
                                                  <dt/>
                                                  <dd/>
                                                  </dlentry>
                                                </dl>
                                            </dd>
                                        </dlentry>
                                    </dl>
                                </p><p>. . . <b><xref href="#topic_rnt_zfk_np/unnest" format="dita"
                                                ><codeph> UNNEST
                                    </codeph>unnest-clause</xref></b></p></entry>
                            <entry>A N1QL expression that defines the input object(s) for the query,
                                which can be either a <xref
                                    href="#topic_rnt_zfk_np/table_vrv_nxx_1db" format="dita"
                                    >keyspace identifier</xref>, <xref
                                    href="index.dita#n1ql-lang-ref">generic expression</xref>, or
                                    <xref href="subqueries.dita#topic_9">subquery</xref> along with
                                one or more JOIN, NEST, or UNNEST clause.<p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                </p><p>Create an input object by combining two or more source
                                    objects via <xref href="#topic_rnt_zfk_np/section_ek1_jnx_1db"
                                        format="dita">ANSI JOIN</xref>, <xref
                                        href="#topic_rnt_zfk_np/lookup-join-clause" format="dita"
                                        >Lookup JOIN</xref>, or <xref
                                        href="#topic_rnt_zfk_np/index-join-clause" format="dita"
                                        >Index JOIN</xref>.</p><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                </p><p>Create an input object by producing a single result of
                                    nesting keyspaces via <xref
                                        href="#topic_rnt_zfk_np/section_tc1_nnx_1db" format="dita"
                                        >ANSI NEST</xref>, <xref href="#topic_rnt_zfk_np/nest"
                                        format="dita">Lookup NEST</xref>, or <xref
                                        href="#topic_rnt_zfk_np/section_rgr_rnx_1db" format="dita"
                                        >Index NEST</xref>.</p><p>
                                    <dl>
                                        <dlentry>
                                            <dt/>
                                            <dd/>
                                        </dlentry>
                                    </dl>
                                </p><p>Create an input object by flattening an array in the parent
                                    document.</p></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section id="sec_from-keyspace">
            <title>from-keyspace</title>
            <p> You can specify a keyspace to query from, either a specific bucket or a constant
                expression. If the <varname>from-keyspace</varname> clause is used, then there must
                be a <varname>from-keyspace-name</varname> specified.</p>
            <p>The simplest type of from-keyspace clause specifies a single bucket (i.e.,
                    <codeph>SELECT * FROM `travel-sample`</codeph>).</p>
            <p>Keyspace identifier is the name or identifier of an independent place for a data
                source of one or more documents. Such keyspaces are not dependent on any of the
                    <xref href="subqueries.dita#topic_9/section_onz_3tj_mz">Variable in Scope of a
                    Subquery</xref>.</p>
            <p/>
            <p><b>from-keyspace Example:</b> Use a keyspace from a single bucket.</p>
            <p>Select four unique landmarks from the<codeph> `travel-sample` </codeph>bucket.</p>
            <p><codeblock>SELECT DISTINCT name
FROM `travel-sample`
WHERE type = "landmark"
LIMIT 4;</codeblock>Results:</p>
            <codeblock>[
  {
    "name": "Royal Engineers Museum"
  },
  {
    "name": "Hollywood Bowl"
  },
  {
    "name": "Thai Won Mien"
  },
  {
    "name": "Spice Court"
  }
]</codeblock>
            <p><b>N1QL Expressions in a FROM Clause</b></p>
            <p>Couchbase Server version 4.6.2 added support for generic <xref
                    href="index.dita#n1ql-lang-ref">expressions</xref> in the
                    <codeph>from-term</codeph> clause; and this adds huge flexibility by the
                enabling of various N1QL functions, operators, path expressions, language constructs
                on constant expressions, variables, and subqueries to create just about any FROM
                clause imaginable. <ul id="ul_jwy_fyx_mz">
                    <li dir="ltr">
                        <p dir="ltr">When the <codeph>from-term</codeph> is an expression,
                                <codeph>USE KEYS</codeph> or <codeph>USE INDEX</codeph> clauses are
                            not allowed.</p>
                    </li>
                    <li dir="ltr">
                        <p dir="ltr">When using a <codeph>JOIN</codeph> clause,
                                <codeph>NEST</codeph> clause, or <codeph>UNNEST</codeph> clause, the
                            left-side keyspace can be an expression or subquery, but the right-side
                            keyspace must be a keyspace identifier.</p>
                        <dl>
                            <dlentry>
                                <dt><b>1. Independent Constant Expression</b></dt>
                                <dd/>
                                <dd>This includes any N1QL expressions of JSON scalar values, static
                                    JSON literals, objects, or N1QL functions, for example:<p>
                                        <codeblock>SELECT * FROM [1, 2, "name", { "type" : "airport", "id" : "SFO"}]  AS  ks1;

SELECT CURL("https://maps.googleapis.com/maps/api/geocode/json",
           {"data":"address=Half+Moon+Bay" , "request":"GET"} );</codeblock>
                                    </p><p dir="ltr">Note that functions such as <xref
                                            href="curl.dita#topic_8_8">CURL()</xref> can
                                        independently produce input data objects for the query.
                                        Similarly, other N1QL functions can also be used in the
                                        expressions.</p></dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>2. Variable N1QL Expression</b></dt>
                                <dd/>
                                <dd>This includes expressions that refer to any <xref
                                        href="subqueries.dita#topic_9/section_onz_3tj_mz">variables
                                        in scope</xref> for the query, for
                                        example:<codeblock>SELECT count(*) 
FROM `travel-sample` t 
<b>LET x = t.geo</b>
WHERE (SELECT RAW y.alt <b>FROM x</b> y)[0] > 6000;</codeblock>The<codeph>
                                        FROM x </codeph>clause is an expression that refers to the
                                    outer query. This is applicable to only subqueries because the
                                    outermost level query cannot use any variables in its own
                                        <codeph>FROM</codeph> clause. This makes the subquery
                                    correlated with outer queries, as explained in the <xref
                                        href="subqueries.dita#topic_9"/> section. </dd>
                            </dlentry>
                        </dl>
                        <dl>
                            <dlentry>
                                <dt><b>3. Subquery and Subquery Expressions</b></dt>
                                <dd/>
                                <dd>
                                    <p dir="ltr"><b>Subquery Example:</b> For each country, find the
                                        number of airports at different altitudes and their
                                        corresponding cities.</p>
                                    <p>In this case, the inner query finds the first level of
                                        grouping of different altitudes by country and corresponding
                                        number of cities. Then the outer query builds on the inner
                                        query results to count the number of different altitude
                                        groups for each country and the total number of cities.</p>
                                    <p><codeblock>SELECT t1.country, num_alts, total_cities
FROM (SELECT country, geo.alt AS alt,
             count(city) AS num_cities
      FROM `travel-sample` 
      WHERE type = "airport"
      GROUP BY country, geo.alt) t1
GROUP BY t1.country 
LETTING num_alts = count(t1.alt), total_cities = sum(t1.num_cities);</codeblock>Results:<codeblock>[
  {
    "country": "United States",
    "num_alts": 946,
    "total_cities": 1560
  },
  {
    "country": "United Kingdom",
    "num_alts": 128,
    "total_cities": 187
  },
  {
    "country": "France",
    "num_alts": 196,
    "total_cities": 221
  }
]</codeblock></p>
                                </dd>
                                <dd>This is equivalent to blending the results of the following two
                                    queries by country, but the subquery in the
                                        <codeph>from-term</codeph> above simplified
                                    it.<codeblock>SELECT country,count(city) AS num_cities
FROM `travel-sample` 
WHERE type = "airport"
GROUP BY country;

SELECT country, count(distinct geo.alt) AS num_alts
FROM `travel-sample` 
WHERE type = "airport"
GROUP BY country;</codeblock>
                                    For more details and examples, see <xref
                                        href="subqueries.dita#topic_9"/> and <xref
                                        href="#topic_rnt_zfk_np/select-expr" format="dita">(
                                        select-expr )</xref>. </dd>
                            </dlentry>
                        </dl>
                    </li>
                </ul></p>
        </section>
        <section id="section_ax5_2nx_1db">
            <title>AS Alias</title>
            <p>To use a shorter or clearer name anywhere in the query, like SQL, N1QL allows
                renaming fields by using the AS keyword to assign an alias to a keyspace or field in
                the <codeph>FROM</codeph> clause.</p>
            <p><b>Syntax</b><codeblock>[AS] alias</codeblock></p>
            <p><b>Arguments</b></p>
            <p>
                <dl>
                    <dlentry>
                        <dt><codeph>AS</codeph></dt>
                        <dd>[Optional] Reserved word denoting the next word is an alias of the
                            previous term.</dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>alias</dt>
                        <dd>[Required if <codeph>AS</codeph> is used] String to assign a name to a
                            keyspace, such as the following equivalent <codeph>FROM</codeph> clauses
                            with and without the <codeph>AS</codeph> keyword:<table frame="all"
                                rowsep="1" colsep="1" id="table_hjp_5qx_1db">
                                <tgroup cols="2" align="left">
                                    <colspec colname="c1" colnum="1" colwidth="1*"/>
                                    <colspec colname="c2" colnum="2" colwidth="1*"/>
                                    <tbody>
                                        <row>
                                            <entry><codeph>FROM `travel-sample`
                                                  </codeph><codeph><b>AS t</b></codeph></entry>
                                            <entry><codeph>FROM `travel-sample`
                                                  </codeph><codeph><b>t</b></codeph></entry>
                                        </row>
                                        <row>
                                            <entry><codeph>FROM `travel-sample`
                                                  </codeph><codeph><b>AS
                                                  h</b></codeph><p><codeph>INNER JOIN
                                                  `travel-sample` </codeph><codeph><b>AS
                                                  l</b></codeph></p><p><codeph>ON
                                                  (</codeph><codeph><b>h</b></codeph><codeph>.city =
                                                  </codeph><codeph><b>l</b></codeph><codeph>.city)</codeph></p></entry>
                                            <entry><codeph>FROM `travel-sample`
                                                  </codeph><codeph><b>h</b></codeph><p><codeph>INNER
                                                  JOIN `travel-sample`
                                                  </codeph><codeph><b>l</b></codeph></p><p><codeph>ON
                                                  (</codeph><codeph><b>h</b></codeph><codeph>.city =
                                                  </codeph><codeph><b>l</b></codeph><codeph>.city)</codeph></p></entry>
                                        </row>
                                    </tbody>
                                </tgroup>
                            </table><note>Since the original name may lead to referencing wrong data
                                and wrong results, you must use the alias name throughout the query
                                instead of the original keyspace name.<p>In the FROM clause, the
                                    renaming appears only in the projection and not the fields
                                    themselves.</p><p>When no alias is used, the keyspace or last
                                    field name of an expression is given as the implicit
                                    alias.</p><p>When an alias conflicts with a keyspace or field
                                    name in the same scope, the identifier always refers to the
                                    alias. This allows for consistent behavior in scenarios where an
                                    identifier only conflicts in some documents. For more
                                    information on aliases, see <xref href="identifiers.dita"
                                />.</p></note></dd>
                    </dlentry>
                </dl>
            </p>
        </section>
        <section><title id="use-keys-clause">USE KEYS Clause</title><p>You can refer to a document's
                unique document key by using the <codeph>USE KEYS</codeph> clause. Only documents
                having those document keys will be included as inputs to a
                    query.</p><p><b>Syntax</b></p><p><image
                    href="images/use-keys-clause.png"
                    id="image_xs4_mtx_1db"/></p><codeblock>USE [ PRIMARY ] KEYS <varname>expr</varname> </codeblock><p><dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>PRIMARY</dt>
                                    <dd>[Optional] <codeph>USE KEYS</codeph> and <codeph>USE PRIMARY
                                            KEYS</codeph> are synonyms.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>expr</dt>
                                    <dd>String of a document key or an array of comma-separated
                                        document keys.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl><b><codeph>USE KEYS</codeph> Example 1:</b> Select a single document by its
                document
                        key.</p><codeblock>SELECT *
FROM `travel-sample` 
USE KEYS "airport_1254";</codeblock>Results:<codeblock>[
  {
    "travel-sample": {
      "airportname": "Calais Dunkerque",
      "city": "Calais",
      "country": "France",
      "faa": "CQF",
      "geo": {
        "alt": 12,
        "lat": 50.962097,
        "lon": 1.954764
      },
      "icao": "LFAC",
      "id": 1254,
      "type": "airport",
      "tz": "Europe/Paris"
    }
  }
]</codeblock><p><b><codeph>USE
                        KEYS</codeph> Example 2:</b> Select multiple documents by their document
                keys.</p><codeblock>SELECT *
FROM `travel-sample` 
USE KEYS ["airport_1254","airport_1255"];</codeblock>Results:<codeblock>[
  {
    "travel-sample": {
      "airportname": "Calais Dunkerque",
      "city": "Calais",
      "country": "France",
      "faa": "CQF",
      "geo": {
        "alt": 12,
        "lat": 50.962097,
        "lon": 1.954764
      },
      "icao": "LFAC",
      "id": 1254,
      "type": "airport",
      "tz": "Europe/Paris"
    }
  },
  {
    "travel-sample": {
      "airportname": "Peronne St Quentin",
      "city": "Peronne",
      "country": "France",
      "faa": null,
      "geo": {
        "alt": 295,
        "lat": 49.868547,
        "lon": 3.029578
      },
      "icao": "LFAG",
      "id": 1255,
      "type": "airport",
      "tz": "Europe/Paris"
    }
  }
]</codeblock></section>
        <section id="select-expr">
            <title>( select-expr )</title>
            <p>Use parenthesis to specify a N1QL <codeph>SELECT</codeph> expression of input
                objects. </p>
            <p><b>Arguments</b></p>
            <p><dl>
                    <dlentry>
                        <dt>select-expr</dt>
                        <dd>[Required] The N1QL <codeph>SELECT</codeph> query of input objects.</dd>
                    </dlentry>
                </dl><b>Example 1:</b> A <codeph>SELECT</codeph> clause inside a
                    <codeph>FROM</codeph> clause.</p>
            <p>List all <codeph>Gillingham</codeph> landmark names from a subset of all landmark
                names and
                addresses.<codeblock>SELECT name, city
FROM <b>(SELECT id, name, address, city 
      FROM `travel-sample` 
      WHERE type = "landmark") as Landmark_Info</b>
WHERE city = "Gillingham";</codeblock>Results:<codeblock>[
  {
    "city": "Gillingham",
    "name": "Royal Engineers Museum"
  },
  {
    "city": "Gillingham",
    "name": "Hollywood Bowl"
  },
  {
    "city": "Gillingham",
    "name": "Thai Won Mien"
  },
  {
    "city": "Gillingham",
    "name": "Spice Court"
  },
  {
    "city": "Gillingham",
    "name": "Beijing Inn"
  },
  {
    "city": "Gillingham",
    "name": "Ossie's Fish and Chips"
  }
]</codeblock>For
                more details and examples, see <xref href="selectclause.dita#topic_SELECT_Clause"
                    >SELECT Clause</xref>.</p>
        </section>
        <section id="section_nkd_3nx_1db">
            <title>from-term</title>
            <p>The from-term defines the input object(s) for the query, and it can be one of the
                following types:<table frame="all" rowsep="1" colsep="1" id="table_vrv_nxx_1db">
                    <tgroup cols="2" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="3*"/>
                        <thead>
                            <row>
                                <entry>Type</entry>
                                <entry>Example</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><xref href="#topic_rnt_zfk_np/sec_from-keyspace"
                                        format="dita">keyspace identifier</xref></entry>
                                <entry><codeph>`travel-sample`</codeph></entry>
                            </row>
                            <row>
                                <entry><xref href="index.dita#n1ql-lang-ref">generic
                                        expression</xref></entry>
                                <entry><codeph>20+10 AS Total</codeph></entry>
                            </row>
                            <row>
                                <entry><xref href="subqueries.dita#topic_9">subquery</xref></entry>
                                <entry><codeph>SELECT t1.country, ARRAY_AGG(t1.city),
                                        SUM(t1.city_cnt) AS apnum</codeph><p><codeph>FROM
                                                </codeph><codeph><b>(SELECT city, city_cnt,
                                                ARRAY_AGG(airportname) AS apnames,
                                            country</b></codeph></p><p><codeph>
                                            <b>FROM `travel-sample`</b></codeph></p><p><codeph>
                                            <b>WHERE type = "airport"</b></codeph></p><p><codeph>
                                            <b>GROUP BY city, country</b></codeph></p><p><codeph>
                                            <b>LETTING city_cnt = COUNT(city) ) AS
                                        t1</b></codeph></p><p><codeph>WHERE t1.city_cnt >
                                            5;</codeph></p></entry>
                            </row>
                            <row>
                                <entry>previous <xref href="#topic_rnt_zfk_np/section_ek1_jnx_1db"
                                        format="dita">join</xref>, <xref
                                        href="#topic_rnt_zfk_np/section_tc1_nnx_1db" format="dita"
                                        >nest</xref>, or <xref href="#topic_rnt_zfk_np/unnest"
                                        format="dita">unnest</xref></entry>
                                <entry><codeph>SELECT *</codeph><p><codeph>FROM `travel-sample` AS
                                            rte</codeph></p><p><codeph>
                                            <b>JOIN</b></codeph><codeph> `travel-sample` AS
                                            aln</codeph></p><p><codeph>    ON rte.airlineid =
                                            META(aln).id</codeph></p><p><codeph>
                                            <b>NEST</b></codeph><codeph> `travel-sample` AS
                                            lmk</codeph></p><p><codeph>        ON aln.landmarkid =
                                            META(lmk).id;</codeph></p></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>For more details with examples, click the above links.</p>
            <p>
                <note>Couchbase Server version 4.6.2 adds support for <xref
                        href="http://docs-build.sc.couchbase.com/server/2059/n1ql/n1ql-language-reference/from.html#concept_rnt_zfk_np__section_fkc_ftt_nz"
                        format="html" scope="external"><u>generic expression</u></xref> in the
                    from-term. Prior Couchbase Server versions support only the other two
                    types.</note>
            </p>
        </section>
        <section id="section_ek1_jnx_1db"><title>ANSI JOIN Clause</title><p><i>(Introduced in
                    Couchbase Server Enterprise Edition 5.5)</i></p><p><note>ANSI JOIN (and <xref href="#topic_rnt_zfk_np/section_tc1_nnx_1db" format="dita">ANSI
                        NEST</xref>) clauses have much more flexible functionality than their
                    earlier INDEX and LOOKUP equivalents. Since these are standard compliant and
                    more flexible, we recommend you to use ANSI JOIN (and ANSI NEST) exclusively,
                    where possible.</note><b>Purpose</b></p><p>To be closer to standard SQL syntax,
                ANSI JOIN can join arbitrary fields of the documents and can be chained
                together.</p><p>The following table lists the JOIN types currently supported.<table
                    frame="all" rowsep="1" colsep="1" id="table_s4l_qby_1db">
                    <tgroup cols="3" align="left">
                        <colspec colname="c1" colnum="1" colwidth="2*"/>
                        <colspec colname="c2" colnum="2" colwidth="1*"/>
                        <colspec colname="c3" colnum="3" colwidth="2*"/>
                        <thead>
                            <row>
                                <entry>Join Type</entry>
                                <entry>Remarks</entry>
                                <entry>Example</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><b
                                        id="docs-internal-guid-5edc3eee-ed0b-ee43-3492-b672460d5600"
                                        >[INNER] JOIN ... ON</b></entry>
                                <entry morerows="1">INNER JOIN and LEFT OUTER JOIN can be mixed in
                                    any number and/or order.</entry>
                                <entry><codeph>SELECT *</codeph><p><codeph>FROM `travel-sample`
                                            r</codeph></p><p><codeph><b>JOIN</b></codeph><codeph>
                                            `travel-sample`
                                            a</codeph></p><p><codeph><b>ON</b></codeph><codeph>
                                            r.airlineid = META(a).id</codeph></p><p><codeph>WHERE
                                            a.country = "France"</codeph></p></entry>
                            </row>
                            <row>
                                <entry><b
                                        id="docs-internal-guid-5edc3eee-ed0c-4735-e067-210e8b069452"
                                        >LEFT [OUTER] JOIN ... ON</b></entry>
                                <entry><codeph>SELECT *</codeph><p><codeph>FROM `travel-sample`
                                            r</codeph></p><p><codeph><b>LEFT
                                            JOIN</b></codeph><codeph> `travel-sample`
                                                a</codeph></p><p><codeph><b>ON</b></codeph><codeph>
                                            r.airlineid = META(a).id</codeph></p><p><codeph>WHERE
                                            r.sourceairport = "SFO"</codeph></p></entry>
                            </row>
                            <row>
                                <entry><b
                                        id="docs-internal-guid-5edc3eee-ed0c-7cfd-a383-bc3ec2216b2c"
                                        >RIGHT [OUTER] JOIN ... ON</b></entry>
                                <entry>RIGHT OUTER JOIN can only be the first join specified in a
                                    FROM clause.</entry>
                                <entry><codeph>SELECT *</codeph><p><codeph>FROM `travel-sample`
                                            r</codeph></p><p><codeph><b>RIGHT
                                            JOIN</b></codeph><codeph> `travel-sample`
                                                a</codeph></p><p><codeph><b>ON</b></codeph><codeph>
                                            r.airlineid = META(a).id</codeph></p><p><codeph>WHERE
                                            r.sourceairport = "SFO"</codeph></p></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table><b>Syntax</b></p><p><image
                    href="images/FROM_ansi-join_RR-clause_5.5.png"
                    id="image_p21_3vz_1db" scale="70"
                    /></p><p><codeblock><i>lhs-expr</i> [<i>join-type</i>] JOIN <i>rhs-expr</i> ON <i>join-clause</i></codeblock><b>Arguments</b></p><p><dl>
                    <dlentry>
                        <dt>lhs-expr</dt>
                        <dd>[Required] Keyspace reference or expression representing the left-hand
                            side of the join clause.</dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt>join-type</dt>
                        <dd>[Optional. Default is <codeph>INNER</codeph>] String representing the
                            type of join.</dd>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt><codeph>INNER</codeph></dt>
                                    <dd>[Optional. Default is <codeph>INNER</codeph>]</dd>
                                    <dd>For each joined object produced, both the left-hand side and
                                        right-hand side source objects of the <codeph>ON</codeph>
                                        clause must be non-MISSING and non-NULL.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>LEFT [OUTER]</codeph></dt>
                                    <dd>[Optional. Query Service interprets <codeph>LEFT</codeph> as
                                            <codeph>LEFT OUTER</codeph>]</dd>
                                    <dd>For each joined object produced, only the left-hand source
                                        objects of the <codeph>ON</codeph> clause must be
                                        non-MISSING and non-NULL</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>RIGHT [OUTER]</codeph></dt>
                                    <dd>[Optional. Query Service interprets <codeph>RIGHT</codeph>
                                        as <codeph>RIGHT OUTER</codeph>]</dd>
                                    <dd>For each joined object produced, only the right-hand source
                                        objects of the <codeph>ON</codeph> clause must be
                                        non-MISSING and non-NULL</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt><codeph>JOIN</codeph> rhs-expr</dt>
                        <dd>[Required] Keyspace reference or expression representing the right-hand
                            side of the join clause.</dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt><codeph>ON</codeph> join-clause</dt>
                        <dd>[Required] Boolean expression representing the join condition between
                            the left-hand side expression and the right-hand side expression, which
                            can be fields, constant expressions or any complex N1QL expression.</dd>
                    </dlentry>
                </dl><b>ANSI Join Example 1:</b> Inner Join.</p><p>List the source airports and
                airlines that fly into SFO, where only the non-null <codeph>route</codeph> documents
                join with matching <codeph>airline</codeph>
                    documents.<codeblock>SELECT route.airlineid, airline.name, route.sourceairport, route.destinationairport 
<b>FROM `travel-sample` route 
INNER JOIN `travel-sample` airline
ON route.airlineid = META(airline).id</b>
WHERE route.type = "route"
AND route.destinationairport = "SFO"
ORDER BY route.sourceairport;</codeblock>Results:<codeblock>[
  {
    "airlineid": "airline_5209",
    "destinationairport": "SFO",
    "name": "United Airlines",
    "sourceairport": "ABQ"
  },
  {
    "airlineid": "airline_5209",
    "destinationairport": "SFO",
    "name": "United Airlines",
    "sourceairport": "ACV"
  },
  {
    "airlineid": "airline_5209",
    "destinationairport": "SFO",
    "name": "United Airlines",
    "sourceairport": "AKL"
  },
...</codeblock><b>ANSI
                    Join Example 2:</b> Left Outer Join of U.S. airports in the same city as a
                landmark.</p><p>List the airports and landmarks in the same city, ordered by the airports.
                <codeblock>SELECT DISTINCT  MIN(aport.airportname) AS Airport__Name, 
                 MIN(lmark.name) AS Landmark_Name,
                 MIN(aport.tz) AS Landmark_Time
FROM `travel-sample` aport 
<b>LEFT JOIN</b> `travel-sample` lmark
  ON aport.city = lmark.city
  AND lmark.country = "United States"
  AND lmark.type = "landmark"
WHERE aport.type = "airport"
GROUP BY lmark.name
ORDER BY lmark.name;</codeblock></p><p>Results:<codeblock>[
  {
    "Airport__Name": "San Francisco Intl",
    "Landmark_Name": "&amp;quot;Hippie Temptation&amp;quot; house",
    "Landmark_Time": "America/Los_Angeles"
  },
  {
    "Airport__Name": "Los Angeles Intl",
    "Landmark_Name": "101 Coffee Shop",
    "Landmark_Time": "America/Los_Angeles"
  },
  {
    "Airport__Name": "San Francisco Intl",
    "Landmark_Name": "1015",
    "Landmark_Time": "America/Los_Angeles"
  },
  {
    "Airport__Name": "San Francisco Intl",
    "Landmark_Name": "1235 Masonic Ave",
    "Landmark_Time": "America/Los_Angeles"
  },
...</codeblock><b>ANSI
                    Join Example 3:</b> RIGHT OUTER JOIN of Example #2.</p><p>List the airports and landmarks in the same city, ordered by the landmarks.<note>The LEFT OUTER
                    JOIN will list all left-side results regardless of matching right-side
                    documents; while the RIGHT OUTER JOIN will list all right-side results
                    regardless of matching left-side
                    documents.</note><codeblock>SELECT DISTINCT  MIN(aport.airportname) AS Airport_Name, 
                 MIN(lmark.name) AS Landmark_Name,
                 MIN(aport.tz) AS Landmark_Time
FROM `travel-sample` aport 
RIGHT JOIN `travel-sample` lmark
  ON aport.city = lmark.city
  AND aport.type = "airport"
  AND aport.country = "United States"
WHERE lmark.type = "landmark"
GROUP BY lmark.name
ORDER BY lmark.name;</codeblock>Results:<codeblock>[
  {
    "Airport_Name": "San Francisco Intl",
    "Landmark_Name": "&amp;quot;Hippie Temptation&amp;quot; house",
    "Landmark_Time": "America/Los_Angeles"
  },
  {
    "Airport_Name": "London-Corbin Airport-MaGee Field",
    "Landmark_Name": "02 Shepherd's Bush Empire",
    "Landmark_Time": "America/New_York"
  },
  {
    "Airport_Name": "Los Angeles Intl",
    "Landmark_Name": "101 Coffee Shop",
    "Landmark_Time": "America/Los_Angeles"
  },
  {
    "Airport_Name": "San Francisco Intl",
    "Landmark_Name": "1015",
    "Landmark_Time": "America/Los_Angeles"
  },
...</codeblock><b>ANSI
                    Join Example #4:</b> In the <codeph>`beer-sample`</codeph> bucket, use an ANSI
                JOIN to list the beer names and breweries that are in the state Wisconsin
                    (<codeph>WI</codeph>). First, create an index with
                    <codeph>beer.brewry_id</codeph> as the leading
                key.<codeblock>CREATE INDEX beer_brewery ON `beer-sample` (brewery_id) 
WHERE type = "beer"

SELECT META(brewery).id bid, META(beer).id, brewery.name brewery_name,
       beer.name beer_name
FROM `beer-sample` brewery 
JOIN `beer-sample` beer
  ON beer.brewery_id = LOWER(REPLACE(brewery.name, " ", "_"))
WHERE beer.type = "beer"
  AND brewery.type = "brewery"
  AND brewery.state = "WI";</codeblock>Results:<codeblock>[
  {
    "beer_name": "Dank",
    "bid": "oso",
    "brewery_name": "Oso",
    "id": "oso-dank"
  }
  ]</codeblock>Visual
                Explain Plan:<image href="images/FROM_AnsiJoin-Ex4-BeerVisual1.png"
                    id="image_xxm_2k1_bdb"/></p><p>If you add <codeph>name</codeph> as the second
                index key to the <codeph>beer_brewery</codeph>
                index:<codeblock>CREATE INDEX beer_brewery_name ON `beer-sample` (brewery_id, <b>name</b>) 
WHERE type = "beer"</codeblock>...
                then you will get covering index scan, as shown in the Visual Explain
                    Plan:</p><p><image
                    href="images/FROM_AnsiJoin-Ex4-BeerVisual2.png"
                    id="image_fxp_gk1_bdb"/></p><b>Limitations</b><p>The following Join types are
                currently not supported:<ul id="ul_qhf_lk1_bdb">
                    <li><codeph>RIGHT OUTER JOIN</codeph> is only supported when it’s the only join
                        in the query; or in a chain of joins, the <codeph>RIGHT OUTER JOIN</codeph>
                        must be the first join in the chain.</li>
                    <li>No mixing of new ANSI Join syntax with Lookup/Index Join syntax in the same
                        FROM clause.</li>
                    <li>The right-hand-side of any join must be a keyspace. Expressions, subqueries,
                        or other join combinations cannot be on the right-hand-side of a join.</li>
                    <li>A join can only be executed when appropriate index exists on the inner side
                        of the join.</li>
                    <li>Adaptive indexes are not considered when selecting indexes on inner side of
                        the join.</li>
                </ul></p></section>
        <section id="section_lbw_jnx_1db">
            <title>ANSI JOIN Hints (HASH &amp; NL)</title>
            <p><i>(Introduced in Couchbase Server Enterprise Edition 5.5)</i></p>
            <p>Couchbase Server Enterprise Edition supports two join methods for performing ANSI
                Join: nested-loop join and hash join. The default join method is nested-loop join.
                Two corresponding join hints are introduced: <codeph>USE HASH</codeph> and
                    <codeph>USE NL</codeph>.</p>
            <p>Hash join is only considered when the<codeph> USE HASH </codeph>hint is specified,
                and it requires at least one equality predicate between the left-hand side and
                right-hand side. In such cases, if a hash join is chosen successfully, then that’ll
                be the join method used for this join. If the hash join cannot be generated, then
                the planner will further consider nested-loop join and will either generate a
                nested-loop join or return an error for the join.</p>
            <p>If no join hint is specified or USE NL hint is specified, then nested-loop join is
                considered.</p>
            <p>
                <note>For Community Edition (CE), any specified<codeph> USE HASH </codeph>hint will
                    be silently ignored and only nested-loop join is considered by the
                    planner.</note>
            </p>
            <p><b>USE HASH hint</b></p>
            <p>The<codeph> USE HASH </codeph>hint is similar to the existing<codeph> USE INDEX
                    </codeph>o<codeph>r USE KEYS </codeph>hint in that the<codeph> USE HASH
                </codeph>hint can be specified after a keyspace reference in an ANSI Join
                specification. There are two versions of the<codeph> USE HASH </codeph>hint that
                indicate whether the keyspace is to be used as:<ul id="ul_f2b_2l1_bdb">
                    <li>The build side of the hash join --<codeph> USE HASH(build)</codeph></li>
                    <li>The probe side of the hash join --<codeph> USE HASH(probe)</codeph></li>
                </ul></p>
            <p>A hash join has two sides: a <codeph>BUILD</codeph> and a <codeph>PROBE</codeph>. The
                    <codeph>BUILD</codeph> side of the join will be used to create an in-memory hash
                table. The <codeph>PROBE</codeph> side will use that table to find matches and
                perform the join. Typically, this means you want the <codeph>BUILD</codeph> side to
                be used on the smaller of the two sets. However, you can only supply one hash hint,
                and only to the right side of the join. So if you specify <codeph>BUILD</codeph> on
                the right side, then you are implicitly using <codeph>PROBE</codeph> on the left
                side (and vice versa).</p>
            <p><b>USE HASH Example 1:</b> PROBE</p>
            <p>The keyspace <codeph>aline</codeph> is to be joined (with <codeph>rte</codeph>) using
                hash join, and <codeph>aline</codeph> is used as the probe side of the hash
                    join.<codeblock>SELECT COUNT(1) AS Total_Count
FROM `travel-sample` rte 
INNER JOIN `travel-sample` aline 
<b>USE HASH (PROBE)</b>
ON (rte.airlineid = META(aline).id)
WHERE rte.type = "route";</codeblock>Results:<codeblock>[
  {
    "Total_Count": 17629
  }
]</codeblock><b>USE
                    HASH Example 2:</b> BUILD</p>
            <p>This is effectively the same query as the previous example, except the two keyspaces
                are switched, and here the <codeph>USE HASH(BUILD)</codeph> hint is used, indicating
                the hash join should use <codeph>rte</codeph> as the build
                    side.<codeblock>SELECT COUNT(1) AS Total_Count
FROM `travel-sample` aline 
INNER JOIN `travel-sample` rte 
<b>USE HASH (BUILD)</b>
ON (rte.airlineid = META(aline).id)
WHERE rte.type = "route";</codeblock>Results:<codeblock>[
  {
    "Total_Count": 17629
  }
]</codeblock><b>USE
                    NL hint</b></p>
            <p>This join hint instructs the planner to use nested-loop join (NL join) for the join
                being considered. Since nested-loop join is the default path, the <codeph>USE
                    NL</codeph> hint is not required.</p>
            <p>USE NL
                    Example:<codeblock>SELECT COUNT(1) AS Total_Count
FROM `travel-sample` rte 
INNER JOIN `travel-sample` aline 
<b>USE NL</b>
ON (rte.airlineid = META(aline).id)
WHERE rte.type = "route";</codeblock><note>The
                    join hint for the first join should be specified on the 2nd keyspace reference,
                    and the join hint for the second join should be specified on the 3rd keyspace
                    reference, etc. If a join hint is specified on the first keyspace, an error is
                    returned.</note><b>Multiple hints</b></p>
            <p>You can use only one join hint (USE HASH or USE NL) together with only one other hint
                (USE INDEX or USE KEYS) for a total of two hints. The order of the two hints doesn't
                matter.</p>
            <p>When multiple hints are being specified, use only one <codeph>USE</codeph> keyword
                with one following the other, as in the following examples.</p>
            <p><b>Multiple hint Example 1:</b> USE INDEX with USE HASH.</p>
            <p><codeblock>SELECT COUNT(1) AS Total_Count
FROM `travel-sample` rte 
INNER JOIN `travel-sample` aline 
<b>USE INDEX idx1 HASH (PROBE)</b>
ON (rte.airlineid = META(aline).id)
WHERE rte.type = "route";</codeblock><b>Multiple
                    hint Example 2:</b> USE HASH with USE
                KEYS.<codeblock>SELECT COUNT(1) AS Total_Count
FROM `travel-sample` rte 
INNER JOIN `travel-sample` aline 
<b>USE HASH (PROBE) KEYS ["airline_key1", "airline_key2", "airline_key3"]</b>
ON (rte.airlineid = META(aline).id)
WHERE rte.type = "route";</codeblock>When
                chosen, the hash join will always work; the restrictions are on any USE KEYS hint
                    clause:<ul id="ul_e2f_gzg_bdb">
                    <li>Must not depend on any previous keyspaces.</li>
                    <li>The expression must be constants, host variables, etc. </li>
                    <li>Must not contain any subqueries. </li>
                </ul><note>If the USE KEYS hint contains references to other keyspaces or
                    subqueries, then the USE HASH hint will be ignored and nested-loop join will be
                    used instead.</note></p>
        </section>
        <section id="section_gk3_lnx_1db">
            <title>ANSI JOIN and Arrays</title>
            <p>ANSI JOIN provides great flexibility since the <codeph>ON</codeph> clause of an ANSI
                JOIN can be any expression as long as it evaluates to TRUE or FALSE. Below are
                different join scenarios involving arrays and ways to handle each
                    scenario.<note>These buckets and indexes will be used throughout this section's
                    array scenarios. As a convention, when a field name starts with<codeph> a
                    </codeph>it is an array, so each bucket has two array fields and two regular
                    fields. Also, both <codeph>_idx1</codeph> indexes index each element of its
                    array, while both <codeph>_idx2</codeph> indexes use its entire array as the
                    index key.<p><codeph>bucket b1 (a11, a12, c11, c12)</codeph></p><codeph>bucket
                        b2 (a21, a22, c21, c22)</codeph><p><codeph>CREATE INDEX b1_idx1 ON b1 (c11,
                            c12, DISTINCT a11)</codeph></p><codeph>CREATE INDEX b1_idx2 ON b1
                        (a12)</codeph><p><codeph>CREATE INDEX b2_idx1 ON b2 (c21, c22, DISTINCT
                            a21)</codeph></p><p><codeph>CREATE INDEX b2_idx2 ON b2
                        (a22)</codeph></p></note><b>ANSI JOIN with no arrays</b></p>
            <p>In this scenario, there is no involvement of arrays in the join. These are just
                straight-forward
                joins:<codeblock>SELECT *
FROM b1 
JOIN b2 
  ON b1.c11 = b2.c21 
  AND b2.c22 = 100 
WHERE b1.c12 = 10;</codeblock>Here
                the joins are using non-array fields of each keyspace.</p>
            <p>The following case also falls in this
                scenario:<codeblock>SELECT *
FROM b1 
JOIN b2 
  ON b1.c11 = b2.c21 
  AND b2.c22 = 100 
  AND ANY v IN b2.a21 SATISFIES v = 10 END 
WHERE b1.c12 = 10;</codeblock>In
                this example, although there is an ANY predicate on the right-hand side array
                    <codeph>b2.a21</codeph>, the ANY predicate does not involve any joins, and thus,
                as far as the join is concerned, it is still a 1-to-1 join.
                Similarly:<codeblock>SELECT *
FROM b1
JOIN b2 
  ON b1.c11 = b2.c21 
WHERE b1.c11 = 10 
  AND b1.c12 = 100 
  AND ANY v IN b1.a11 SATISFIES v = 20 END;</codeblock>In
                this case the ANY predicate is on the left-hand side array <codeph>b1.a11</codeph>;
                however, similar to above, the ANY predicate does not involve any joins, and thus
                the join is still 1-to-1. We can even have ANY predicates on both
                sides:<codeblock>SELECT *
FROM b1 
JOIN b2 
  ON b1.c11 = b2.c21 
  AND b2.c22 = 100 
  AND ANY v IN b2.a21 SATISFIES v = 10 END 
WHERE b1.c11 = 10 
  AND b1.c12 = 100 
  AND ANY v IN b1.a11 SATISFIES v = 10 END;</codeblock>Again,
                the ANY predicates do not involve any join, and the join is still 1-to-1.</p>
            <p><b>ANSI JOIN with entire array as index key</b></p>
            <p>As a special case, it is possible to perform ANSI JOIN on an entire array as a join
                key:<codeblock>SELECT * 
FROM b1 
JOIN b2 
  ON b1.a21 = b2.a22 
WHERE b1.c11 = 10 
  AND b1.c12 = 100;</codeblock>In
                this case, the entire array must match each other for the join to work. For all
                practical purposes, the array here is treated as a scalar since there is no logic to
                iterate through elements of an array here. The entire array is used as an index key
                    (<codeph>b2_idx2</codeph>) and as such, an entire array is used as an index span
                to probe the index. The join here can also be considered as 1-to-1.</p>
            <p><b>ANSI JOIN involving right-hand-side arrays</b></p>
            <p>In this scenario, the join involves an array on the right-hand side
                keyspace:<codeblock>SELECT * 
FROM b1 
JOIN b2 
  ON b2.c21 = 10 
  AND b2.c22 = 100 
  AND ANY v IN b2.a21 SATISFIES v = b1.c12 END 
WHERE b1.c11 = 10;</codeblock>In
                this case, the ANY predicate involves a join, and thus, effectively we are joining
                    <codeph>b1</codeph> with elements of the <codeph>b2.a21</codeph> array. This now
                becomes a 1-to-many join. Note that we use an ANY clause for this scenario since
                it’s a natural extension of the existing support for array indexes; the only
                difference is for index span generation, we now can have a potential join
                expression. Array indexes can be used for join in this scenario.</p>
            <p><b>ANSI JOIN involving left-hand-side arrays</b></p>
            <p>This is a slightly more complex scenario, where the array reference is on the
                left-hand side of the join, and it’s a many-to-1 join. There are two alternative
                ways to handle the scenario where the array appears on the left-hand side of the
                join.</p>
            <p>
                <dl>
                    <dlentry>
                        <dt><b>Alternative #1: use UNNEST</b></dt>
                        <dd>This alternative will flatten the left-hand side array first, before
                            performing the
                            join:<codeblock>SELECT *
FROM b1 UNNEST b1.a12 AS ba1 
JOIN b2 
  ON ba1 = b2.c22 
  AND b2.c21 = 10 
WHERE b1.c11 = 10 
  AND b1.c12 = 100;</codeblock>The
                                <xref href="#topic_rnt_zfk_np/unnest" format="dita">UNNEST</xref>
                            operation is used to flatten the array, turning one left-hand side
                            document into multiple documents; and then for each one of them, join
                            with the right-hand side. This way, by the time join is being performed,
                            it is a regular join, since the array is already flattened in the UNNEST
                            step.</dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt><b>Alternative #2: use IN clause</b></dt>
                        <dd>This alternative uses the IN clause to handle the
                            array:<codeblock>SELECT *
FROM b1 
JOIN b2 
  ON b2.c22 IN b1.a12 AND b2.c21 = 10 
WHERE b1.c11 = 10 AND b1.c12 = 100;</codeblock>By
                            using the <xref href="indexing-arrays.dita#topic_hv4_sbr_w5">IN</xref>
                            clause, the right-hand side field value can match any of the elements of
                            the left-hand side array. Conceptually, we are using each element of the
                            left-hand side array to probe the right-hand side index.</dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt><b>Differences between the two alternatives</b></dt>
                        <dd>There is a semantical difference between the two alternatives. With
                            UNNEST, we are first turning one left-hand side document into multiple
                            documents and then performing the join. With IN-clause, there is still
                            only one left-hand side document, which can then join with one or more
                            right-hand side documents. Thus:<ul id="ul_c21_f3h_bdb">
                                <li>If the array contains duplicate values, <ul id="ul_n25_f3h_bdb">
                                        <li>the UNNEST method treats each duplicate as an individual
                                            value and thus duplicated results will be returned;</li>
                                        <li>the IN clause method will not duplicate the result.
                                        </li>
                                    </ul></li>
                                <li>If no duplicate values exists and we are performing inner join,
                                        <ul id="ul_ufx_h3h_bdb">
                                        <li>then the two alternatives will likely give the same
                                            result. </li>
                                    </ul></li>
                                <li>If outer join is performed, assuming there are N elements in the
                                    left-hand side array, and assuming there is at most one matching
                                    document from the right-hand side for each element of the array,
                                        <ul id="ul_b5j_j3h_bdb">
                                        <li>the UNNEST method will produce N result documents;</li>
                                        <li>the IN clause method may produce &lt; N result documents
                                            if some of the array elements do not have matching
                                            right-hand side documents.</li>
                                    </ul></li>
                            </ul></dd>
                    </dlentry>
                </dl>
            </p>
            <p><b>ANSI JOIN with arrays on both sides</b></p>
            <p>If the join involves arrays on both sides, then we can combine the approaches above,
                i.e., using ANY clause to handle the right-hand side array and either UNNEST or IN
                clause to handle the left-hand side array. For
                example:<codeblock>SELECT *
FROM b1 
UNNEST b1.a12 AS ba1 
  JOIN b2 
    ON ANY v IN b2.a21 SATISFIES v = ba1 END
    AND b2.c21 = 10 
    AND b2.c22 = 100 
WHERE b1.c11 = 10 
  AND b1.c12 = 100;</codeblock>or<codeblock>SELECT * 
FROM b1 
JOIN b2 
  ON ANY v IN b2.a21 SATISFIES v IN b1.a12 END 
  AND b2.c21 = 10 
  AND b2.c22 = 100 
WHERE b1.c11 = 10 
  AND b1.c12 = 100;</codeblock></p>
        </section>
        <section id="lookup-join-clause">
            <title>Lookup JOIN Clause</title>
            <p><i>(Introduced in Couchbase Server 4.0)</i></p>
            <p>The <codeph>JOIN</codeph> clause enables you to create new input objects by combining
                two or more source objects. </p>
            <p>Lookup joins allow only left-to-right joins, which means the ON KEYS expression must
                produce a document key which is then used to retrieve documents from the right-hand
                side keyspace. Couchbase Server version 4.1 and earlier supported only lookup
                joins.</p>
            <p><b>Syntax</b></p>
            <p><image
                    href="images/FROM_lookup-join-clause.png"
                    id="image_asp_x3h_bdb" scale="70"/></p>
            <codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ] ON KEYS <varname>on-keys-clause</varname></codeblock>
            <p id="lookup-join">
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>INNER</codeph></dt>
                                                <dd>For each joined object produced, both the
                                                  left-hand and right-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT OUTER</codeph></dt>
                                                <dd>For each joined object produced, only the
                                                  left-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>from-path</dt>
                                    <dd>[Required] Keyspace reference for right-hand side of lookup
                                        join. For details, see <xref
                                            href="#concept_rnt_zfk_np/keyspaces" format="dita"
                                            >Keyspaces</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>alias (Optionally, <codeph>AS</codeph> alias)</dt>
                                    <dd>[Optional] To assign another name. For details, see <xref
                                            href="#concept_rnt_zfk_np/as" format="dita">AS
                                            Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>ON KEYS</codeph> on-keys-clause</dt>
                                    <dd>[Required] String or expression representing the primary
                                        keys of the documents for the right-hand side keyspace.</dd>
                                    <dd>The <codeph>ON KEYS</codeph> expression produces one or more
                                        document keys for the right-hand side document.</dd>
                                    <dd>The <codeph>ON KEYS</codeph> expression can produce an array
                                        of document keys.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Return Values</dt>
                        <dd>If <codeph>LEFT</codeph> or <codeph>LEFT OUTER</codeph> is specified,
                            then a left outer join is performed.</dd>
                        <dd>At least one joined object is produced for each left-hand source
                            object.</dd>
                        <dd>If the right-hand source object is <codeph>NULL</codeph> or
                                <codeph>MISSING</codeph>, then the joined object's right-hand side
                            value is also <codeph>NULL</codeph> or <codeph>MISSING</codeph>
                            (omitted), respectively. </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Limitations</dt>
                        <dd>Lookup JOINs can be chained with other lookup joins/nests or index
                            joins/nests, but they cannot be mixed with an ANSI JOIN or ANSI
                            NEST.</dd>
                    </dlentry>
                </dl>
            </p>
            <p>
                <b>Lookup JOIN Example 1:</b> route JOIN airline ON KEYS route.airlineid.</p>
            <p> List all airlines and non-stop routes from SFO in the <codeph>travel-sample</codeph>
                keyspace.
                <codeblock>SELECT DISTINCT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline
<b>FROM `travel-sample` route 
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid </b>
WHERE route.type = "route" 
AND airline.type = "airline" 
AND route.sourceairport = "SFO" 
AND route.stops = 0
LIMIT 4;         </codeblock></p>
            <p>Results:<codeblock>[
  {
    "airline": "VX",
    "callsign": "REDWOOD",
    "destinationairport": "SAN",
    "name": "Virgin America",
    "stops": 0
  },
  {
    "airline": "VX",
    "callsign": "REDWOOD",
    "destinationairport": "PHL",
    "name": "Virgin America",
    "stops": 0
  },
  {
    "airline": "B6",
    "callsign": "JETBLUE",
    "destinationairport": "FLL",
    "name": "JetBlue Airways",
    "stops": 0
  },
  {
    "airline": "UA",
    "callsign": "UNITED",
    "destinationairport": "IND",
    "name": "United Airlines",
    "stops": 0
  }
]</codeblock></p>
            <p><b>Lookup JOIN Example 2:</b> route JOIN airline ON KEYS route.airlineid.</p>
            <p>List the schedule of flights from Boston to San Francisco on JETBLUE in the
                    <codeph>travel-sample</codeph>
                keyspace.<codeblock>SELECT DISTINCT airline.name, route.schedule<b>
FROM `travel-sample` route 
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid </b>
WHERE route.type = "route" 
AND airline.type = "airline" 
AND route.sourceairport = "BOS"
AND route.destinationairport = "SFO" 
AND airline.callsign = "JETBLUE";</codeblock></p>
            <p>Results:<codeblock>[
  {
    "name": "JetBlue Airways",
    "schedule": [
      {
        "day": 0,
        "flight": "B6076",
        "utc": "10:15:00"
      },
      {
        "day": 0,
        "flight": "B6321",
        "utc": "00:06:00"
      },
      {
        "day": 1,
        "flight": "B6536",
        "utc": "22:45:00"
      },
      {
        "day": 1,
        "flight": "B6194",
        "utc": "00:51:00"
      },
      {
        "day": 2,
        "flight": "B6918",
        "utc": "23:45:00"
      },
      {
        "day": 2,
        "flight": "B6451",
        "utc": "18:09:00"
      },
      {
        "day": 2,
        "flight": "B6868",
        "utc": "22:04:00"
      },
      {
        "day": 2,
        "flight": "B6621",
        "utc": "11:04:00"
      },
      {
        "day": 3,
        "flight": "B6015",
        "utc": "16:59:00"
      },
      {
        "day": 3,
        "flight": "B6668",
        "utc": "07:22:00"
      },
      {
        "day": 3,
        "flight": "B6188",
        "utc": "01:41:00"
      },
      {
        "day": 3,
        "flight": "B6215",
        "utc": "19:35:00"
      },
      {
        "day": 4,
        "flight": "B6371",
        "utc": "21:37:00"
      },
      {
        "day": 4,
        "flight": "B6024",
        "utc": "10:24:00"
      },
      {
        "day": 4,
        "flight": "B6749",
        "utc": "01:12:00"
      },
      {
        "day": 4,
        "flight": "B6170",
        "utc": "01:14:00"
      },
      {
        "day": 5,
        "flight": "B6613",
        "utc": "08:59:00"
      },
      {
        "day": 5,
        "flight": "B6761",
        "utc": "15:24:00"
      },
      {
        "day": 5,
        "flight": "B6162",
        "utc": "02:42:00"
      },
      {
        "day": 5,
        "flight": "B6341",
        "utc": "21:26:00"
      },
      {
        "day": 5,
        "flight": "B6347",
        "utc": "08:43:00"
      },
      {
        "day": 6,
        "flight": "B6481",
        "utc": "22:08:00"
      },
      {
        "day": 6,
        "flight": "B6549",
        "utc": "21:48:00"
      },
      {
        "day": 6,
        "flight": "B6994",
        "utc": "11:30:00"
      },
      {
        "day": 6,
        "flight": "B6892",
        "utc": "13:27:00"
      }
    ]
  }
]</codeblock></p>
            <p/>
        </section>
        <section id="index-join-clause"><title>Index JOIN Clause</title><p><i>(Introduced in
                    Couchbase Server 4.0)</i></p><p>When Lookup JOINs cannot efficiently join
                left-hand side documents with right-to-left joins and your situation cannot be
                flipped because your predicate needs to be on the left-hand side (such as the above
                Lookup Example #1 where airline documents have no reference to route documents),
                then Index JOINs can be used efficiently without making a Cartesian product of all
                route documents. Index JOINs allow you to flip the direction of your join
                clause.</p><p>Consider the below query similar to the above <i>Lookup Example #1</i>
                with route and airline documents where route.airlineid is the document key of route
                documents and airline documents have no reference to route
                documents:<codeblock>SELECT DISTINCT airline.name, airline.callsign, route.destinationairport,
 route.stops, route.airline
FROM `travel-sample` route 
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid 
WHERE route.type = "route" 
AND airline.type = "airline" 
AND airline.icao = "SEA" 
LIMIT 4;</codeblock>This
                query gets a list of Seattle (<codeph>SEA</codeph>) flights, but getting
                    <codeph>SEA</codeph> flights cannot be efficiently executed without making a
                Cartesian product of all route documents (LHS) with all airline documents
                (RHS).</p><p>This query cannot use any index on airline to directly access SEA
                flights because airline is on the RHS.</p><p>Also, you cannot rewrite the query to
                put the airline document on the LHS (to use any index) and the route document on the
                RHS because the airline documents (on the LHS) have no primary keys to access the
                route documents (on the RHS).</p><p>Using index joins, the same query can be written
                as:
                <codeblock>Required Index:
  CREATE INDEX route_airlineid ON `travel-sample`(airlineid) WHERE type="route";
                 
Optional index:
  CREATE INDEX <b>airline_icao</b> ON `travel-sample`(<b>icao</b>) WHERE type="<b>airline</b>";

Resulting in:
  SELECT * FROM `travel-sample` airline 
    JOIN `travel-sample` route
    ON KEY route.airlineid FOR airline
  WHERE route.type="route" 
  AND airline.type="airline"
  AND airline.icao = "SEA";                </codeblock></p><p>If
                you generalize the same query, it looks like the following:
                <codeblock>CREATE INDEX <varname>on-key-for-index-name</varname> <varname>rhs-expression</varname> (<varname>lhs-expression-key</varname>);
                 
SELECT <varname>projection-list</varname> 
FROM <varname>lhs-expression</varname>
JOIN <varname>rhs-expression</varname>
  ON KEY <varname>rhs-expression</varname>.<varname>lhs-expression-key</varname> FOR <varname>lhs-expression</varname>      
[ WHERE <varname>predicates</varname> ] ; </codeblock></p><p>There
                are three important changes in the index scan syntax example above: <ul
                    id="ul_fky_g32_1v">
                    <li><codeph>CREATE INDEX</codeph> on the <codeph>ON KEY</codeph> expression
                            <codeph>route.airlineid</codeph> to access <codeph>route</codeph>
                        documents using <codeph>airlineid</codeph> (which are produced on the
                        LHS).</li>
                    <li>The <codeph>ON KEY route.airlineid FOR airline</codeph> enables N1QL to use
                        the index <codeph>route.airlineid</codeph>.</li>
                    <li>Create any optional index such as <codeph>route.airline</codeph> that can be
                        used on airline (LHS).</li>
                </ul><note>For index joins, the syntax uses <codeph>ON KEY</codeph> (singular)
                    instead of <codeph>ON KEYS</codeph> (plural). This is because Index JOINs'
                        <codeph>ON KEY</codeph> expression must produce a scalar value; whereas
                    Lookup JOINs' <codeph>ON KEYS</codeph> expression can produce either a scalar or
                    an array value. </note></p><p><b>Syntax</b></p><p><image
                    href="images/FROM_index-join-clause.png"
                    id="image_cdn_bc3_bdb" scale="80"/></p><codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ]  ON KEY FOR <varname>on-key-for-clause</varname> </codeblock><p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>LEFT INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT</codeph> or <codeph>LEFT
                                                  INNER</codeph></dt>
                                                <dd>For each joined object produced, both the
                                                  left-hand and right-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT OUTER</codeph></dt>
                                                <dd>For each joined object produced, only the
                                                  left-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>from-path</dt>
                                    <dd>Keyspace reference for right-hand side of an index join. For
                                        details, see <xref href="#concept_rnt_zfk_np/keyspaces"
                                            format="dita">Keyspaces</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>AS</codeph> alias</dt>
                                    <dd>[Optional] To assign another name. For details, see <xref
                                            href="#concept_rnt_zfk_np/as" format="dita">AS
                                            Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>ON KEY</codeph> rhs-expression.lhs-expression-key </dt>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt>rhs-expression</dt>
                                                <dd>Keyspace reference for the right-hand side of
                                                  the index join.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt>lhs-expression-key</dt>
                                                <dd>String or expression representing the attribute
                                                  in rhs-expression referencing the document key for
                                                  lhs-expression.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>FOR lhs-expression</dt>
                                    <dd>Keyspace reference for the left-hand side of the index
                                        join.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
            </p><p><b>Index JOIN Example 1:</b>
                <codeph>ON KEY ... FOR</codeph>.</p><p>The following example counts the number of
                distinct "AA" airline routes for each airport after creating the following index (if
                not already
            created).</p><codeblock>CREATE INDEX route_airlineid ON `travel-sample`(airlineid) WHERE type="route";

SELECT Count(DISTINCT route.sourceairport) AS DistinctAirports
<b>FROM `travel-sample` airline 
  JOIN `travel-sample` route 
  ON KEY route.airlineid FOR airline </b>
WHERE route.type = "route" 
AND airline.type = "airline" 
AND airline.iata = "AA"; </codeblock>Results:<?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?><codeblock><?oxy_custom_end?>[
  {
    "DistinctAirports": 429
  }
]</codeblock></section>
        <section id="unnest"><title>UNNEST Clause</title><p>If a document or object contains a
                nested array, UNNEST conceptually performs a join of the nested array with its
                parent object. Each resulting joined object becomes an output of the query. Unnests
                can be chained.</p><p><b>Syntax</b></p><p><image
                    href="images/FROM_unnest-clause_4.0_RR.png"
                    id="image_sg1_dd3_bdb" scale="80"/></p><codeblock>[ <varname>join-type</varname> ] UNNEST <varname>path</varname> [ [ AS ] <varname>alias</varname> ]</codeblock><p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>INNER</codeph></dt>
                                                <dd>For each result object produced, the array
                                                  object in the left-hand side keyspace must be
                                                  non-empty.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT</codeph> or <codeph>LEFT
                                                  OUTER</codeph></dt>
                                                <dd>A left-outer unnest is performed, and at least
                                                  one result object is produced for each left source
                                                  object.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>path</dt>
                                    <dd>[Required] The first path element after each UNNEST must
                                        reference some preceding path.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>alias (optionally, <codeph>AS</codeph> alias)</dt>
                                    <dd>[Required] To assign a name for the unnested item. For
                                        details, see <xref href="#concept_rnt_zfk_np/as"
                                            format="dita">AS Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Return Values</dt>
                        <dd>If the right-hand source object is <codeph>NULL</codeph>,
                                <codeph>MISSING</codeph>, empty, or a non-array value, then the
                            result object's right-side value is <codeph>MISSING</codeph>
                            (omitted).</dd>
                    </dlentry>
                </dl>
            </p><p><b>UNNEST Example 1: </b>UNNEST an array to select an item.</p><p>In the
                `travel-sample` keyspace, flatten the schedule array to get a list of the flights on
                Monday
                (<codeph>1</codeph>).</p><codeblock>SELECT <b>sched</b> 
FROM `travel-sample` 
UNNEST schedule <b>sched</b>
WHERE  <b>sched</b>.day = 1
LIMIT 3;</codeblock><p>Results
                :</p><codeblock>[
  {
    "sched": {
      "day": 1,
      "flight": "AF356",
      "utc": "12:40:00"
    }
  },
  {
    "sched": {
      "day": 1,
      "flight": "AF480",
      "utc": "08:58:00"
    }
  },
  {
    "sched": {
      "day": 1,
      "flight": "AF250",
      "utc": "12:59:00"
    }
  }
]</codeblock>Another
            way to get similar results is by using a Collection Operator to find array items that
            meet our
            criteria:<codeblock>SELECT ARRAY item FOR item IN schedule WHEN item.day = 1 END AS Monday_flights
FROM `travel-sample`
WHERE type = "route"
AND ANY item IN schedule SATISFIES item.day = 1 END
LIMIT 3;</codeblock>However,
            without the <codeph>UNNEST</codeph> clause, the unflattened list results in 3 sets of
            flights instead of only 3 individual
                    flights:<codeblock>[
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF356",
        "utc": "12:40:00"
      },
      {
        "day": 1,
        "flight": "AF480",
        "utc": "08:58:00"
      },
      {
        "day": 1,
        "flight": "AF250",
        "utc": "12:59:00"
      },
      {
        "day": 1,
        "flight": "AF130",
        "utc": "04:45:00"
      }
    ]
  },
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF517",
        "utc": "13:36:00"
      },
      {
        "day": 1,
        "flight": "AF279",
        "utc": "21:35:00"
      },
      {
        "day": 1,
        "flight": "AF753",
        "utc": "00:54:00"
      },
      {
        "day": 1,
        "flight": "AF079",
        "utc": "15:29:00"
      },
      {
        "day": 1,
        "flight": "AF756",
        "utc": "06:16:00"
      }
    ]
  },
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF975",
        "utc": "11:23:00"
      },
      {
        "day": 1,
        "flight": "AF225",
        "utc": "16:05:00"
      }
    ]
  }
]</codeblock><p><b>UNNEST
                    Example 2:</b> Use <codeph>UNNEST</codeph> to collect items from one array to
                use in another query.</p><p>In this example, the <codeph>UNNEST</codeph> clause
                iterates over the <codeph>reviews</codeph> array and collects the
                    <codeph>author</codeph> names of the reviewers who rated the rooms less than a 2
                to be contacted for ways to improve. <codeph>r</codeph> is an element of the array
                generated by the UNNEST
                operation.</p><codeblock>SELECT RAW r.author
FROM `travel-sample` 
UNNEST reviews AS r
WHERE `travel-sample`.type = "hotel"
AND <b>r.ratings.Rooms &lt; 2</b>
LIMIT 4;</codeblock><p>This
                results
            in:</p><codeblock>[
  "Kayli Cronin",
  "Shanelle Streich",
  "Catharine Funk",
  "Tyson Beatty"
]</codeblock></section>
        <section id="section_tc1_nnx_1db">
            <title>ANSI NEST Clause</title>
            <p><i>(Introduced in Couchbase Server Enterprise Edition 5.5)</i></p>
            <p><note>ANSI NEST (and <xref href="#topic_rnt_zfk_np/section_ek1_jnx_1db" format="dita"
                        >ANSI JOIN</xref>) clauses are much faster and have much more flexible
                    functionality than their earlier INDEX and LOOKUP equivalents, so users are
                    strongly recommended to use ANSI NEST (and ANSI JOIN) exclusively, where
                    possible.</note>ANSI NEST supports more nest types than Couchbase Server version
                4.0's NEST was able. ANSI NEST can nest arbitrary fields of the documents and can be
                chained together.</p>
            <p>The key difference between the currently supported nests and ANSI NEST support is the
                replacement of the current <codeph>ON KEYS</codeph> or <codeph>ON KEY … FOR</codeph>
                clauses with a simple <codeph>ON</codeph> clause. The <codeph>ON KEYS</codeph> or
                    <codeph>ON KEY … FOR</codeph> clauses dictate that those nests can only be done
                on a document key (primary key for a document). The <codeph>ON</codeph> clause can
                contain any expression, and thus it opens up many more nest possibilities that
                Couchbase did not previously support.</p>
            <p><b id="docs-internal-guid-5edc3eee-f437-e104-1f6d-a9791f291d20">Syntax</b></p>
           <p><image
               href="images/FROM_ansi-nest_RR-clause_5.5.png"
                    id="image_wwl_cf3_bdb" scale="80"/></p>
            <p><codeph><i>lhs-expr</i></codeph><codeph>
                    [</codeph><codeph><i>nest-type</i></codeph><codeph>] NEST
                        </codeph><codeph><i>rhs-expr</i></codeph><codeph> ON
                        </codeph><codeph><i>nest-clause</i></codeph></p>
            <p><b id="docs-internal-guid-5edc3eee-f439-8114-b64a-e4635bc90845">Arguments</b></p>
            <p><dl>
                    <dlentry>
                        <dt><b>lhs-expr</b></dt>
                        <dd>[Required] Keyspace reference or expression representing the left-hand
                            side of the nest clause.</dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt><b>nest-type</b></dt>
                        <dd>[Optional. Default is <codeph>INNER</codeph>] String representing the
                            type of nest.</dd>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt><codeph>INNER</codeph></dt>
                                    <dd>[Optional. Default is <codeph>INNER</codeph>]</dd>
                                    <dd>For each nested object produced, both the left-hand and
                                        right-hand source objects must be non-MISSING and
                                        non-NULL.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>LEFT [OUTER]</codeph></dt>
                                    <dd>[Optional. Query Service interprets <codeph>LEFT</codeph> as
                                            <codeph>LEFT OUTER</codeph>]</dd>
                                    <dd>For each nested object produced, only the left-hand source
                                        objects must be non-MISSING and non-NULL.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt><codeph><b>NEST</b></codeph><b> rhs-expr</b></dt>
                        <dd>[Required] Keyspace reference or expression representing the right-hand
                            side of the nest clause.</dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt><codeph><b>ON</b></codeph><b> nest-clause</b></dt>
                        <dd>[Required] Boolean expression representing the nest condition between
                            the left-hand side expression and the right-hand side expression, which
                            can be fields, constant expressions or any complex N1QL expression.</dd>
                    </dlentry>
                </dl><b id="docs-internal-guid-5edc3eee-f440-8b49-9295-51c9be0e6099"
                        ><b>Limitations</b></b></p>
            <p>The following nest types are currently not supported:<ul id="ul_r5p_3g3_bdb">
                    <li>Full OUTER NEST</li>
                    <li>Cross NEST</li>
                    <li>No mixing of new ANSI NEST syntax with NEST syntax in the same FROM
                        clause.</li>
                    <li>The right-hand-side of any nest must be a keyspace. Expressions, subqueries,
                        or other join combinations cannot be on the right-hand-side of a nest.</li>
                    <li>A nest can only be executed when appropriate index exists on the inner side
                        of the ANSI NEST (similar to current NEST support).</li>
                    <li>Adaptive indexes are not considered when selecting indexes on inner side of
                        the nest</li>
                </ul><b>ANSI NEST Example 1: </b> Inner ANSI NEST</p>
            <p>List the airlines, their plane model (<codeph>equipment</codeph>), and number of
                stops for flights between San Francisco and
                Boston.<codeblock>SELECT r.airline, r.equipment, r.stops
FROM `travel-sample` r
  NEST `travel-sample` a 
  ON r.airlineid = META(a).id
WHERE r.sourceairport = "SFO"
AND r.destinationairport = "BOS";</codeblock>Results:<codeblock>[
  {
    "airline": "B6",
    "equipment": "320",
    "stops": 0
  },
  {
    "airline": "UA",
    "equipment": "752 753 738 739 319 320",
    "stops": 0
  },
  {
    "airline": "VX",
    "equipment": "320",
    "stops": 0
  }
]</codeblock></p>
        </section>
        <section id="nest"><title>Lookup NEST Clause</title><p><i>(Introduced in Couchbase Server
                    4.0)</i></p><p>Nesting is conceptually the inverse of unnesting. Nesting
                performs a join across two keyspaces. But instead of producing a cross-product of
                the left and right inputs, a single result is produced for each left input, while
                the corresponding right inputs are collected into an array and nested as a single
                array-valued field in the result object.</p><b>Syntax</b><p><image
                    href="images/FROM_lookup-nest_4.0_RR.png"
                    id="image_nxv_yg3_bdb" scale="80"/></p><codeblock>[ <varname>join-type</varname> ] NEST <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ] <varname>on-keys-clause</varname></codeblock><p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>INNER</codeph></dt>
                                                <dd>For each result object produced, both the
                                                  left-hand and right-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT</codeph> or <codeph>LEFT
                                                  OUTER</codeph></dt>
                                                <dd>A left-outer unnest is performed, and at least
                                                  one result object is produced for each left source
                                                  object.</dd>
                                                <dd>For each joined object produced, only the
                                                  left-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>from-path</dt>
                                    <dd>[Required] Keyspace reference for right-hand side of lookup
                                        nest. For details, see <xref
                                            href="#concept_rnt_zfk_np/keyspaces" format="dita"
                                            >Keyspaces</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>alias (optionally, <codeph>AS</codeph> alias)</dt>
                                    <dd>[Required] To assign a name for the right-hand side
                                        keyspace. For details, see <xref
                                            href="#concept_rnt_zfk_np/as" format="dita">AS
                                            Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>on-keys-clause</dt>
                                    <dd>[Required] String or expression representing the primary
                                        keys of the documents for the second keyspace.</dd>
                                    <dd>The <codeph>ON KEYS</codeph> expression produces one or more
                                        document keys for the right-hand side document.</dd>
                                    <dd>The <codeph>ON KEYS</codeph> expression can produce an array
                                        of document keys.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Return Values</dt>
                        <dd>If the right-hand source object is NULL, MISSING, empty, or a non-array
                            value, then the result object's right-side value is MISSING
                            (omitted).</dd>
                        <dd>Nests can be chained with other NEST, JOIN, and UNNEST clauses. By
                            default, an INNER NEST is performed. This means that for each result
                            object produced, both the left and right source objects must be
                            non-missing and non-null. The right-hand side result of NEST is always
                            an array or MISSING. If there is no matching right source object, then
                            the right source object is as follows:<table frame="all" rowsep="1"
                                colsep="1" id="table_kbj_2dr_ccb">
                                <tgroup cols="2" align="left">
                                    <colspec colname="c1" colnum="1" colwidth="1*"/>
                                    <colspec colname="c2" colnum="2" colwidth="1*"/>
                                    <thead>
                                        <row>
                                            <entry>If the <codeph>ON KEYS</codeph> expression
                                                evaluates to</entry>
                                            <entry>Then the right-side value is</entry>
                                        </row>
                                    </thead>
                                    <tbody>
                                        <row>
                                            <entry><codeph>MISSING</codeph></entry>
                                            <entry><codeph>MISSING</codeph></entry>
                                        </row>
                                        <row>
                                            <entry><codeph>NULL</codeph></entry>
                                            <entry><codeph>MISSING</codeph></entry>
                                        </row>
                                        <row>
                                            <entry>an array</entry>
                                            <entry>an empty array</entry>
                                        </row>
                                        <row>
                                            <entry>a non-array value</entry>
                                            <entry>an empty array</entry>
                                        </row>
                                    </tbody>
                                </tgroup>
                            </table></dd>
                    </dlentry>
                </dl>
            </p><p><b>Lookup NEST Example 1:</b> Join two keyspaces producing an output for each
                left input.</p><p>Show one set of routes for one airline in the<codeph>
                    travel-sample
                </codeph>keyspace.</p><codeblock>SELECT *
FROM `travel-sample` route
  INNER NEST `travel-sample` airline
  ON KEYS route.airlineid
WHERE route.type = "route"
LIMIT 1;</codeblock><p>Results:</p><codeblock>[
  {
    "airline": [
      {
        "callsign": "AIRFRANS",
        "country": "France",
        "iata": "AF",
        "icao": "AFR",
        "id": 137,
        "name": "Air France",
        "type": "airline"
      }
    ],
    "route": {
      "airline": "AF",
      "airlineid": "airline_137",
      "destinationairport": "MRS",
      "distance": 2881.617376098415,
      "equipment": "320",
      "id": 10000,
      "schedule": [
        {
          "day": 0,
          "flight": "AF198",
          "utc": "10:13:00"
        },
        {
          "day": 0,
          "flight": "AF547",
          "utc": "19:14:00"
        },
        {
          "day": 0,
          "flight": "AF943",
          "utc": "01:31:00"
        },
        {
          "day": 1,
          "flight": "AF356",
          "utc": "12:40:00"
        },
        {
          "day": 1,
          "flight": "AF480",
          "utc": "08:58:00"
        },
        {
          "day": 1,
          "flight": "AF250",
          "utc": "12:59:00"
        },
        {
          "day": 1,
          "flight": "AF130",
          "utc": "04:45:00"
        },
        {
          "day": 2,
          "flight": "AF997",
          "utc": "00:31:00"
        },
        {
          "day": 2,
          "flight": "AF223",
          "utc": "19:41:00"
        },
        {
          "day": 2,
          "flight": "AF890",
          "utc": "15:14:00"
        },
        {
          "day": 2,
          "flight": "AF399",
          "utc": "00:30:00"
        },
        {
          "day": 2,
          "flight": "AF328",
          "utc": "16:18:00"
        },
        {
          "day": 3,
          "flight": "AF074",
          "utc": "23:50:00"
        },
        {
          "day": 3,
          "flight": "AF556",
          "utc": "11:33:00"
        },
        {
          "day": 4,
          "flight": "AF064",
          "utc": "13:23:00"
        },
        {
          "day": 4,
          "flight": "AF596",
          "utc": "12:09:00"
        },
        {
          "day": 4,
          "flight": "AF818",
          "utc": "08:02:00"
        },
        {
          "day": 5,
          "flight": "AF967",
          "utc": "11:33:00"
        },
        {
          "day": 5,
          "flight": "AF730",
          "utc": "19:42:00"
        },
        {
          "day": 6,
          "flight": "AF882",
          "utc": "17:07:00"
        },
        {
          "day": 6,
          "flight": "AF485",
          "utc": "17:03:00"
        },
        {
          "day": 6,
          "flight": "AF898",
          "utc": "10:01:00"
        },
        {
          "day": 6,
          "flight": "AF496",
          "utc": "07:00:00"
        }
      ],
      "sourceairport": "TLV",
      "stops": 0,
      "type": "route"
    }
  }
]</codeblock></section>
        <section id="section_rgr_rnx_1db">
            <title>Index NEST Clause</title>
            <p><i>(Introduced in Couchbase Server 4.0)</i></p>
            <p>When Lookup NESTs cannot efficiently nest left-hand side documents with right-to-left
                nests and your situation cannot be flipped because your predicate needs to be on the
                left-hand side (such as the above Lookup NEST Example #1 where airline documents
                have no reference to route documents), then Index NESTs can be used efficiently.
                Index NESTs allow you to flip the direction of your nest clause.</p>
            <p><b>Index NEST Example 1:</b> List four
                <codeblock>CREATE INDEX idx_ijoin ON `travel-sample`(airlineid) WHERE type="route";

SELECT *
FROM `travel-sample` rte
  INNER NEST `travel-sample` aline
  ON KEY rte.airlineid
  FOR rte
WHERE rte.type = "route"
LIMIT 4;</codeblock>If
                you generalize the same query, it looks like the
                following:<codeblock>CREATE INDEX <i>on-key-for-index-name rhs-expression</i> (<i>lhs-expression-key</i>);
                 
SELECT <i>projection-list</i> 
FROM <i>lhs-expression</i>
  NEST <i>rhs-expression</i>
  ON KEY <i>rhs-expression.lhs-expression-key</i> FOR <i>lhs-expression</i>      
[ WHERE <i>predicates</i> ] ;</codeblock>There
                are three important changes in the index scan syntax example above:<ul
                    id="ul_msk_5m3_bdb">
                    <li><codeph>CREATE INDEX </codeph>on the <codeph>ON KEY
                            </codeph>expression<codeph> route.airlineid </codeph>to access<codeph>
                            route </codeph>documents using<codeph> airlineid </codeph>(which are
                        produced on the LHS).</li>
                    <li>The<codeph> ON KEY route.airlineid FOR airline </codeph>enables N1QL to use
                        the index<codeph> route.airlineid</codeph>.</li>
                    <li>Create any optional index, such as<codeph> route.airline </codeph>that can
                        be used on<codeph> airline </codeph>(LHS).</li>
                </ul><note>For index nests, the syntax uses<codeph> ON KEY </codeph>(singular)
                    instead of<codeph> ON KEYS </codeph>(plural). This is because Index NESTs'
                        <codeph>ON KEY </codeph>expression must produce a scalar value; whereas
                    Lookup NESTs'<codeph> ON KEYS </codeph>expression can produce either a scalar or
                    an array value.</note><b
                    id="docs-internal-guid-5edc3eee-f473-2bc0-9ae3-a3f90f7b214f"
                ><b>Syntax</b></b></p>
            <p><image
                    href="images/FROM_index-nest_5.1_rr.png"
                    id="image_emh_343_bdb"/></p>
            <p><codeblock>[ <i>nest-type</i> ] NEST <i>from-path</i> [ [ AS ] <i>alias</i> ] ON KEY <i>on-key-clause</i> FOR <i>for-clause</i></codeblock><b
                    id="docs-internal-guid-5edc3eee-f47b-4520-084c-c7d29e2286bd"
                    ><b>Arguments</b></b></p>
            <p><dl>
                    <dlentry>
                        <dt><b>nest-type</b></dt>
                        <dd>[Optional; default is<codeph> LEFT INNER</codeph>]</dd>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt><codeph>LEFT</codeph> or <codeph>LEFT INNER</codeph></dt>
                                    <dd>For each nested object produced, both the left-hand and
                                        right-hand source objects must be non-MISSING and
                                        non-NULL.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>LEFT OUTER</codeph></dt>
                                    <dd>For each nested object produced, only the left-hand source
                                        objects must be non-MISSING and non-NULL.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt>from-path</dt>
                        <dd>Keyspace reference for right-hand side of an index nest. For details,
                            see <xref
                                href="http://docs-build.sc.couchbase.com/server/2059/n1ql/n1ql-language-reference/from.html#concept_rnt_zfk_np__keyspaces"
                                format="html" scope="external"><u>Keyspaces</u></xref>.</dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt><codeph>AS</codeph> alias</dt>
                        <dd>[Optional] To assign another name. For details, see <xref
                                href="http://docs-build.sc.couchbase.com/server/2059/n1ql/n1ql-language-reference/from.html#concept_rnt_zfk_np__as"
                                format="html" scope="external"><u>AS Keyword</u></xref>.</dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt><codeph>ON KEY</codeph> rhs-expression.lhs-expression-key</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>rhs-expression</dt>
                                    <dd>Keyspace reference for the right-hand side of the index
                                        nest.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>lhs-expression-key</dt>
                                    <dd>String or expression representing the attribute in<codeph>
                                            rhs-expression </codeph>referencing the document key
                                            for<codeph> lhs-expression</codeph>.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt><codeph>FOR</codeph> lhs-expression</dt>
                        <dd>Keyspace reference for the left-hand side of the index nest.</dd>
                    </dlentry>
                </dl><b>Index NEST Example 1:</b> ON KEY ... FOR.</p>
            <p>This example nests the airline routes for each airline after creating the following
                index. (Note that the index will not match if it contains a WHERE
                clause)<codeblock>CREATE INDEX route_airline ON `travel-sample`(airlineid);

SELECT *
FROM `travel-sample` aline
  INNER NEST `travel-sample` rte
  ON KEY rte.airlineid
  FOR aline                
WHERE aline.type = "airline"
LIMIT 1;</codeblock>Results:<codeblock>[
  {
    "aline": {
      "callsign": "MILE-AIR",
      "country": "United States",
      "iata": "Q5",
      "icao": "MLA",
      "id": 10,
      "name": "40-Mile Air",
      "type": "airline"
    },
    "route": [
      {
        "airline": "Q5",
        "airlineid": "airline_10",
        "destinationairport": "HKB",
        "distance": 118.20183585107631,
        "equipment": "CNA",
        "id": 46586,
        "schedule": [
          {
            "day": 0,
            "flight": "Q5188",
            "utc": "12:40:00"
          },
          {
            "day": 0,
            "flight": "Q5630",
            "utc": "21:53:00"
          },
          {
            "day": 0,
            "flight": "Q5530",
            "utc": "07:47:00"
          },
          {
            "day": 0,
            "flight": "Q5132",
            "utc": "01:10:00"
          },
          {
            "day": 0,
            "flight": "Q5746",
            "utc": "20:11:00"
          },
          {
            "day": 1,
            "flight": "Q5413",
            "utc": "08:07:00"
          },
          {
            "day": 2,
            "flight": "Q5263",
            "utc": "17:39:00"
          },
          {
            "day": 2,
            "flight": "Q5564",
            "utc": "01:55:00"
          },
          {
            "day": 2,
            "flight": "Q5970",
            "utc": "00:09:00"
          },
          {
            "day": 2,
            "flight": "Q5295",
            "utc": "21:24:00"
          },
          {
            "day": 2,
            "flight": "Q5051",
            "utc": "04:41:00"
          },
          {
            "day": 3,
            "flight": "Q5023",
            "utc": "00:16:00"
          },
          {
            "day": 3,
            "flight": "Q5554",
            "utc": "11:45:00"
          },
          {
            "day": 3,
            "flight": "Q5619",
            "utc": "22:22:00"
          },
          {
            "day": 4,
            "flight": "Q5279",
            "utc": "23:19:00"
          },
          {
            "day": 4,
            "flight": "Q5652",
            "utc": "13:35:00"
          },
          {
            "day": 4,
            "flight": "Q5631",
            "utc": "17:53:00"
          },
          {
            "day": 4,
            "flight": "Q5105",
            "utc": "21:54:00"
          },
          {
            "day": 5,
            "flight": "Q5559",
            "utc": "01:19:00"
          },
          {
            "day": 5,
            "flight": "Q5600",
            "utc": "17:36:00"
          },
          {
            "day": 6,
            "flight": "Q5854",
            "utc": "22:59:00"
          },
          {
            "day": 6,
            "flight": "Q5217",
            "utc": "11:58:00"
          },
          {
            "day": 6,
            "flight": "Q5756",
            "utc": "06:32:00"
          },
          {
            "day": 6,
            "flight": "Q5151",
            "utc": "15:14:00"
          }
        ],
        "sourceairport": "FAI",
        "stops": 0,
        "type": "route"
      },
      {
        "airline": "Q5",
        "airlineid": "airline_10",
        "destinationairport": "FAI",
        "distance": 118.20183585107631,
        "equipment": "CNA",
        "id": 46587,
        "schedule": [
          {
            "day": 0,
            "flight": "Q5492",
            "utc": "17:00:00"
          },
          {
            "day": 0,
            "flight": "Q5357",
            "utc": "09:44:00"
          },
          {
            "day": 0,
            "flight": "Q5873",
            "utc": "00:01:00"
          },
          {
            "day": 1,
            "flight": "Q5171",
            "utc": "00:59:00"
          },
          {
            "day": 1,
            "flight": "Q5047",
            "utc": "10:57:00"
          },
          {
            "day": 1,
            "flight": "Q5889",
            "utc": "14:51:00"
          },
          {
            "day": 1,
            "flight": "Q5272",
            "utc": "18:36:00"
          },
          {
            "day": 2,
            "flight": "Q5673",
            "utc": "21:30:00"
          },
          {
            "day": 3,
            "flight": "Q5381",
            "utc": "20:01:00"
          },
          {
            "day": 4,
            "flight": "Q5261",
            "utc": "18:37:00"
          },
          {
            "day": 5,
            "flight": "Q5755",
            "utc": "23:43:00"
          },
          {
            "day": 5,
            "flight": "Q5544",
            "utc": "16:04:00"
          },
          {
            "day": 6,
            "flight": "Q5400",
            "utc": "10:46:00"
          },
          {
            "day": 6,
            "flight": "Q5963",
            "utc": "13:53:00"
          },
          {
            "day": 6,
            "flight": "Q5195",
            "utc": "03:03:00"
          },
          {
            "day": 6,
            "flight": "Q5653",
            "utc": "22:58:00"
          }
        ],
        "sourceairport": "HKB",
        "stops": 0,
        "type": "route"
      }
    ]
  }
]</codeblock></p>
        </section>
        <section>
            <title>Appendix 1 - JOIN Types</title>
            <p>
                <table frame="all" rowsep="1" colsep="1" id="table_qqy_sq3_bdb">
                    <tgroup cols="5" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="2*"/>
                        <colspec colname="c3" colnum="3" colwidth="2*"/>
                        <colspec colname="c4" colnum="4" colwidth="3*"/>
                        <colspec colname="c5" colnum="5" colwidth="3*"/>
                        <thead>
                            <row>
                                <entry>Join</entry>
                                <entry>Left-Hand Side (lhs)</entry>
                                <entry>Right-Hand Side (rhs)</entry>
                                <entry>Syntax</entry>
                                <entry>Example</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><b>ANSI</b></entry>
                                <entry>Any field or expr that produces a value that will be matched
                                    on the right-hand side.</entry>
                                <entry>Anything that can have a proper index on the join
                                    expression.</entry>
                                <entry><codeph>lhs-expr</codeph><p><codeph>JOIN
                                            rhs-keyspace</codeph></p><p><codeph><b>ON
                                            </b></codeph><i>any join condition</i></p></entry>
                                <entry><codeph>SELECT *</codeph><p><codeph>FROM `travel-sample`
                                            r</codeph></p><p><codeph>JOIN `travel-sample`
                                        a</codeph></p><p><codeph><b>ON </b></codeph><codeph>
                                            r.airlineid = META(a).id</codeph></p></entry>
                            </row>
                            <row>
                                <entry><b>Lookup</b></entry>
                                <entry>Must produce a Document Key for the right-hand side.</entry>
                                <entry>Must have a Document Key.</entry>
                                <entry><codeph>lhs-expr</codeph><p><codeph>JOIN
                                            rhs-keyspace</codeph></p><p><codeph><b>ON
                                            KEYS</b></codeph></p><p><codeph>lhs-expr.foreign_key</codeph></p></entry>
                                <entry><codeph>SELECT *</codeph><p><codeph>FROM `travel-sample`
                                            r</codeph></p><p><codeph>JOIN `travel-sample`
                                        a</codeph></p><p><codeph><b>ON KEYS</b></codeph><codeph>
                                            r.airlineid</codeph></p></entry>
                            </row>
                            <row>
                                <entry><b>Index</b></entry>
                                <entry>Must produce a key for the right-hand side's index.</entry>
                                <entry>Must have a proper index on the field or expr that maps to
                                    the Document Key of the left-hand side.</entry>
                                <entry><codeph>lhs-keyspace</codeph><p><codeph>JOIN rhs-keyspace
                                        </codeph></p><p><codeph><b>ON KEY</b>
                                            rhs-kspace.idx_key</codeph></p><p><codeph><b>FOR</b>
                                            lhs-keyspace</codeph></p></entry>
                                <entry><codeph>SELECT *</codeph><p><codeph>FROM `travel-sample` a
                                        </codeph></p><p><codeph>JOIN `travel-sample` r
                                                </codeph></p><p><codeph><b>ON
                                            KEY</b></codeph><codeph>
                                                r.airlineid</codeph></p><p><b><codeph>FOR</codeph></b>
                                        a</p></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </p>
        </section>
        <section id="as">
            <title>Appendix 2 - NEST Types</title>
            <p>
                <table frame="all" rowsep="1" colsep="1" id="table_emt_lt3_bdb">
                    <tgroup cols="5" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="2*"/>
                        <colspec colname="c3" colnum="3" colwidth="2*"/>
                        <colspec colname="c4" colnum="4" colwidth="3*"/>
                        <colspec colname="c5" colnum="5" colwidth="3*"/>
                        <thead>
                            <row>
                                <entry>NEST</entry>
                                <entry>Left-Hand Side (lhs)</entry>
                                <entry>Right-Hand Side (rhs)</entry>
                                <entry>Syntax</entry>
                                <entry>Example</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><b>ANSI</b></entry>
                                <entry>Any field or expr that produces a value that will be matched
                                    on the right-hand side.</entry>
                                <entry>Anything that can have a proper index on the join
                                    expression.</entry>
                                <entry><codeph>lhs-expr</codeph><p><codeph>NEST
                                            rhs-keyspace</codeph></p><p><codeph><b>ON
                                            </b></codeph><i>any nest condition</i></p></entry>
                                <entry><codeph>SELECT * </codeph><p><codeph>FROM `travel-sample`
                                            r</codeph></p><p><codeph>NEST `travel-sample`
                                        a</codeph></p><p><codeph><b>ON
                                            </b></codeph><codeph>r.airlineid =
                                        META(a).id</codeph></p></entry>
                            </row>
                            <row>
                                <entry><b>Lookup</b></entry>
                                <entry>Must produce a Document Key for the right-hand side.</entry>
                                <entry>Must have a Document Key.</entry>
                                <entry><codeph>lhs-expr</codeph><p><codeph>NEST
                                            rhs-keyspace</codeph></p><p><codeph><b>ON
                                            KEYS</b></codeph></p><p><codeph>lhs-expr.foreign_key</codeph></p></entry>
                                <entry><codeph>SELECT * </codeph><p><codeph>FROM `travel-sample`
                                            r</codeph></p><p><codeph>NEST `travel-sample` a
                                        </codeph></p><p><codeph><b>ON KEYS</b></codeph><codeph>
                                            r.airlineid</codeph></p><p><codeph>WHERE
                                            r.type="route"</codeph></p><p><codeph>LIMIT
                                        4;</codeph></p></entry>
                            </row>
                            <row>
                                <entry><b>Index</b></entry>
                                <entry>Must produce a key for the right-hand side index.</entry>
                                <entry>Must have a proper index on the field or expr that maps to
                                    the Document Key of the left-hand side.</entry>
                                <entry><codeph>lhs-keyspace</codeph><p><codeph>NEST rhs-keyspace
                                        </codeph></p><p><codeph><b>ON KEY</b>
                                            rhs-kspace.idx_key</codeph></p><p><codeph><b>FOR</b></codeph><codeph>
                                            lhs-keyspace</codeph></p></entry>
                                <entry><codeph>SELECT *</codeph><p><codeph>FROM `travel-sample`
                                            a</codeph></p><p><codeph>NEST `travel-sample`
                                        r</codeph></p><p><codeph><b>ON KEY</b></codeph><codeph>
                                            r.airlineid
                                            </codeph></p><p><codeph><b>FOR</b></codeph><codeph>
                                            a</codeph></p><p><codeph>WHERE
                                        a.type="airline"</codeph></p><p><codeph>LIMIT
                                        4;</codeph></p></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </p>
        </section>
    </body>
</topic>
