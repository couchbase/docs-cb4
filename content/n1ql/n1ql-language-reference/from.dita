<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_rnt_zfk_np">
 <title>FROM clause</title>
    <shortdesc>The <codeph>FROM</codeph> clause defines the keyspaces, input documents, or objects
        for the query.</shortdesc>

 <body>
        <p><i>(Introduced in Couchbase Server 1.0)</i></p>
        <section id="section_afb_jnp_2cb">
            <title>Purpose</title>
            <p>In a <codeph>SELECT</codeph> query or subquery, the <codeph>FROM</codeph> clause
                defines the keyspaces and the source of input documents or objects for the query.
                Every <codeph>FROM</codeph> clause specifies one or more keyspaces. The first
                keyspace is called the primary keyspace and is an optional clause for your query. </p>
            <p>If the <codeph>FROM</codeph> clause is omitted, the input for the query is a single
                empty object that allows you to perform calculations with the
                    <codeph>SELECT</codeph> statement.</p>
        </section>
        <section id="section_hgx_knp_2cb">
            <title>Prerequisites</title>
            <p>For you to select data from a document or keyspace, you must have the
                    <parmname>query_select</parmname> privilege on the document or keyspace. For
                more details about user roles, see <xref
                    href="../../security/security-authorization.dita#authorization"/>.</p>
        </section>
        <section id="section_fwj_nnp_2cb">
            <title>Syntax</title>
            <p>
                <codeblock>FROM <varname>from-keyspace</varname> [ [ AS ] <varname>alias1</varname> ] [ USE KEYS <varname>use-clause</varname> ]  
                    | "(" SELECT ")" [ [ AS ] <varname>alias2</varname> ]
                    | <varname>expr</varname> [ [ AS ] <varname>alias3</varname> ]
                    | <varname>from-term</varname> ( <varname>join-clause</varname> | <varname>nest-clause</varname> | <varname>unnest-clause</varname> )  </codeblock></p>
     <p>
            <image placement="break" href="images/from-term.png" id="image_uy5_kzt_pz"/>
        </p>
        <note>Couchbase Server version 4.x supports only keyspace identifier or a subquery in the
                <codeph>from-term</codeph>, but not expressions. Couchbase Server version 4.6.2 adds
            support for generic <xref href="#concept_rnt_zfk_np/section_fkc_ftt_nz" format="dita"
                >expression</xref> in the <codeph>from-term</codeph>.</note>
        <dl>
            <dlentry>
                <dt>Arguments</dt>
                <dd>
                    <dl>
                        <dlentry>
                            <dt>from-keyspace</dt>
                            <dd>[Optional] String or <xref
                                    href="#concept_rnt_zfk_np/section_fkc_ftt_nz" format="dita"
                                    >expression</xref> resulting in a string that represents the
                                keyspace or source of input documents. For details, see <xref
                                    href="#concept_rnt_zfk_np/keyspaces" format="dita"
                                    >Keyspaces</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>alias (Optionally, <codeph>AS</codeph> alias)</dt>
                            <dd>[Optional] To assign another name. For details, see <xref
                                    href="#concept_rnt_zfk_np/as" format="dita">AS
                                Keyword</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt><codeph>USE KEYS</codeph></dt>
                            <dd>[Optional] To specify one or multiple primary keys.  For details,
                                see <xref href="#concept_rnt_zfk_np/use-keys-clause" format="dita"
                                    >USE KEYS Clause</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt><codeph>SELECT</codeph></dt>
                            <dd>[Optional] To create a subquery of input objects. For details, see
                                    <xref href="selectclause.dita#topic_SELECT_Clause">SELECT
                                    Clause</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>expr</dt>
                            <dd>[Optional] A string expression of input objects.  For details, see
                                    <xref href="index.dita#n1ql-lang-ref">N1QL
                                Expressions</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>from-term</dt>
                            <dd>[Optional] The <varname>from-term</varname> defines the input
                                objects for the query and it can be either a keyspace identifier or
                                an expression.</dd>
                            <dd>When using nested subqueries, the <varname>from-term</varname> of
                                the outermost parent query can only have a <xref
                                    href="#concept_rnt_zfk_np/section_ekc_ftt_nz" format="dita"
                                    >keyspace identifier</xref>, a subquery, or a <xref
                                    href="#concept_rnt_zfk_np/section_fkc_ftt_nz" format="dita"
                                    >constant expression</xref> since the
                                    <varname>from-term</varname> needs to independently produce
                                input documents for the query.</dd>
                            <dd>However, the subqueries can use generic variable expressions, which
                                may be dependent on the <xref
                                    href="subqueries.dita#topic_9/section_onz_3tj_mz"/>. For
                                details, see <xref href="subqueries.dita#topic_9"/>. </dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>join-clause</dt>
                            <dd>[Optional] To create new input objects by combining two or more
                                source objects either via a <xref
                                    href="#concept_rnt_zfk_np/lookup-join" format="dita">Lookup
                                    JOIN</xref> or an <xref href="#concept_rnt_zfk_np/index-join"
                                    format="dita">Index JOIN</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>nest-clause</dt>
                            <dd>[Optional] To produce a single result of joining two keyspaces. For
                                details, see <xref href="#concept_rnt_zfk_np/nest" format="dita"
                                    >NEST Clause</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>unnest-clause</dt>
                            <dd>[Optional] To perform a join of the nested array with its parent.
                                For details, see <xref href="#concept_rnt_zfk_np/unnest"
                                    format="dita">UNNEST Clause</xref>.</dd>
                        </dlentry>
                    </dl>
                </dd>
            </dlentry>
        </dl>
     
  <codeblock>from-term::= keyspace-ref [ [ AS ] <varname>alias</varname> ] [ use-keys-clause ]  
                        | "(" select ")" [ AS ] alias
                        | expr [ AS ] alias
                        | from-term ( join-clause | nest-clause | unnest-clause )   </codeblock>
 
     <p><i>from-path:</i></p>
     <codeblock>[ namespace : ] path </codeblock>
     
     <p><i>namespace:</i></p>
     <codeblock>identifier</codeblock>
        <p><i>expr:</i></p>
        <codeblock>see <xref href="#concept_rnt_zfk_np/section_fkc_ftt_nz" format="dita">N1QL expression</xref></codeblock>
     
     <p><i>use-keys-clause:</i></p>
     <codeblock>USE [ PRIMARY ] KEYS expression </codeblock>
     
     <p><i>join-clause:</i></p>
     <codeblock>( <varname>lookup-join</varname> | <varname>index-join</varname> )</codeblock>
     
     <p><i>lookup-join:</i></p>
     <codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] alias ] <varname>on-keys-clause</varname></codeblock>
     
     <p><i>index-join:</i></p>
     <codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] alias ] ( <varname>on-keys-clause</varname> | <varname>on-key-for-clause</varname> )</codeblock>
     
     <p><i>join-type:</i></p>
     <codeblock>INNER | LEFT [ OUTER ]  </codeblock>
     
     <p><i>on-keys-clause:</i></p>
     <codeblock>ON [ PRIMARY ] KEYS expression  </codeblock>
     
     <p><varname>on-key-for-clause:</varname></p>
     <codeblock>ON [ PRIMARY ] KEY <varname>rhs-expression</varname>.<varname>lhs-expression-key</varname> FOR <varname>lhs-expression</varname> </codeblock>
     <p><varname>rhs-expression</varname>: keyspace or expression corresponding to the right hand side of JOIN.</p>
     <p><varname>lhs-expression</varname>: keyspace or expression corresponding to the left hand side of JOIN.</p>
     <p><varname>lhs-expression-key</varname>: attribute in <varname>rhs-expression</varname>
            referencing primary key for <varname>lhs-expression</varname>.</p>
     
     <p><i>nest-clause:</i></p>
     <codeblock>[ <varname>join-type</varname> ] NEST <varname>from-path</varname> [ ( [ AS ] alias ) ] <varname>on-keys-clause</varname> </codeblock>
     
     <p><i>unnest-clause:</i></p>
     <codeblock>[ <varname>join-type</varname> ] [ UNNEST | FLATTEN ] expression [ ( [ AS ] alias ) ]</codeblock>
     
<p><b>Omitted <codeph>FROM</codeph> clause</b></p>
  <p>If the <codeph>FROM</codeph> clause is omitted, the data source is equivalent to an array
            containing a single empty object. This allows you to evaluate expressions that do not
            depend on stored data.</p>
  <p>Evaluating an expression<codeph> SELECT 10 + 20 </codeph>produces the following result:</p>
<codeblock>[ { "$1" : 30 } ] </codeblock>
  <p>Counting the number of inputs<codeph> SELECT COUNT(*) AS input_count </codeph>produces the
            following result:</p>
<codeblock>[ { "input_count" : 1 } ]</codeblock>
  <p>Getting the input contents<codeph> SELECT * </codeph>produces the following result:</p>
  <codeblock>[ { } ]</codeblock>
  
  <p/>
        <p/></section>
        <section id="section_yp1_dpf_bcb">
            <title>Omitted FROM Clause</title>
            <p>If the <codeph>FROM</codeph> clause is omitted, the data source is equivalent to an
                array containing a single empty object. This allows you to evaluate expressions that
                do not depend on stored data.</p>
            <p><b>Omitted <codeph>FROM</codeph> Example 1: Evaluating an expression.</b></p>
            <p>Add the two numbers 10 and 20 together.<codeblock>SELECT 10 + 20</codeblock> This
                results in:</p>
            <codeblock>[
  {
    "$1" : 30
  }
] </codeblock>
            <p><b>Omitted <codeph>FROM</codeph> Example 2: Selecting the local time.</b></p>
            <p>Select the local time and format the result as
                "yyyy-mm-dd".<codeblock>SELECT NOW_LOCAL('1111-11-11')</codeblock></p>
            <p>This results in:</p>
            <codeblock>[
  {
    "$1": "2017-11-30"
  }
]</codeblock>
            <p><b>Omitted <codeph>FROM</codeph> Example 3: Calculating the days until
                Christmas.</b></p>
            <p>Use the DATE_DATE_STR function to calculate the days from now until
                Christmas.<codeblock>SELECT DATE_DIFF_STR('2017-12-25',NOW_LOCAL('1111-11-11'),'day')</codeblock>This
                results in:</p>
            <codeblock>[
  {
    "$1": 25
  }
]</codeblock>
        </section>
        <section id="keyspaces">
            <title>Keyspaces</title>
            <p>The simplest type of <codeph>FROM</codeph> clause specifies a keyspace:</p>
            <codeblock>SELECT * FROM `travel-sample`;</codeblock>
            <p>This returns every value in the <codeph>`travel-sample`</codeph> keyspace.</p>
            <p>The keyspace can be prefixed with an optional namespace (pool):</p>
            <codeblock>SELECT * FROM <?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?>main<?oxy_custom_end?>:`travel-sample`;</codeblock>
            <p>This queries the customer keyspace in the main namespace.</p>
            <p>If the namespace is omitted, the default namespace in the current session is
                used.</p>
        </section>
        <section id="section_ekc_ftt_nz"><title>Keyspace Identifier</title><p>This is the name or
                identifier of an independent keyspace that can serve as a data source or keyspace of
                one or more documents. Such keyspaces are not dependent on any of the <xref
                    href="subqueries.dita#topic_9/section_onz_3tj_mz"/>.</p><b>Keyspace Example 1:
                Use the <codeph>`travel-sample`</codeph> keyspace.</b><p>Select 4 unique landmarks
                from the keyspace
                <codeph>`travel-sample`</codeph>.</p><p><codeblock>SELECT t1.city
FROM `travel-sample` t1
WHERE t1.type = "landmark" LIMIT 4;</codeblock>This
                results
                in:<codeblock>[
  {
    "city": "Gillingham"
  },
  {
    "city": "Giverny"
  },
  {
    "city": "Glasgow"
  },
  {
    "city": "Clarkston"
  }
]</codeblock></p><p><b>Keyspace
                    Example 2: Cities that have landmarks and airports. (non-correlated)</b></p><p
                dir="ltr">The following non-correlated subquery uses the keyspace
                    <codeph>`travel-sample`</codeph> independent of the same keyspace used in the
                outer query:
                </p><p><codeblock>SELECT DISTINCT t1.city
FROM `travel-sample` t1
WHERE t1.type = "landmark"  
AND   t1.city IN (SELECT RAW city
                  FROM `travel-sample` 
                  WHERE type = "airport")
LIMIT 3;</codeblock>This
                results
                in:<codeblock>[
  {
    "city": "Avignon"
  },
  {
    "city": "Bangor"
  },
  {
    "city": "Glasgow"
  }
]</codeblock></p><p
                dir="ltr"><b>Keyspace Example 3: Cities that have museum landmarks.
                (correlated)</b></p><p dir="ltr">The following correlated subquery uses the keyspace
                alias from an outer
                query:</p><p><codeblock>SELECT t1.city, t1.name
FROM `travel-sample` t1
WHERE t1.type = "landmark"  
AND   (SELECT RAW t2
       FROM SPLIT(t1.name) t2 
       WHERE t2 = "museum")[0] IS NOT NULL
LIMIT 3;</codeblock>This
                results
                in:<codeblock>[
  {
    "city": "Washington",
    "name": "Washington 'F' Pit mining museum"
  },
  {
    "city": "L'Isle-sur-la-Sorgue",
    "name": "Campredon museum"
  },
  {
    "city": "Isle of Anglesey",
    "name": "Swtan heritage museum"
  }
]</codeblock></p><p
                dir="ltr"><b>Keyspace Example 3: Cities that have landmarks and breweries.</b></p><p
                dir="ltr">The following subquery example uses different keyspaces in the outer and
                inner
                queries.</p><p><codeblock>SELECT DISTINCT t1.city
FROM `travel-sample` t1
WHERE t1.type = "landmark" 
AND   t1.city IN (SELECT RAW b1.city
                  FROM `beer-sample` b1
                  WHERE b1.type = "brewery")
LIMIT 3;</codeblock>This
                results
                in:<codeblock>[
  {
    "city": "Bangor"
  },
  {
    "city": "East Lothian"
  },
  {
    "city": "Escondido"
  }
]</codeblock></p></section>
        <section id="section_fkc_ftt_nz">
            <title>N1QL Expression</title>
            <p>Couchbase Server version 4.6.2 adds support for generic <xref
                    href="index.dita#n1ql-lang-ref">expressions</xref> in the
                    <codeph>from-term</codeph>. This is a very powerful functionality as it enables
                usage of various N1QL functions, operators, path expressions, language constructs on
                constant expressions, variables, and subqueries. <ul id="ul_jwy_fyx_mz">
                    <li dir="ltr">
                        <p dir="ltr">When the <codeph>from-term</codeph> is an expression,
                                <codeph>USE KEYS</codeph> or <codeph>USE INDEX</codeph> clauses are
                            not allowed.</p>
                    </li>
                    <li dir="ltr">
                        <p dir="ltr">When using a <codeph>JOIN</codeph> clause,
                                <codeph>NEST</codeph> clause, or <codeph>UNNEST</codeph> clause, the
                            left-side keyspace can be an expression or subquery, but the right-side
                            keyspace must be a keyspace identifier.</p>
                        <dl>
                            <dlentry>
                                <dt><b>Independent Constant Expression</b></dt>
                                <dd/>
                                <dd>This includes any N1QL expressions of JSON scalar values, static
                                    JSON literals, objects, or N1QL functions. For example:<p>
                                        <codeblock>SELECT * FROM [1, 2, "name", { "type" : "airport", "id" : "SFO"}]  AS  ks1;

SELECT * FROM CURL(...) as ks2;</codeblock>
                                    </p><p dir="ltr">Note that functions such as <xref
                                            href="curl.dita#topic_8_8">CURL()</xref> can
                                        independently produce input data objects for the query.
                                        However, other N1QL functions can also be used in the
                                        expressions.</p></dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>Variable N1QL Expression</b></dt>
                                <dd/>
                                <dd>This includes expressions that refers to any <xref
                                        href="subqueries.dita#topic_9/section_onz_3tj_mz">variables
                                        in scope</xref> for the query. This is applicable to only
                                    subqueries because the outermost level query cannot use any
                                    variables in its own <codeph>FROM</codeph> clause. This makes
                                    the subquery correlated with outer queries, as explained in the
                                        <xref href="subqueries.dita#topic_9"/> section. </dd>
                            </dlentry>
                        </dl>
                        <dl>
                            <dlentry>
                                <dt><b>Subquery and Subquery Expressions</b></dt>
                                <dd/>
                                <dd>A subquery itself can appear as a <codeph>from-term</codeph>
                                    expression. In this case, the subquery results are fed as data
                                    source to the outer query. Further, subqueries can occur as a
                                    subquery or as constituent part of a bigger N1QL expression.<p
                                        dir="ltr"><b>Subquery Example 1a: Highest altitude
                                            airport/city in each country. (with a
                                        subquery)</b></p><p dir="ltr">The following shows a simple
                                        case of using a subquery in the <codeph>FROM</codeph>
                                        clause:</p><p><codeblock>SELECT t1.country, t1.max_country_alt, 
       ARRAY x.city FOR x IN t1.c 
       WHEN x.alt = t1.max_country_alt END
FROM (SELECT  country, array_agg({"alt": geo.alt , city}) c,
   max_country_alt
      FROM `travel-sample` 
      WHERE type = "airport"
      GROUP BY country 
LETTING max_country_alt = max(geo.alt) ) t1;</codeblock>(in
                                        107ms) This results
                                            in:<codeblock>[
  {
    "$1": [
      "Shaftesbury"
    ],
    "country": "United Kingdom",
    "max_country_alt": 811
  },
  {
    "$1": [
      "Courcheval"
    ],
    "country": "France",
    "max_country_alt": 6588
  },
  {
    "$1": [
      "Telluride"
    ],
    "country": "United States",
    "max_country_alt": 9078
  }
]</codeblock><b>Subquery
                                            Example 1b: Highest altitude airports/cities in each
                                            country. (without a subquery)</b></p><p>The same query
                                        as above, but use N1QL's power to express it without a
                                        subquery.<codeblock>SELECT  country, 
        (ARRAY x.city FOR x IN array_agg({"alt": geo.alt, city}) 
        WHEN x.alt = max_country_alt END) AS max_alt_city,
        max_country_alt
FROM `travel-sample` 
WHERE type = "airport"
GROUP BY country 
LETTING max_country_alt = max(geo.alt);</codeblock>(in
                                        104ms) This results
                                        in:<codeblock>[
  {
    "country": "United Kingdom",
    "max_alt_city": [
      "Shaftesbury"
    ],
    "max_country_alt": 811
  },
  {
    "country": "France",
    "max_alt_city": [
      "Courcheval"
    ],
    "max_country_alt": 6588
  },
  {
    "country": "United States",
    "max_alt_city": [
      "Telluride"
    ],
    "max_country_alt": 9078
  }
]</codeblock></p>A
                                    more realistic example of needing subquery in the
                                        <codeph>FROM</codeph> clause arises in more complicated
                                    scenarios, such as when multiple levels of aggregates (sort
                                    orders and limits) are required, or when the subquery results of
                                    one keyspace may need to be JOINed with another keyspace. </dd>
                                <dd><b>Subquery Example 2: For each country, find the number of
                                        airports at different altitudes and their corresponding
                                        cities.</b></dd>
                                <dd>In this case, the inner query finds the first level of grouping
                                    of different altitudes by country and corresponding number of
                                    cities. Then the outer query builds on the inner query results
                                    to count the number of different altitude groups for each
                                    country and the total number of
                                        cities.<p><codeblock>SELECT t1.country, num_alts, total_cities
FROM (SELECT country, geo.alt AS alt,
             count(city) AS num_cities
      FROM `travel-sample` 
      WHERE type = "airport"
      GROUP BY country, geo.alt) t1
GROUP BY t1.country 
LETTING num_alts = count(t1.alt), total_cities = sum(t1.num_cities);</codeblock>This
                                        results
                                        in:<codeblock>[
  {
    "country": "United States",
    "num_alts": 946,
    "total_cities": 1560
  },
  {
    "country": "United Kingdom",
    "num_alts": 128,
    "total_cities": 187
  },
  {
    "country": "France",
    "num_alts": 196,
    "total_cities": 221
  }
]</codeblock></p>This
                                    is equivalent to blending the results of the following two
                                    queries by country, but the subquery in the
                                        <codeph>from-term</codeph> above simplified
                                    it.<codeblock>SELECT country,count(city) AS num_cities
FROM `travel-sample` 
WHERE type = "airport"
GROUP BY country;

SELECT country, count(distinct geo.alt) AS num_alts
FROM `travel-sample` 
WHERE type = "airport"
GROUP BY country;</codeblock>
                                    See <xref href="subqueries.dita#topic_9"/> for details and
                                    examples. </dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>Nested Path Expressions</b></dt>
                                <dd/>
                                <dd>Expressions used in the <codeph>from-term</codeph> can have
                                    nested paths, including constant or variable or subquery
                                    expressions. Similarly, variable expressions are allowed in only
                                    subqueries (not in outermost parent queries). </dd>
                                <dd>Further, the nested-path variable expression in a subquery
                                        <codeph>from-term</codeph> must resolve to variables/aliases
                                    in scope, and not to any keyspace identifiers. Otherwise, it
                                    results in a syntax error.<note>When an expression cannot be
                                        resolved to any variables in scope, it is considered
                                        keyspace identifier. See <xref
                                            href="subqueries.dita#topic_9/nested-path-expr">Nested
                                            Paths in Subqueries</xref> for more details. </note><p
                                        dir="ltr"><b>Nested Example 1: Usage of a nested path over a
                                            subquery
                                        expression.</b></p><p><codeblock>SELECT x.geo.alt
FROM (SELECT geo from `travel-sample` 
      WHERE type = "airport") AS x
LIMIT 2;</codeblock>This
                                        results
                                        in:<codeblock>[
  {
    "alt": 12
  },
  {
    "alt": 295
  }
]</codeblock></p><p/><b>Nested
                                        Example 2: Usage of a nested path over a constant
                                        expression.</b><codeblock>SELECT x.b FROM 
         [{"a" : 1, "b" : {"c" : 2}},
          {"a" : 3, "b" : {"d" : 4}}] AS x
LIMIT 2;</codeblock>This
                                    results
                                    in:<codeblock>[
  {
    "x": {
      "c": 2
    }
  },
  {
    "x": {
      "d": 4
    }
  }
]</codeblock></dd>
                            </dlentry>
                        </dl>
                    </li>
                </ul></p>
        </section>
        <section>
            <title id="use-keys-clause">USE KEYS Clause</title>
            <p>Specific primary keys within a keyspace can be specified. Only values having those
                primary keys will be included as inputs to the query.</p>
            <p><b>Syntax</b></p>
            <codeblock>USE [ PRIMARY ] KEYS <varname>key_expression</varname> </codeblock>
            <p><dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>PRIMARY</dt>
                                    <dd>[Optional] Make the <varname>key_expression</varname> a
                                        unique Primary Key.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>key_expression</dt>
                                    <dd>String of one or more fields to be used as a key.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl><b><codeph>USE KEYS</codeph> Example 1: Specify a single key.</b></p>
            <codeblock>SELECT * FROM customer USE KEYS "acme-uuid-1234-5678"</codeblock>
            <p><b><codeph>USE KEYS</codeph> Example 2: Specify multiple keys.</b></p>
            <codeblock>SELECT * FROM customer USE KEYS [ "acme-uuid-1234-5678", "roadster-uuid-4321-8765" ]</codeblock>
            <p>
                <note>In the <codeph>FROM</codeph> clause of a subquery, <codeph>USE KEYS</codeph>
                    is mandatory for the primary keyspace.</note>
            </p>
        </section>
        <section id="lookup-join-clause">
            <title>Lookup JOIN Clause</title>
            <p><i>(Introduced in Couchbase Server 4.5)</i></p>
            <p>The <codeph>JOIN</codeph> clause enables you to create new input objects by combining
                two or more source objects. </p>
            <p>Lookup joins allow only left-to-right joins, which means each qualified document from
                the left-hand side (LHS) of the <codeph>JOIN</codeph> operator is required to
                produce primary keys of documents on the right-hand side (RHS). These keys are
                subsequently nested-loop-joined to access qualified RHS documents.</p>
            <p><b>Syntax</b></p>
            <codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ] ON KEYS <varname>on-keys-clause</varname></codeblock>
            <p id="lookup-join">
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>LEFT INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT</codeph> or <codeph>LEFT
                                                  INNER</codeph></dt>
                                                <dd>For each joined object produced, both the
                                                  left-hand and right-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT OUTER</codeph></dt>
                                                <dd>For each joined object produced, only the
                                                  left-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>from-path</dt>
                                    <dd>[Required] String or <xref
                                            href="#concept_rnt_zfk_np/section_fkc_ftt_nz"
                                            format="dita">expression</xref> resulting in a string
                                        that represents the keyspace or source of input documents.
                                        For details, see <xref href="#concept_rnt_zfk_np/keyspaces"
                                            format="dita">Keyspaces</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>alias (Optionally, <codeph>AS</codeph> alias)</dt>
                                    <dd>[Optional] To assign another name. For details, see <xref
                                            href="#concept_rnt_zfk_np/as" format="dita">AS
                                            Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>ON KEYS</codeph> on-keys-clause</dt>
                                    <dd>[Required] String or expression representing the primary
                                        keys of the documents for the second keyspace.</dd>
                                    <dd>The <codeph>ON KEYS</codeph> expression produces one or more
                                        document keys for the right-hand side document.</dd>
                                    <dd>The <codeph>ON KEYS</codeph> expression can produce an array
                                        of document keys.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Return Values</dt>
                        <dd>If <codeph>LEFT</codeph> or <codeph>LEFT OUTER</codeph> is specified,
                            then a left outer join is performed.</dd>
                        <dd>At least one joined object is produced for each left-hand source
                            object.</dd>
                        <dd>If the right-hand source object is <codeph>NULL</codeph> or
                                <codeph>MISSING</codeph>, then the joined object's right-hand side
                            value is also <codeph>NULL</codeph> or <codeph>MISSING</codeph>
                            (omitted), respectively. </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Limitations</dt>
                        <dd>Lookup JOINs cannot be chained together.</dd>
                    </dlentry>
                </dl>
            </p>
            <p>
                <b>Lookup JOIN Example 1: route JOIN airline ON KEYS route.airlineid.</b></p>
            <p> List all airlines and non-stop routes from SFO in the <codeph>travel-sample</codeph>
                keyspace.
                <codeblock>SELECT DISTINCT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline
<b>FROM `travel-sample` route 
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid </b>
WHERE route.type = "route" 
AND airline.type = "airline" 
AND route.sourceairport = "SFO" 
AND route.stops = 0
LIMIT 4;         </codeblock></p>
            <p>This results
                in:<codeblock>[
  {
    "airline": "VX",
    "callsign": "REDWOOD",
    "destinationairport": "SAN",
    "name": "Virgin America",
    "stops": 0
  },
  {
    "airline": "VX",
    "callsign": "REDWOOD",
    "destinationairport": "PHL",
    "name": "Virgin America",
    "stops": 0
  },
  {
    "airline": "B6",
    "callsign": "JETBLUE",
    "destinationairport": "FLL",
    "name": "JetBlue Airways",
    "stops": 0
  },
  {
    "airline": "UA",
    "callsign": "UNITED",
    "destinationairport": "IND",
    "name": "United Airlines",
    "stops": 0
  }
]</codeblock></p>
            <p><b>Lookup JOIN Example 2: route JOIN airline ON KEYS route.airlineid.</b></p>
            <p>List the schedule of flights from Boston to San Francisco on JETBLUE in the
                    <codeph>travel-sample</codeph>
                keyspace.<codeblock>SELECT DISTINCT airline.name, route.schedule
FROM `travel-sample` route 
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid 
WHERE route.type = "route" 
AND airline.type = "airline" 
AND route.sourceairport = "BOS"
AND route.destinationairport = "SFO" 
AND airline.callsign = "JETBLUE";</codeblock></p>
            <p>This results in:
                <codeblock>[
  {
    "name": "JetBlue Airways",
    "schedule": [
      {
        "day": 0,
        "flight": "B6076",
        "utc": "10:15:00"
      },
      {
        "day": 0,
        "flight": "B6321",
        "utc": "00:06:00"
      },
      {
        "day": 1,
        "flight": "B6536",
        "utc": "22:45:00"
      },
      {
        "day": 1,
        "flight": "B6194",
        "utc": "00:51:00"
      },
      {
        "day": 2,
        "flight": "B6918",
        "utc": "23:45:00"
      },
      {
        "day": 2,
        "flight": "B6451",
        "utc": "18:09:00"
      },
      {
        "day": 2,
        "flight": "B6868",
        "utc": "22:04:00"
      },
      {
        "day": 2,
        "flight": "B6621",
        "utc": "11:04:00"
      },
      {
        "day": 3,
        "flight": "B6015",
        "utc": "16:59:00"
      },
      {
        "day": 3,
        "flight": "B6668",
        "utc": "07:22:00"
      },
      {
        "day": 3,
        "flight": "B6188",
        "utc": "01:41:00"
      },
      {
        "day": 3,
        "flight": "B6215",
        "utc": "19:35:00"
      },
      {
        "day": 4,
        "flight": "B6371",
        "utc": "21:37:00"
      },
      {
        "day": 4,
        "flight": "B6024",
        "utc": "10:24:00"
      },
      {
        "day": 4,
        "flight": "B6749",
        "utc": "01:12:00"
      },
      {
        "day": 4,
        "flight": "B6170",
        "utc": "01:14:00"
      },
      {
        "day": 5,
        "flight": "B6613",
        "utc": "08:59:00"
      },
      {
        "day": 5,
        "flight": "B6761",
        "utc": "15:24:00"
      },
      {
        "day": 5,
        "flight": "B6162",
        "utc": "02:42:00"
      },
      {
        "day": 5,
        "flight": "B6341",
        "utc": "21:26:00"
      },
      {
        "day": 5,
        "flight": "B6347",
        "utc": "08:43:00"
      },
      {
        "day": 6,
        "flight": "B6481",
        "utc": "22:08:00"
      },
      {
        "day": 6,
        "flight": "B6549",
        "utc": "21:48:00"
      },
      {
        "day": 6,
        "flight": "B6994",
        "utc": "11:30:00"
      },
      {
        "day": 6,
        "flight": "B6892",
        "utc": "13:27:00"
      }
    ]
  }
]</codeblock></p>
            <p>
                <note><codeph>ON KEYS</codeph> is required after each <codeph>JOIN</codeph>. It
                    specifies the primary keys for the second keyspace in the join.</note>
            </p>
            <p/>
        </section>
        <section id="index-join-clause"><title>Index JOIN Clause</title><p>When using lookup joins,
                right-to-left joins with RHS documents containing primary key references to LHS
                documents cannot be joined efficiently using any index. </p><p>Consider the above
                    <i>Lookup Example #1</i> with route and airline documents where
                    <varname>route.airlineid</varname> is the primary key of route documents and
                airline documents have no reference to route
                documents:<codeblock>SELECT DISTINCT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline
FROM `travel-sample` route 
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid 
WHERE route.type = "route" 
AND airline.type = "airline" 
AND route.sourceairport = "SFO" 
LIMIT 4;</codeblock>This
                query gets a list of flights from airlines flying from SFO, but getting flights to
                SFO cannot be efficiently executed without making a Cartesian product of all route
                documents (LHS) with all airline documents (RHS).</p><p>This query cannot use any
                index on <codeph>airline</codeph> to directly access <codeph>sourceairport</codeph>
                in SFO because <codeph>airline</codeph> is on the RHS. </p><p>Also, you cannot
                rewrite the query to put the airline document on the LHS (to use any index) and the
                    <codeph>route</codeph> document on the RHS because the <codeph>airline</codeph>
                documents (on the LHS) have no primary keys to access the <codeph>route</codeph>
                documents (on the RHS). </p><p>Using <term>index joins</term>, the same query can be
                written as:
                <codeblock>Required Index:
  CREATE INDEX route_airlineid ON `travel-sample`(airlineid) WHERE type="route";
                 
Optional index:
  CREATE INDEX route_sourceairport ON `travel-sample`(sourceairport) WHERE type="route";

Resulting in:
  SELECT * FROM `travel-sample` airline 
    JOIN `travel-sample` route
    ON KEY route.airlineid FOR airline
  WHERE route.type="route" 
  AND airline.type="airline"
  AND route.sourceairport = "SFO";                 </codeblock></p><p>If
                you generalize the same query, it looks like the following:
                <codeblock>CREATE INDEX <varname>on-key-for-index-name</varname> <varname>rhs-expression</varname> (<varname>lhs-expression-key</varname>);
                 
SELECT <varname>projection-list</varname> FROM <varname>lhs-expression</varname>
  JOIN <varname>rhs-expression</varname>
  ON KEY <varname>rhs-expression</varname>.<varname>lhs-expression-key</varname> FOR <varname>lhs-expression</varname>      
[ WHERE <varname>predicates</varname> ] ; </codeblock></p><p>There
                are three important changes in the index scan syntax example above: <ul
                    id="ul_fky_g32_1v">
                    <li><codeph>CREATE INDEX</codeph> on the <codeph>ON KEY</codeph> expression
                            <codeph>route.airlineid</codeph> to access <codeph>route</codeph>
                        documents using <codeph>airlineid</codeph> (which are produced on the
                        LHS).</li>
                    <li>The <codeph>ON KEY route.airlineid FOR airline</codeph> enables N1QL to use
                        the index <codeph>route.airlineid</codeph>.</li>
                    <li>Create any optional index such as <codeph>route.sourceairport</codeph> that
                        can be used on route (LHS).</li>
                </ul><note>For index joins, the syntax uses <codeph>ON KEY</codeph> (singular)
                    instead of <codeph>ON KEYS</codeph> (plural). This is because Index JOINs'
                        <codeph>ON KEY</codeph> expression must produce a scalar value; whereas
                    Lookup JOINs' <codeph>ON KEYS</codeph> expression can produce either a scalar or
                    an array value. </note></p><p><b>Syntax</b></p><codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ]  ON KEY FOR <varname>on-key-for-clause</varname> </codeblock><p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>LEFT INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT</codeph> or <codeph>LEFT
                                                  INNER</codeph></dt>
                                                <dd>For each joined object produced, both the
                                                  left-hand and right-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT OUTER</codeph></dt>
                                                <dd>For each joined object produced, only the
                                                  left-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>from-path</dt>
                                    <dd>String or <xref
                                            href="#concept_rnt_zfk_np/section_fkc_ftt_nz"
                                            format="dita">expression</xref> resulting in a string
                                        that represents the keyspace or source of input documents.
                                        For details, see <xref href="#concept_rnt_zfk_np/keyspaces"
                                            format="dita">Keyspaces</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>AS</codeph> alias</dt>
                                    <dd>[Optional] To assign another name. For details, see <xref
                                            href="#concept_rnt_zfk_np/as" format="dita">AS
                                            Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>ON [PRIMARY] KEY</codeph>
                                        rhs-expression.lhs-expression-key FOR lhs-expression</dt>
                                    <dd>[Optional]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt>rhs-expression</dt>
                                                <dd>String or expression representing the Keyspace
                                                  corresponding to the right-hand side of JOIN.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt>lhs-expression</dt>
                                                <dd>String or expression representing the Keyspace
                                                  corresponding to the left-hand side of JOIN.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt>lhs-expression-key</dt>
                                                <dd>String or expression representing the attribute
                                                  in <varname>rhs-expression</varname> referencing
                                                  the primary key for
                                                  <varname>lhs-expression</varname>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
            </p><p><b>Index JOIN Example 1: <codeph>ON KEY ... FOR</codeph>.</b></p><p>The following
                example counts the number of distinct "AA" airline routes for each airport after
                creating the following index (if not already
            created).</p><codeblock>CREATE INDEX route_airlineid ON `travel-sample`(airlineid) WHERE type="route";

SELECT Count(DISTINCT route.sourceairport) AS DistinctAirports
<b>FROM `travel-sample` airline 
  JOIN `travel-sample` route 
  ON KEY route.airlineid FOR airline </b>
WHERE route.type = "route" 
AND airline.type = "airline" 
AND airline.iata = "AA"; </codeblock>This
            results
            in:<?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?><codeblock><?oxy_custom_end?>[
  {
    "DistinctAirports": 429
  }
]</codeblock></section>
        <section id="unnest"><title>UNNEST Clause</title><p>If a document or object contains a
                nested array, <codeph>UNNEST</codeph> conceptually performs a join of the nested
                array with its parent object. Each resulting joined object becomes an input to the
                query. Unnests can be chained.</p><p><b>Syntax</b></p><codeblock>[ <varname>join-type</varname> ] UNNEST <varname>path</varname> [ [ AS ] <varname>alias</varname> ]</codeblock><p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>INNER</codeph></dt>
                                                <dd>For each result object produced, both the
                                                  left-hand and right-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT</codeph> or <codeph>LEFT
                                                  OUTER</codeph></dt>
                                                <dd>A left-outer unnest is performed, and at least
                                                  one result object is produced for each left source
                                                  object.</dd>
                                                <dd>For each joined object produced, only the
                                                  left-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>path</dt>
                                    <dd>[Required] The first path element after each
                                            <codeph>UNNEST</codeph> must reference some preceding
                                        path. </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>alias (optionally, <codeph>AS</codeph> alias)</dt>
                                    <dd>[Required] To assign a name for the unnested item. For
                                        details, see <xref href="#concept_rnt_zfk_np/as"
                                            format="dita">AS Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Return Values</dt>
                        <dd>If the right-hand source object is <codeph>NULL</codeph>,
                                <codeph>MISSING</codeph>, empty, or a non-array value, then the
                            result object's right-side value is <codeph>MISSING</codeph>
                            (omitted).</dd>
                    </dlentry>
                </dl>
            </p><p><b>Example 1: UNNEST an array to select an item.</b></p><p>In the `travel-sample`
                keyspace, flatten the schedule array to get a list of the flights on Monday
                (1).</p><codeblock>SELECT <b>sched</b> FROM `travel-sample` UNNEST schedule <b>sched</b>
WHERE  <b>sched</b>.day = 1
LIMIT 3;</codeblock><p>This
                results
            in:</p><codeblock>[
  {
    "sched": {
      "day": 1,
      "flight": "AF356",
      "utc": "12:40:00"
    }
  },
  {
    "sched": {
      "day": 1,
      "flight": "AF480",
      "utc": "08:58:00"
    }
  },
  {
    "sched": {
      "day": 1,
      "flight": "AF250",
      "utc": "12:59:00"
    }
  }
]</codeblock>Another
            way to get similar results is by using a Collection Operator to find array items that
            meet our
            criteria:<codeblock>SELECT ARRAY item FOR item IN schedule WHEN item.day = 1 END AS Monday_flights
FROM `travel-sample`
WHERE type = "route"
AND ANY item IN schedule SATISFIES item.day = 1 END
LIMIT 3;</codeblock>However,
            without the <codeph>UNNEST</codeph> clause, the unflattened list results in 3 sets of
            flights instead of only 3 individual
                    flights:<codeblock>[
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF356",
        "utc": "12:40:00"
      },
      {
        "day": 1,
        "flight": "AF480",
        "utc": "08:58:00"
      },
      {
        "day": 1,
        "flight": "AF250",
        "utc": "12:59:00"
      },
      {
        "day": 1,
        "flight": "AF130",
        "utc": "04:45:00"
      }
    ]
  },
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF517",
        "utc": "13:36:00"
      },
      {
        "day": 1,
        "flight": "AF279",
        "utc": "21:35:00"
      },
      {
        "day": 1,
        "flight": "AF753",
        "utc": "00:54:00"
      },
      {
        "day": 1,
        "flight": "AF079",
        "utc": "15:29:00"
      },
      {
        "day": 1,
        "flight": "AF756",
        "utc": "06:16:00"
      }
    ]
  },
  {
    "Monday_flights": [
      {
        "day": 1,
        "flight": "AF975",
        "utc": "11:23:00"
      },
      {
        "day": 1,
        "flight": "AF225",
        "utc": "16:05:00"
      }
    ]
  }
]</codeblock><p><b>Example
                    2: Use <codeph>UNNEST</codeph> to collect items from one array to use in another
                    query.</b></p><p>In this example, the <codeph>UNNEST</codeph> clause iterates
                over the reviews array and collects the <codeph>author</codeph> names of the
                reviewers who rated the rooms less than a 2 to be contacted for ways to improve.
                This collection of objects can be used as input for other query
                operations.</p><codeblock>SELECT RAW reviews.author
FROM `travel-sample` 
UNNEST reviews 
WHERE `travel-sample`.type = "hotel"
AND reviews.ratings.Rooms &lt; 2
LIMIT 4;</codeblock><p>This
                results
            in:</p><codeblock>[
  "Kayli Cronin",
  "Shanelle Streich",
  "Catharine Funk",
  "Tyson Beatty"
]</codeblock></section>
        <section id="nest"><title>NEST Clause</title><p>Nesting is conceptually the inverse of
                unnesting. Nesting performs a join across two keyspaces. But instead of producing a
                cross-product of the left and right inputs, a single result is produced for each
                left input, while the corresponding right inputs are collected into an array and
                nested as a single array-valued field in the result object.</p><b>Syntax</b><codeblock>[ <varname>join-type</varname> ] NEST <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ] <varname>on-keys-clause</varname></codeblock><p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>INNER</codeph></dt>
                                                <dd>For each result object produced, both the
                                                  left-hand and right-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT</codeph> or <codeph>LEFT
                                                  OUTER</codeph></dt>
                                                <dd>A left-outer unnest is performed, and at least
                                                  one result object is produced for each left source
                                                  object.</dd>
                                                <dd>For each joined object produced, only the
                                                  left-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>path</dt>
                                    <dd>[Required] The first path element after each
                                            <codeph>UNNEST</codeph> must reference some preceding
                                        path. </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>alias (optionally, <codeph>AS</codeph> alias)</dt>
                                    <dd>[Required] To assign a name for the unnested item. For
                                        details, see <xref href="#concept_rnt_zfk_np/as"
                                            format="dita">AS Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>on-keys-clause</dt>
                                    <dd>[Required] String or expression representing the primary
                                        keys of the documents for the second keyspace.</dd>
                                    <dd>The <codeph>ON KEYS</codeph> expression produces one or more
                                        document keys for the right-hand side document.</dd>
                                    <dd>The <codeph>ON KEYS</codeph> expression can produce an array
                                        of document keys.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Return Values</dt>
                        <dd>If the right-hand source object is <codeph>NULL</codeph>,
                                <codeph>MISSING</codeph>, empty, or a non-array value, then the
                            result object's right-side value is <codeph>MISSING</codeph>
                            (omitted).</dd>
                        <dd>Nests can be chained with other <codeph>NEST</codeph>,
                                <codeph>JOIN</codeph>, and <codeph>UNNEST</codeph> clauses. By
                            default, an <codeph>INNER NEST</codeph> is performed. This means that
                            for each result object produced, both the left and right source objects
                            must be non-missing and non-null. The right-hand side result of
                                <codeph>NEST</codeph> is always an array or
                            <codeph>MISSING</codeph>. If there is no matching right source object,
                            then the right source object is as follows:<table frame="all" rowsep="1"
                                colsep="1" id="table_kbj_2dr_ccb">
                                <tgroup cols="2" align="left">
                                    <colspec colname="c1" colnum="1" colwidth="1*"/>
                                    <colspec colname="c2" colnum="2" colwidth="1*"/>
                                    <thead>
                                        <row>
                                            <entry>If the <codeph>ON KEYS</codeph> expression
                                                evaluates to</entry>
                                            <entry>Then the right-side value is</entry>
                                        </row>
                                    </thead>
                                    <tbody>
                                        <row>
                                            <entry><codeph>MISSING</codeph></entry>
                                            <entry><codeph>MISSING</codeph></entry>
                                        </row>
                                        <row>
                                            <entry><codeph>NULL</codeph></entry>
                                            <entry><codeph>MISSING</codeph></entry>
                                        </row>
                                        <row>
                                            <entry>an array</entry>
                                            <entry>an empty array</entry>
                                        </row>
                                        <row>
                                            <entry>a non-array value</entry>
                                            <entry>an empty array</entry>
                                        </row>
                                    </tbody>
                                </tgroup>
                            </table></dd>
                    </dlentry>
                </dl>
            </p><p><b>NEST Example 1: Join two keyspaces producing an output for each left
                    input.</b></p><p>Show 1 set of routes for 1 airline in the
                    <codeph>`travel-sample`</codeph>
                keyspace.</p><codeblock>SELECT *
FROM `travel-sample` route
  INNER NEST `travel-sample` airline
  ON KEYS route.airlineid
WHERE route.type = "route"
LIMIT 1;</codeblock><p>This
                results
            in:</p><codeblock>[
  {
    "airline": [
      {
        "callsign": "AIRFRANS",
        "country": "France",
        "iata": "AF",
        "icao": "AFR",
        "id": 137,
        "name": "Air France",
        "type": "airline"
      }
    ],
    "route": {
      "airline": "AF",
      "airlineid": "airline_137",
      "destinationairport": "MRS",
      "distance": 2881.617376098415,
      "equipment": "320",
      "id": 10000,
      "schedule": [
        {
          "day": 0,
          "flight": "AF198",
          "utc": "10:13:00"
        },
        {
          "day": 0,
          "flight": "AF547",
          "utc": "19:14:00"
        },
        {
          "day": 0,
          "flight": "AF943",
          "utc": "01:31:00"
        },
        {
          "day": 1,
          "flight": "AF356",
          "utc": "12:40:00"
        },
        {
          "day": 1,
          "flight": "AF480",
          "utc": "08:58:00"
        },
        {
          "day": 1,
          "flight": "AF250",
          "utc": "12:59:00"
        },
        {
          "day": 1,
          "flight": "AF130",
          "utc": "04:45:00"
        },
        {
          "day": 2,
          "flight": "AF997",
          "utc": "00:31:00"
        },
        {
          "day": 2,
          "flight": "AF223",
          "utc": "19:41:00"
        },
        {
          "day": 2,
          "flight": "AF890",
          "utc": "15:14:00"
        },
        {
          "day": 2,
          "flight": "AF399",
          "utc": "00:30:00"
        },
        {
          "day": 2,
          "flight": "AF328",
          "utc": "16:18:00"
        },
        {
          "day": 3,
          "flight": "AF074",
          "utc": "23:50:00"
        },
        {
          "day": 3,
          "flight": "AF556",
          "utc": "11:33:00"
        },
        {
          "day": 4,
          "flight": "AF064",
          "utc": "13:23:00"
        },
        {
          "day": 4,
          "flight": "AF596",
          "utc": "12:09:00"
        },
        {
          "day": 4,
          "flight": "AF818",
          "utc": "08:02:00"
        },
        {
          "day": 5,
          "flight": "AF967",
          "utc": "11:33:00"
        },
        {
          "day": 5,
          "flight": "AF730",
          "utc": "19:42:00"
        },
        {
          "day": 6,
          "flight": "AF882",
          "utc": "17:07:00"
        },
        {
          "day": 6,
          "flight": "AF485",
          "utc": "17:03:00"
        },
        {
          "day": 6,
          "flight": "AF898",
          "utc": "10:01:00"
        },
        {
          "day": 6,
          "flight": "AF496",
          "utc": "07:00:00"
        }
      ],
      "sourceairport": "TLV",
      "stops": 0,
      "type": "route"
    }
  }
]</codeblock></section>
        <section><title>Arrays</title><p>If an array occurs along a path, you can use array
                subscripts to select one element. </p><p><b>Arrays Example 1a: List the arrays of
                        <codeph>public_likes</codeph>.
            </b></p><codeblock>SELECT public_likes
FROM `travel-sample` 
WHERE type = "hotel"
LIMIT 4;   </codeblock>This
            results
                    in:<codeblock>[
  {
    "public_likes": [
      "Julius Tromp I",
      "Corrine Hilll",
      "Jaeden McKenzie",                          / 3rd item
      "Vallie Ryan",
      "Brian Kilback",
      "Lilian McLaughlin",
      "Ms. Moses Feeney",
      "Elnora Trantow"
    ]
  },
  {
    "public_likes": []
  },
  {
    "public_likes": []
  },
  {
    "public_likes": [
      "Thomas Wilkinson",
      "Jesse Goyette",
      "Dallas Smitham",                            / 3rd item
      "Madilyn Kub",
      "Roxanne Murazik",
      "Kale Runte",
      "Ephraim Hane"
    ]
  }
]</codeblock><p><b>Arrays
                    Example 1b: List the third item of each <codeph>public_likes</codeph> array.
                </b></p><p>Remember that array counting starts with <codeph>0</codeph>, so
                    <codeph>2</codeph> points to the third
            item.</p><codeblock>SELECT public_likes<b>[2]</b>
FROM `travel-sample` 
WHERE type = "hotel"
LIMIT 4; </codeblock><codeblock>[
  {
    "$1": "Jaeden McKenzie"
  },
  {},
  {},
  {
    "$1": "Dallas Smitham"
  }
]</codeblock></section>
        <section id="as">
            <title>AS Keyword</title>
            <p>Like SQL, N1QL allows renaming fields using the <codeph>AS</codeph> keyword. However,
                N1QL also allows reshaping the data, which has no analog in SQL. To do this, you
                embed the attributes of the statement in the desired result object shape.</p>
        </section>
        <section>
            <title>Aliases</title>
            <p>Aliases in the <codeph>FROM</codeph> clause create new names that can be referred to
                anywhere in the query. When an alias conflicts with a keyspace or field name in the
                same scope, the identifier always refers to the alias. This allows for consistent
                behavior in scenarios where an identifier only conflicts in some documents. For more
                information on aliases, see <xref href="identifiers.dita"/>.</p>
        </section>
    </body>
</topic>
