<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="datefun" xml:lang="en-US">
	<title>Date Functions</title>
	<shortdesc>N1QL date functions return the system clock value or manipulate the datetime values,
        which are represented as a string or an integer. These functions are very useful for
        manipulating dates in datasets with various date formats and timezones. </shortdesc>
	<conbody>
        <section id="date-timezone"><title>Timezones</title>Datetime values are always tied to a
            specific timezone, either explicitly in the date value, or implicitly in the
            application. The date functions in N1QL therefore support multiple different timezones.<dl>
                <dlentry>
                    <dt><b>UTC</b></dt>
                    <dd>UTC, The Coordinated Universal Time is the primary time standard by which
                        the world regulates clocks and time. It is defined as the time at 0Â°
                        longitude and is consistent, as it does not take into account daylight
                        savings time. You can read further about UTC at 
                        <xref href="https://www.timeanddate.com/time/aboututc.html" format="html" scope="external"></xref>. <p>All N1QL
                            functions which accept a timezone as an argument also accept
                                <codeph>UTC</codeph>.</p></dd>
                </dlentry>
                <dlentry>
                    <dt><b>IANA Timezones</b></dt>
                    <dd>Many applications operate across multiple different time zones and may not
                        necessarily use <codeph>UTC</codeph>. Therefore, it is important for the
                        database to be able to handle and manipulate dates in these time zones in a
                        consistent manner. Many date functions take the time zone as an additional
                        argument. <note>Timezones are case sensitive,<codeph> Europe/London
                            </codeph>is not the same as<codeph> europe/london</codeph>.</note><p> It
                            is important to note that many time zones change their UTC offset based
                            on daylight savings time, as a result the UTC offset of times may change
                            based on the time of year. N1QL take this into account when converting
                            dates. </p>Below are a few examples of commonly used timezones and their
                        offsets: <table frame="all" rowsep="1" colsep="1" id="table_sfk_mqq_5y">
                            <title>Common Timezones</title>
                            <tgroup cols="3">
                                <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                                <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                                <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                                <thead>
                                    <row>
                                        <entry>Timezone</entry>
                                        <entry>UTC Offset (without daylight savings time)</entry>
                                        <entry>UTC Offset (during daylight savings time)</entry>
                                    </row>
                                </thead>
                                <tbody>
                                    <row>
                                        <entry>America/New_York</entry>
                                        <entry>-05:00</entry>
                                        <entry>-04:00</entry>
                                    </row>
                                    <row>
                                        <entry>America/Tijuana</entry>
                                        <entry>-08:00</entry>
                                        <entry>-07:00</entry>
                                    </row>
                                    <row>
                                        <entry>Europe/Paris</entry>
                                        <entry>+01:00</entry>
                                        <entry>+02:00</entry>
                                    </row>
                                    <row>
                                        <entry>Europe/London</entry>
                                        <entry>+00:00</entry>
                                        <entry>+01:00</entry>
                                    </row>
                                    <row>
                                        <entry>Asia/Tel_Aviv</entry>
                                        <entry>+02:00</entry>
                                        <entry>+03:00</entry>
                                    </row>
                                    <row>
                                        <entry>Asia/Kolkata</entry>
                                        <entry>+05:30</entry>
                                        <entry>+05:30</entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </table></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Local System Timezone</b></dt>
                    <dd>Many functions default to using the local timezone of the system, which will be one of the IANA timezones.</dd>
                </dlentry>
            </dl></section>
        <section id="date-formats">
            <title>Date Formats</title>
            <p>N1QL date functions accept dates in either Epoch/UNIX timestamp format or string date
                format. N1QL is then able to represent the passed date as a standardized date object
                internally. In general, functions whose name contains the word <codeph>STR</codeph>
                are designed to use string formats while<codeph> MILLIS </codeph>functions are
                designed to use Epoch/UNIX timestamps.<dl>
                    <dlentry id="unix-time">
                        <dt><b>Epoch/UNIX Timestamps</b></dt>
                        <dd>Epoch/UNIX time is the number of seconds (or milliseconds) that have
                            elapsed since<codeph> 1970-01-01T00:00:00.000Z </codeph>(Thursday, 1
                            January 1970 at midnight), not including leap seconds. This can be
                            useful for numeric and timezone agnostic representations of dates. While
                            Epoch/UNIX time can be represented in either seconds or milliseconds,
                                <b>all N1QL date functions specifically treat Epoch/UNIX timestamps
                                as milliseconds</b>. For example, the date<codeph>
                                2017-01-31T10:02:07Z </codeph>would equate to an Epoch/UNIX
                            timestamp of 1485856927000.</dd>
                    </dlentry>
                    <dlentry id="date-string">
                        <dt><b>Date String Formats</b></dt>
                        <dd>In many cases, dates are not stored as Epoch/UNIX timestamp but instead
                            as more human-readable formats, such as<codeph>
                                2006-01-02T15:04:05.567+08:00</codeph>. Therefore, N1QL also
                            provides convenience methods to allow you to manipulate and convert
                            dates in string format. All date formats follow the <xref
                                href="https://www.w3.org/TR/NOTE-datetime" scope="external"
                                format="html">ISO-8601 standard</xref>.<p>The supported string
                                formats are composed of the following components:</p><table
                                frame="all" rowsep="1" colsep="1" id="table_vwg_psq_5y">
                                <title>Date String Components</title>
                                <tgroup cols="3">
                                    <colspec colname="c1" colnum="1" colwidth="2.0*"/>
                                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                                    <colspec colname="c3" colnum="3" colwidth="2.0*"/>
                                    <thead>
                                        <row>
                                            <entry>Component</entry>
                                            <entry>Code</entry>
                                            <entry>Example</entry>
                                        </row>
                                    </thead>
                                    <tbody>
                                        <row>
                                            <entry>Year</entry>
                                            <entry>YYYY</entry>
                                            <entry>2006</entry>
                                        </row>
                                        <row>
                                            <entry>Month (of the year)</entry>
                                            <entry>MM</entry>
                                            <entry>01</entry>
                                        </row>
                                        <row>
                                            <entry>Day (of the month)</entry>
                                            <entry>DD</entry>
                                            <entry>02</entry>
                                        </row>
                                        <row>
                                            <entry>Hour (of the day)</entry>
                                            <entry>hh</entry>
                                            <entry>15</entry>
                                        </row>
                                        <row>
                                            <entry>Minute (of the hour)</entry>
                                            <entry>mm</entry>
                                            <entry>04</entry>
                                        </row>
                                        <row>
                                            <entry>Second (of the minute)</entry>
                                            <entry>ss</entry>
                                            <entry>05</entry>
                                        </row>
                                        <row>
                                            <entry>Millisecond (of the second)</entry>
                                            <entry>s</entry>
                                            <entry>567</entry>
                                        </row>
                                        <row>
                                            <entry>Time Zone (as UTC offset)</entry>
                                            <entry>TZD</entry>
                                            <entry>-08:00<note>A UTC offset of 0 (+00:00) can just
                                                  be specified as <codeph>Z</codeph></note></entry>
                                        </row>
                                    </tbody>
                                </tgroup>
                            </table><p>The following table shows all of the accepted string date
                                formats for N1QL date functions, using the date components specified
                                above. In cases where the timezone is not specified, the local
                                system time is assumed:<table frame="all" rowsep="1" colsep="1"
                                    id="table_z31_3tq_5y">
                                    <title>Date String Examples</title>
                                    <tgroup cols="2">
                                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                                        <colspec colname="c2" colnum="2" colwidth="2*"/>
                                        <thead>
                                            <row>
                                                <entry>Format</entry>
                                                <entry>Example</entry>
                                            </row>
                                        </thead>
                                        <tbody>
                                            <row>
                                                <entry>YYYY-MM-DDThh:mm:ss.sTZD</entry>
                                                <entry>2006-01-02T15:04:05.999+00:00 or
                                                  2006-01-02T15:04:05.999Z</entry>
                                            </row>
                                            <row>
                                                <entry>YYYY-MM-DDThh:mm:ssTZD</entry>
                                                <entry>2006-01-02T15:04:05+00:00 or
                                                  2006-01-02T15:04:05Z</entry>
                                            </row>
                                            <row>
                                                <entry>YYYY-MM-DDThh:mm:ss.s</entry>
                                                <entry>2006-01-02T15:04:05.999</entry>
                                            </row>
                                            <row>
                                                <entry>YYYY-MM-DDThh:mm:ss</entry>
                                                <entry>2006-01-02T15:04:05</entry>
                                            </row>
                                            <row>
                                                <entry>YYYY-MM-DD hh:mm:ss.sTZD</entry>
                                                <entry>2006-01-02 15:04:05.999+00:00 or 2006-01-02
                                                  15:04:05.999Z</entry>
                                            </row>
                                            <row>
                                                <entry>YYYY-MM-DD hh:mm:ssTZD</entry>
                                                <entry>2006-01-02 15:04:05+00:00 or 2006-01-02
                                                  15:04:05Z</entry>
                                            </row>
                                            <row>
                                                <entry>YYYY-MM-DD hh:mm:ss.s</entry>
                                                <entry>2006-01-02 15:04:05.999</entry>
                                            </row>
                                            <row>
                                                <entry>YYYY-MM-DD hh:mm:ss</entry>
                                                <entry>2006-01-02 15:04:05</entry>
                                            </row>
                                            <row>
                                                <entry>YYYY-MM-DD</entry>
                                                <entry>2006-01-02</entry>
                                            </row>
                                            <row>
                                                <entry>hh:mm:ss.sTZD</entry>
                                                <entry>15:04:05.999+00:00 or 15:04:05.999Z</entry>
                                            </row>
                                            <row>
                                                <entry>hh:mm:ssTZD</entry>
                                                <entry>15:04:05+00:00 or 15:04:05Z</entry>
                                            </row>
                                            <row>
                                                <entry>hh:mm:ss.s</entry>
                                                <entry>15:04:05.999</entry>
                                            </row>
                                            <row>
                                                <entry>hh:mm:ss</entry>
                                                <entry>15:04:05</entry>
                                            </row>
                                        </tbody>
                                    </tgroup>
                                </table></p><note>Currently N1QL only accepts numeric format strings
                                with valid values for each component. For example, you should pass
                                something like<codeph> "1111-11-11" </codeph>as the date format
                                rather than<codeph> "YYYY-MM-DD"</codeph>, this has the same effect
                                as passing in any other valid date in the same format (such
                                    as<codeph> "2017-01-31"</codeph>). <p>If the date string does
                                    not explicitly declare the value of a component, then a value of
                                    0 is assumed. For example<codeph> 2016-02-07 </codeph>is
                                    equivalent to<codeph> 2016-02-07T00:00:00</codeph>. This is with
                                    the exception of the time zone, which if unspecified in the date
                                    string will default to the local system time zone.</p><p>N1QL is
                                    very specific as to what it accepts as a valid date format,
                                    below are a few examples:<ul id="ul_orx_pyb_wy">
                                        <li><codeph>"01:01:01"</codeph> - Valid</li>
                                        <li><codeph>"hh:mm:ss"</codeph> - Invalid</li>
                                        <li><codeph>"01:01:01.111"</codeph> - Valid</li>
                                        <li><codeph>"01:01.111"</codeph> - Invalid</li>
                                        <li><codeph>"2017-01-31"</codeph> - Valid</li>
                                        <li><codeph>"2017-01-86"</codeph> - Invalid</li>
                                    </ul></p></note></dd>
                    </dlentry>
                </dl></p>
        </section>
        <section id="manipulating-components">
            <title>Manipulating Date Components</title>
            <p>Dates are composed of multiple different components such as the day, year, month etc.
                It is important for applications to be able to manipulate particular components of a
                date. Functions such as <xref href="#datefun/fn-date-add-str">DATE_ADD_STR()</xref>
                accept a <codeph>part</codeph> argument, which is the component to adjust. Below is
                a list of accepted parts, these are expressed as strings and are not case-sensitive:
                    <ul id="ul_egx_j5q_5y">
                    <li dir="ltr">
                        <p><codeph>millennium</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>century</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>decade</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>year</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>quarter</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>month</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>week</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>day</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>hour</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>minute</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p><codeph>second</codeph></p>
                    </li>
                    <li dir="ltr">
                        <p dir="ltr"><codeph>millisecond</codeph></p>
                    </li>
                </ul></p>
        </section>
        <section id="extracting-components">
            <title>Extracting Date Components</title>
            <p>It is important for applications to be able to extract the specific component of the
                timestamps, such as day, year, month, hours, minutes, or seconds, so that these can
                be used in N1QL queries. The following are the supported date parts that can be
                passed to the date extraction functions. These date parts are expressed as strings
                and are not case-sensitive, so<codeph> year </codeph>is regarded the same as<codeph>
                    YeAr</codeph>. For all examples, the date being used is<codeph>
                    2006-01-02T15:04:05.999Z</codeph></p>
            <table frame="all" rowsep="1" colsep="1" id="table_nvb_t5q_5y">
                <title>Timestamp Components</title>
                <tgroup cols="5">
                    <colspec colname="c1" colnum="1" colwidth="2.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="6.0*"/>
                    <colspec colname="newCol3" colnum="3" colwidth="1*"/>
                    <colspec colname="newCol4" colnum="4" colwidth="1*"/>
                    <colspec colname="newCol5" colnum="5" colwidth="1*"/>
                    <thead>
                        <row>
                            <entry>Component</entry>
                            <entry>Description</entry>
                            <entry>Lower Bound</entry>
                            <entry>Upper Bound</entry>
                            <entry>Example</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>millennium</entry>
                            <entry>The millennium (1000 year period), which begins at 0 BCE.</entry>
                            <entry>-</entry>
                            <entry>-</entry>
                            <entry>3</entry>
                        </row>
                        <row>
                            <entry>century</entry>
                            <entry>The century (100 year period), which begins at 0 BCE.</entry>
                            <entry>-</entry>
                            <entry>-</entry>
                            <entry>21</entry>
                        </row>
                        <row>
                            <entry>decade</entry>
                            <entry>The decade (10 year period). This is calculated as <codeph>floor(year / 10)</codeph>.</entry>
                            <entry>-</entry>
                            <entry>-</entry>
                            <entry>200</entry>
                        </row>
                        <row>
                            <entry>year</entry>
                            <entry>The Gregorian year, which begins at 0 BCE</entry>
                            <entry>-</entry>
                            <entry>-</entry>
                            <entry>2006</entry>
                        </row>
                        <row>
                            <entry>iso_year</entry>
                            <entry>The ISO-8601 week number of the year. Each ISO-8601 year begins with the Monday of the week 
                                containing the 4th of January, so in early January and late December the ISO year may differ from the Gregorian year.
                                Should be used in conjunction with <codeph>iso_week</codeph> to get consistent results.</entry>
                            <entry>-</entry>
                            <entry>-</entry>
                            <entry>2006</entry>
                        </row>
                        <row>
                            <entry>quarter</entry>
                            <entry>The number of the quarter (3 month period) of the year. January-March (inclusive) is 1 while 
                                October-December (inclusive) is 4.</entry>
                            <entry>1</entry>
                            <entry>4</entry>
                            <entry>1</entry>
                        </row>
                        <row>
                            <entry>month</entry>
                            <entry>The number of the month of the year. January is 1 and December is 12.</entry>
                            <entry>1</entry>
                            <entry>12</entry>
                            <entry>1</entry>
                        </row>
                        <row>
                            <entry>week</entry>
                            <entry>The number of the week of the year. This is the ceiling value of the day of the year divided by 7.</entry>
                            <entry>1</entry>
                            <entry>53</entry>
                            <entry>1</entry>
                        </row>
                        <row>
                            <entry>iso_week</entry>
                            <entry>The number of the week of the year, based on the ISO definition.
                                ISO weeks start on Mondays and the first week of a year contains
                                January 4 of that year. In other words, the first Thursday of a year
                                will always be in week 1 of that year. This results in some
                                different results between week and<codeph> iso_week</codeph>, based
                                on the input date. <p>For example the<codeph> iso_week
                                        </codeph>of<codeph> 2006-01-08T15:04:05.999Z </codeph>is 1,
                                    while the<codeph> week </codeph>is 2. Should be used in
                                    conjunction with<codeph> iso_year </codeph>to get consistent
                                    results.</p></entry>
                            <entry>1</entry>
                            <entry>53</entry>
                            <entry>1</entry>
                        </row>
                        <row>
                            <entry>day</entry>
                            <entry>The day of the month.</entry>
                            <entry>1</entry>
                            <entry>31</entry>
                            <entry>2</entry>
                        </row>
                        <row>
                            <entry>day_of_year or doy</entry>
                            <entry>The day of the year.</entry>
                            <entry>1</entry>
                            <entry>366</entry>
                            <entry>2</entry>
                        </row>
                        <row>
                            <entry>day_of_week or dow</entry>
                            <entry>The day of the week.</entry>
                            <entry>0</entry>
                            <entry>6</entry>
                            <entry>1</entry>
                        </row>
                        <row>
                            <entry>hour</entry>
                            <entry>The hour of the day.</entry>
                            <entry>0</entry>
                            <entry>23</entry>
                            <entry>5</entry>
                        </row>
                        <row>
                            <entry>minute</entry>
                            <entry>The minute of the hour.</entry>
                            <entry>0</entry>
                            <entry>59</entry>
                            <entry>4</entry>
                        </row>
                        <row>
                            <entry>second</entry>
                            <entry>The second of the minute.</entry>
                            <entry>0</entry>
                            <entry>59</entry>
                            <entry>5</entry>
                        </row>
                        <row>
                            <entry>millisecond</entry>
                            <entry>The millisecond of the second.</entry>
                            <entry>0</entry>
                            <entry>999</entry>
                            <entry>999</entry>
                        </row>
                        <row>
                            <entry>timezone</entry>
                            <entry>The offset from UTC in seconds.</entry>
                            <entry>-43200</entry>
                            <entry>43200</entry>
                            <entry>0</entry>
                        </row>
                        <row>
                            <entry>timezone_hour</entry>
                            <entry>The hour component of the offset from UTC.</entry>
                            <entry>-12</entry>
                            <entry>12</entry>
                            <entry>0</entry>
                        </row>
                        <row>
                            <entry>timezone_minute</entry>
                            <entry>The minute component of the offset from UTC.</entry>
                            <entry>-59</entry>
                            <entry>59</entry>
                            <entry>0</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section id="section_trq_pwq_5y">
            <title>Date Functions</title>
            <p>Below is a list of all date functions that N1QL provides.</p>
            <note type="important">Many date functions use the local system clock value and timezone
                of the query node to generate results. Therefore, if all nodes running the query
                service do not have their time appropriately synchronized then you may experience
                inconsistent behavior. It is recommended that all Couchbase Server nodes have their
                    <xref href="../../install/synchronize-clocks-using-ntp.dita">time synchronized
                    via NTP</xref>.</note>
                <note>If any arguments to any of the following functions are<codeph> MISSING
                </codeph>then the result is also<codeph> MISSING </codeph> (i.e. no result is
                returned). Similarly, if any of the arguments are<codeph> NULL </codeph>then<codeph>
                    NULL </codeph>is returned.</note>
        </section>
        <section id="fn-date-clock-local">
            <title>CLOCK_LOCAL([fmt])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>The current time (at function evaluation time) of the machine that the query
                        service is running on, in the specified string format.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                        <dlentry>
                            <dt><b>fmt</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as. <p><b>Optional argument</b>, if no format
                                        or an incorrect format is specified, then this defaults to
                                        the combined full date and time.</p></dd>
                        </dlentry>
                    </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string in the format specified representing the local system
                        time.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd><codeph>CLOCK_LOCAL()</codeph> cannot be used as part of an index
                        definition, this includes the indexed fields and the <codeph>WHERE</codeph>
                        clause of the index.</dd>
                    <dd>If this function is called multiple times within the same query then the
                        values returned may differ, particularly if the query takes a long time to
                        run. To avoid inconsistencies between multiple calls to
                            <codeph>CLOCK_LOCAL()</codeph> within a single query, use
                        <xref href="#datefun/fn-date-now-local">NOW_LOCAL()</xref> instead. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT CLOCK_LOCAL() as full_date, 
       CLOCK_LOCAL('invalid date') as invalid_date, 
       CLOCK_LOCAL('1111-11-11') as short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_date": "2018-01-23T13:57:29.847-08:00",
    "invalid_date": "2018-01-23T13:57:29.847-08:00",
    "short_date": "2018-01-23"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-clock-millis">
            <title>CLOCK_MILLIS()</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>The current time as an Epoch/UNIX timestamp. Its fractional part represents
                        nanoseconds, but the additional precision beyond milliseconds may not be
                        consistent or guaranteed on all platforms.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>This function accepts no arguments.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A single float value (with 3 decimal places) representing the system time as
                        Epoch/UNIX time.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd><codeph>CLOCK_MILLIS()</codeph> cannot be used as part of an index
                        definition, this includes the indexed fields and the <codeph>WHERE</codeph>
                        clause of the index.</dd>
                    <dd>If this function is called multiple times within the same query then the
                        values returned may differ, particularly if the query takes a long time to
                        run. To avoid inconsistencies between multiple calls to
                            <codeph>CLOCK_MILLIS()</codeph> within a single query, use
                        <xref href="#datefun/fn-date-now-millis">NOW_MILLIS()</xref> instead. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT CLOCK_MILLIS() AS CurrentTime;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "CurrentTime": 1516744600430.677
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-clock-str">
            <title>CLOCK_STR([fmt])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>The current time (at function evaluation time) of the machine that the query
                        service is running on, in the specified string format.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                        <dlentry>
                            <dt><b>fmt</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as. . </dd>
                                <dd><b>Optional argument</b>, if no format or an incorrect format is
                                    specified, then this defaults to the combined full date and
                                    time.</dd>
                        </dlentry>
                    </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string in the format specified representing the system time.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd><codeph>CLOCK_STR()</codeph> cannot be used as part of an index definition,
                        this includes the indexed fields and the <codeph>WHERE</codeph> clause of
                        the index.</dd>
                    <dd>If this function is called multiple times within the same query then the
                        values returned may differ, particularly if the query takes a long time to
                        run. To avoid inconsistencies between multiple calls to
                            <codeph>CLOCK_STR()</codeph> within a single query, use
                        <xref href="#datefun/fn-date-now-str">NOW_STR()</xref> instead. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT CLOCK_STR() as full_date, 
       CLOCK_STR('invalid date') as invalid_date,
       CLOCK_STR('1111-11-11') as short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_date": "2018-01-23T13:55:10.798-08:00",
    "invalid_date": "2018-01-23T13:55:10.798-08:00",
    "short_date": "2018-01-23"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
	    <section id="fn-date-clock-tz">
	        <title>CLOCK_TZ(tz [, fmt])</title>
	        <dl>
	            <dlentry>
	                <dt><b>Description</b></dt>
	                <dd>The current time (at function evaluation time) in the timezone given by the
                        timezone argument passed to the function. This time is the local system time
                        converted to the specified timezone.</dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Arguments</b></dt>
	                <dd><dl>
	                    <dlentry>
	                        <dt><b>tz</b></dt>
	                        <dd>A string, or any valid <xref href="index.dita">expression</xref> which
	                            evaluates to a string, representing the <xref href="#datefun/date-timezone">timezone</xref> to convert the local time to. </dd>
                                <dd>If this argument is not a valid timezone then
                                        <codeph>null</codeph> is returned as the result.</dd>
	                    </dlentry>
	                    <dlentry>
	                        <dt><b>fmt</b></dt>
	                        <dd>A string, or any valid <xref href="index.dita">expression</xref> which
                                    evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as.</dd>
                                <dd><b>Optional argument</b>, if no format or an incorrect format is
                                    specified, then this defaults to the combined full date and
                                    time.</dd>
	                    </dlentry>
	                </dl></dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Return Value</b></dt>
	                <dd>An date string in the format specified representing the system time in the
                        specified timezone.</dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Limitations</b></dt>
	                <dd>As this function converts the local time, it may not accurately represent the
                        true time in that timezone. </dd>
                    <dd><codeph>CLOCK_TZ()</codeph> cannot be used as part of an index definition,
                        this includes the indexed fields and the <codeph>WHERE</codeph> clause of
                        the index.</dd>
                    <dd>If this function is called multiple times within the same query then the
                        values returned may differ, particularly if the query takes a long time to
                        run. To avoid inconsistencies between multiple calls to
                            <codeph>CLOCK_TZ()</codeph> within a single query, use
                        <xref href="#datefun/fn-date-now-tz">NOW_TZ()</xref> instead. </dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Examples</b></dt>
	                <dd><codeblock outputclass="language-json">SELECT CLOCK_TZ('UTC') as UTC_full_date, 
       CLOCK_TZ('UTC', '1111-11-11') as UTC_short_date, 
       CLOCK_TZ('invalid timezone') as invalid_timezone, 
       CLOCK_TZ('US/Eastern') as us_east, 
       CLOCK_TZ('US/Pacific') as us_west;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "UTC_full_date": "2018-01-23T21:54:37.178Z",
    "UTC_short_date": "2018-01-23",
    "invalid_timezone": null,
    "us_east": "2018-01-23T16:54:37.18-05:00",
    "us_west": "2018-01-23T13:54:37.181-08:00"
  }
]</codeblock></dd>
	            </dlentry>
	        </dl>
	    </section>
        <section id="fn-date-clock-utc">
            <title>CLOCK_UTC([fmt])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>The current time in UTC. This time is the local system time converted to UTC. This function is provided for convenience and is the same as <codeph>CLOCK_TZ('UTC')</codeph>.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                        <dlentry>
                            <dt><b>fmt</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as. </dd>
                                <dd><b>Optional argument</b>, if no format or an incorrect format is
                                    specified, then this defaults to the combined full date and
                                    time.</dd>
                        </dlentry>
                    </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An date string in the format specified representing the system time in
                        UTC.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>As this function converts the local time, it may not accurately represent
                        the true time in UTC.</dd>
                    <dd><codeph>CLOCK_UTC() </codeph>cannot be used as part of an index definition,
                        this includes the indexed fields and the<codeph> WHERE </codeph>clause of
                        the index.</dd>
                    <dd>If this function is called multiple times within the same query then the
                        values returned may differ, particularly if the query takes a long time to
                        run. To avoid inconsistencies between multiple calls to<codeph> CLOCK_UTC()
                        </codeph>within a single query, use <xref href="#datefun/fn-date-now-utc"
                            >NOW_UTC()</xref> instead. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT CLOCK_UTC() as full_date, CLOCK_UTC('1111-11-11') as short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_date": "2018-01-23T21:54:03.593Z",
    "short_date": "2018-01-23"
  }
]</codeblock></dd>
                </dlentry>
            </dl></section>
        
        <section id="fn-date-add-millis">
            <title>DATE_ADD_MILLIS(date1, n, part)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Performs date arithmetic on a particular component of an Epoch/UNIX
                        timestamp value. This calculation is specified by the arguments<codeph> n
                            </codeph>and<codeph> part</codeph>. </dd>
                    <dd>For example, a value of 3 for<codeph> n </codeph>and a value of<codeph> day
                            </codeph>for<codeph> part </codeph>would add 3 days to the date
                        specified by<codeph> date1</codeph>. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                        <dlentry>
                            <dt><b>date1</b></dt>
                            <dd>An integer, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to an integer, representing an Epoch/UNIX
                                    timestamp in milliseconds. </dd>
                                <dd>If this argument is not an integer then <codeph>null</codeph> is
                                    returned.</dd>
                        </dlentry>
                        <dlentry>
                            <dt><b>n</b></dt>
                            <dd>The value to increment the date component by. This value must be an
                                    integer, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to an integer, and may be negative to perform
                                    date subtraction. </dd>
                                <dd>If a non-integer is passed to the function then
                                        <codeph>null</codeph> is returned.</dd>
                        </dlentry>
                        <dlentry>
                            <dt><b>part</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> of
                                    the date to increment.</dd>
                                <dd>If an invalid part is passed to the function then
                                        <codeph>null</codeph> is returned.</dd>
                        </dlentry>
                    </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer, representing the result of the calculation as an Epoch/UNIX
                        timestamp in milliseconds.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DATE_ADD_MILLIS(1463284740000, 3, 'day') as add_3_days, 
       DATE_ADD_MILLIS(1463284740000, 3, 'year') as add_3_years,
       DATE_ADD_MILLIS(1463284740000, -3, 'day') as sub_3_days, 
       DATE_ADD_MILLIS(1463284740000, -3, 'year') as sub_3_years;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "add_3_days": 1463543940000,
    "add_3_years": 1557892740000,
    "sub_3_days": 1463025540000,
    "sub_3_years": 1368590340000
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-add-str">
            <title>DATE_ADD_STR(date1, n, part)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Performs date arithmetic on a date string. This calculation is specified by
                        the arguments<codeph> n </codeph>and<codeph> part</codeph>. For example a
                        value of 3 for<codeph> n </codeph>and a value of<codeph> day
                            </codeph>for<codeph> part </codeph>would add 3 days to the date
                        specified by<codeph> date1</codeph>. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                        <dlentry>
                            <dt><b>date1</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the date in a <xref
                                        href="#datefun/date-string">supported date
                                    format</xref>.</dd>
                        </dlentry>
                        <dlentry>
                            <dt><b>n</b></dt>
                            <dd>The value to increment the date component by. This value must be an
                                    integer, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to an integer, and may be negative to perform
                                    date subtraction. </dd>
                                <dd>If a non-integer is passed to the function then
                                        <codeph>null</codeph> is returned.</dd>
                        </dlentry>
                        <dlentry>
                            <dt><b>part</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> of
                                    the date to increment.</dd>
                                <dd>If an invalid part is passed to the function then
                                        <codeph>null</codeph> is returned.</dd>
                        </dlentry>
                    </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer representing the result of the calculation as an Epoch/UNIX
                        timestamp in milliseconds.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DATE_ADD_STR('2016-05-15 03:59:00Z', 3, 'day') as add_3_days,
       DATE_ADD_STR('2016-05-15 03:59:00Z', 3, 'year') as add_3_years,
       DATE_ADD_STR('2016-05-15 03:59:00Z', -3, 'day') as sub_3_days,
       DATE_ADD_STR('2016-05-15 03:59:00Z', -3, 'year') as sub_3_years;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "add_3_days": "2016-05-18T03:59:00Z",
    "add_3_years": "2019-05-15T03:59:00Z",
    "sub_3_days": "2016-05-12T03:59:00Z",
    "sub_3_years": "2013-05-15T03:59:00Z"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-diff-millis">
            <title>DATE_DIFF_MILLIS(date1, date2, part)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Finds the elapsed time between two Epoch/UNIX timestamps. This elapsed time
                        is measured from the date specified by<codeph> date2 </codeph>to the date
                        specified by<codeph> date1</codeph>.  If<codeph> date1 </codeph>is greater
                            than<codeph> date2</codeph>, then the value returned will be positive,
                        otherwise the value returned will be negative. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                        <dlentry>
                            <dt><b>date1</b></dt>
                            <dd>An integer, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to an integer, representing a Epoch/UNIX
                                    timestamp in milliseconds. This is the value that is subtracted
                                        from<codeph> date1</codeph>.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                        </dlentry>
                        <dlentry>
                                <dt><b>date2</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds.</dd>
                                <dd>This is the value that is subtracted from<codeph>
                                    date1</codeph>.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        <dlentry>
                            <dt><b>part</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                which evaluates to a string, representing the <xref href="#datefun/manipulating-components">component</xref> of the
                                    date to increment.</dd>
                                <dd>If an invalid part is passed to the function, then<codeph> null
                                    </codeph>is returned.</dd>
                        </dlentry>
                    </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer representing the elapsed time (based on the specified
                            <codeph>part</codeph>) between both dates.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DATE_DIFF_MILLIS(1463543940000, 1463284740000, 'day') as add_3_days,
       DATE_DIFF_MILLIS(1557892740000, 1463284740000, 'year') as add_3_years,
       DATE_DIFF_MILLIS(1463025540000, 1463284740000, 'day') as sub_3_days,
       DATE_DIFF_MILLIS(1368590340000, 1463284740000, 'year') as sub_3_years;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "add_3_days": 3,
    "add_3_years": 3,
    "sub_3_days": -3,
    "sub_3_years": -3
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-diff-str">
            <title>DATE_DIFF_STR(date1, date2, part)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Finds the elapsed time between two dates specified as formatted strings. This elapsed time
                        is measured from the date specified by <codeph>date2</codeph> to the date
                        specified by <codeph>date1</codeph>. If <codeph>date1</codeph> is greater
                        than <codeph>date2</codeph> then the value returned will be positive,
                        otherwise the value returned will be negative. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds. This is the
                                    value that is subtracted from<codeph> date1</codeph>.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>date2</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds.</dd>
                                <dd>This is the value that is subtracted from<codeph>
                                    date1</codeph>.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>part</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> of
                                    the date to increment.</dd>
                                <dd>If an invalid part is passed to the function, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer representing the elapsed time (based on the specified
                            <codeph>part</codeph>) between both dates.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><b>Example 1:</b> Find the day difference and year difference between two
                            strings.<codeblock outputclass="language-json">SELECT DATE_DIFF_STR('2016-05-18T03:59:00Z', '2016-05-15 03:59:00Z', 'day') as add_3_days,
       DATE_DIFF_STR('2019-05-15T03:59:00Z', '2016-05-15 03:59:00Z', 'year') as add_3_years,
       DATE_DIFF_STR('2016-05-12T03:59:00Z', '2016-05-15 03:59:00Z', 'day') as sub_3_days,
       DATE_DIFF_STR('2013-05-15T03:59:00Z', '2016-05-15 03:59:00Z', 'year') as sub_3_years;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "add_3_days": 3,
    "add_3_years": 3,
    "sub_3_days": -3,
    "sub_3_years": -3
  }
]</codeblock><b>Example
                            2:</b> List all hotel documents that were reviewed between two
                        dates.<codeblock>SELECT name, reviews[0].date 
FROM `travel-sample`
WHERE type = "hotel"
AND reviews[0].date BETWEEN "2013-01-01 00:00:00 +0100" AND "2014-01-01 00:00:00 +0100";</codeblock>The
                        same
                            as:<codeblock>SELECT name, reviews[0].date 
FROM `travel-sample`
WHERE type = "hotel"
AND reviews[0].date BETWEEN "2013-01-01 %" AND "2014-01-01 %";</codeblock>Results:<codeblock>[
  {
    "date": "2013-06-13 01:39:18 +0300",
    "name": "Le Clos Fleuri"
  },
  {
    "date": "2013-07-02 14:32:55 +0300",
    "name": "The George Hotel"
  },
  {
    "date": "2013-06-22 18:33:50 +0300",
    "name": "Medway Youth Hostel"
  },
...</codeblock><note>When
                            querying between two dates, you must specify the full date (with time
                            and time zone) or use the wildcard character (%).</note></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-format-str">
            <title>DATE_FORMAT_STR(date1, fmt)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts datetime strings from one supported date string format to a different supported date string format.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                        <dlentry>
                            <dt><b>date1</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>. </dd>
                                <dd>If this argument is not a valid date string then<codeph> null
                                    </codeph>is returned.</dd>
                        </dlentry>
                        <dlentry>
                            <dt><b>fmt</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as. </dd>
                                <dd>If an incorrect format is specified then this defaults to the
                                    combined full date and time.</dd>
                        </dlentry>
                    </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string in the format specified.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DATE_FORMAT_STR('2016-05-15T00:00:23+00:00', '1111-11-11') as full_to_short,
       DATE_FORMAT_STR('2016-05-15', '1111-11-11T00:00:00+00:00') as short_to_full,
       DATE_FORMAT_STR('01:10:05', '1111-11-11T01:01:01Z') as time_to_full;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_to_short": "2016-05-15",
    "short_to_full": "2016-05-15T00:00:00-07:00",
    "time_to_full": "0000-01-01T01:10:05-08:00"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-part-millis">
            <title>DATE_PART_MILLIS(date1, part [, tz])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Extracts the value of a given date component from an Epoch/UNIX timestamp value.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd><dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds. This is the
                                    value that is subtracted from<codeph> date1</codeph>.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>part</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> of
                                    the date to increment.</dd>
                                <dd>If an invalid part is passed to the function, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        <dlentry>
                            <dt><b>tz</b></dt>
                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/date-timezone">timezone</xref> to convert the
                                    local time to. </dd>
                                <dd><b>Optional argument</b>, defaults to the system timezone if not
                                    specified. If an incorrect time zone is provided, then<codeph>
                                        null </codeph>is returned.</dd>
                        </dlentry>
                    </dl></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer representing the value of the component extracted from the
                        timestamp.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DATE_PART_MILLIS(1463284740000, 'day') as day_local,
       DATE_PART_MILLIS(1463284740000, 'day', 'America/Tijuana') as day_pst,
       DATE_PART_MILLIS(1463284740000, 'day', 'UTC') as day_utc,
       DATE_PART_MILLIS(1463284740000, 'month') as month,
       DATE_PART_MILLIS(1463284740000, 'week') as week,
       DATE_PART_MILLIS(1463284740000, 'year') as year;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "day_local": 14,
    "day_pst": 14,
    "day_utc": 15,
    "month": 5,
    "week": 20,
    "year": 2016
  }
]               </codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-part-str">
            <title>DATE_PART_STR(date1, part)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Extracts the value of a given date component from a date string.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds. This is the
                                    value that is subtracted from<codeph> date1</codeph>.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>part</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> of
                                    the date to increment.</dd>
                                <dd>If an invalid part is passed to the function, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer representing the value of the component extracted from the
                        timestamp.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DATE_PART_STR('2016-05-15T03:59:00Z', 'day') as day,
       DATE_PART_STR('2016-05-15T03:59:00Z', 'millisecond') as millisecond,
       DATE_PART_STR('2016-05-15T03:59:00Z', 'month') as month,
       DATE_PART_STR('2016-05-15T03:59:00Z', 'week') as week,
       DATE_PART_STR('2016-05-15T03:59:00Z', 'year') as year;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "day": 15,
    "millisecond": 0,
    "month": 5,
    "week": 20,
    "year": 2016
  }
]           </codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-range-millis">
            <title>DATE_RANGE_MILLIS(date1, date2, part [,n])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Generates an array of dates from the start date specified by <codeph>date1</codeph> and the end date specified by <codeph>date2</codeph>, as Epoch/UNIX timestamps. 
                        The difference between each subsequent generated date can be adjusted.
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds. This is the
                                    value that is subtracted from<codeph> date1</codeph>.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>date2</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds.</dd>
                                <dd>This is the value that is subtracted from<codeph>
                                    date1</codeph>.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>part</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> of
                                    the date to increment.</dd>
                                <dd>If an invalid part is passed to the function, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>n</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing the value by which to increment the part component
                                    for each generated date.</dd>
                                <dd><b>Optional argument</b>, if not specified, this defaults to 1.
                                    If a value which is not an integer is specified, then<codeph>
                                        null </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An array of integers representing the generated dates, as Epoch/UNIX
                        timestamps, between<codeph> date1 </codeph>and<codeph> date2</codeph>.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>It is possible to generate very large arrays using this function. In some
                        cases the query engine may be unable to process all of these and cause
                        excessive resource consumption. It is therefore recommended that you first
                        validate the inputs to this function to ensure that the generated result is
                        a reasonable size.</dd>
                    <dd>If the start date is greater than the end date passed to the function then
                        an error will not be thrown, but the result array will be empty. An array of
                        descending dates can be generated by setting the start date greater than the
                        end date and specifying a negative value for<codeph> n</codeph>.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><b>Example 1:</b> Range of milliseconds by
                            month.<codeblock outputclass="language-json">SELECT DATE_RANGE_MILLIS(1480752000000, 1475478000000, 'month', -1) as Milliseconds;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Milliseconds": [
      1480752000000,
      1478156400000
    ]
  }
]</codeblock><b>Example
                            1b:</b> Range of milliseconds by previous
                        month.<codeblock outputclass="language-json">SELECT DATE_RANGE_MILLIS(1480752000000, 1449129600000, 'month', -1) as Months;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Months": [
      1480752000000,
      1478156400000,
      1475478000000,
      1472886000000,
      1470207600000,
      1467529200000,
      1464937200000,
      1462258800000,
      1459666800000,
      1456992000000,
      1454486400000,
      1451808000000
    ]
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-range-str">
            <title>DATE_RANGE_STR(start_date, end_date, date_interval [, quantity_int ])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Generates an array of date strings between the start date and end date,
                        calculated by the interval and quantity values. The input dates can be in
                        any of the <xref href="#datefun/date-string">supported date formats</xref>. </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>start_date</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>.
                                    This is the date used as the start date of the array
                                    generation.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>end_date</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>.
                                    This is the date used as the end date of the array generation,
                                    and this value is exclusive, that is, the end date will not be
                                    included in the result.<p> If this argument is not an integer,
                                            then<codeph> null </codeph>is returned.</p></dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>date_interval</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> of
                                    the date to increment.</dd>
                                <dd>If an invalid part is passed to the function, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>quantity_int</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing the value by which to increment the interval
                                    component for each generated date.</dd>
                                <dd><b>Optional argument</b>, if not specified, this defaults to 1.
                                    If a value which is not an integer is specified, then<codeph>
                                        null </codeph>is returned. </dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An array of strings representing the generated dates, as date strings,
                            between<codeph> start_date </codeph>and<codeph> end_date</codeph>.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>
                        <ul id="ul_cgb_5bn_sz">
                            <li>It is possible to generate very large arrays using this function. In
                                some cases the query engine may be unable to process all of these
                                and cause excessive resource consumption. It is therefore
                                recommended that you first validate the inputs of this function to
                                ensure that the generated result is a reasonable size.</li>
                        </ul>
                    </dd>
                    <dd>
                        <ul id="ul_bdq_5bn_sz">
                            <li>If the<codeph> start_date </codeph>is greater than the<codeph>
                                    end_date</codeph>, then an error will not be thrown, but the
                                result array will be empty. An array of descending dates can be
                                generated by setting the<codeph> start_date </codeph>greater than
                                    the<codeph> end_date </codeph>and specifying a negative value
                                    for<codeph> quantity_number</codeph>.</li>
                        </ul>
                    </dd>
                    <dd>
                        <ul id="ul_ofc_vbn_sz">
                            <li>From 4.6.2, both specified dates can be different acceptable date
                                formats; but prior to 4.6.2, both specified dates must have the same
                                string format, otherwise<codeph> null </codeph>will be returned. To
                                ensure that both dates have the same format, you should use <xref
                                    href="#datefun/fn-date-format-str"
                                >DATE_FORMAT_STR()</xref>.</li>
                        </ul>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><b>Example 1:</b> Ranges by
                            quarters.<codeblock outputclass="language-json">SELECT DATE_RANGE_STR('2015-11-30T15:04:05.999', '2017-04-14T15:04:06.998', 'quarter') AS Quarters;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Quarters": [
      "2015-11-30T15:04:05.999",
      "2016-03-01T15:04:05.999",
      "2016-06-01T15:04:05.999",
      "2016-09-01T15:04:05.999",
      "2016-12-01T15:04:05.999",
      "2017-03-01T15:04:05.999"
    ]
  }
]</codeblock><b>Example
                            2:</b> Ranges by a single
                            day.<codeblock outputclass="language-json">SELECT DATE_RANGE_STR('2016-01-01T15:04:05.999', '2016-01-05T15:04:05.998', 'day', 1) as Days;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Days": [
      "2016-01-01T15:04:05.999",
      "2016-01-02T15:04:05.999",
      "2016-01-03T15:04:05.999",
      "2016-01-04T15:04:05.999"
    ]
  }
]</codeblock><b>Example
                            3:</b> Ranges by four
                            months.<codeblock outputclass="language-json">SELECT DATE_RANGE_STR('2018-01-01','2019-01-01', 'month', 4) as Months;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Months": [
      "2018-01-01",
      "2018-05-01",
      "2018-09-01"
    ]
  }
]</codeblock><b>Example
                            4:</b> Ranges by previous
                            days.<codeblock outputclass="language-json">SELECT DATE_RANGE_STR('2016-01-05T15:04:05.999', '2016-01-01T15:04:06.998', 'day', -1) as Previous;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Previous": [
      "2016-01-05T15:04:05.999",
      "2016-01-04T15:04:05.999",
      "2016-01-03T15:04:05.999",
      "2016-01-02T15:04:05.999"
    ]
  }
]</codeblock><b>Example
                            5:</b> Ranges by
                        month.<codeblock outputclass="language-json">SELECT DATE_RANGE_STR('2015-01-01T01:01:01', '2015-12-11T00:00:00', 'month', 1) as Months;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Months": [
      "2015-01-01T01:01:01",
      "2015-02-01T01:01:01",
      "2015-03-01T01:01:01",
      "2015-04-01T01:01:01",
      "2015-05-01T01:01:01",
      "2015-06-01T01:01:01",
      "2015-07-01T01:01:01",
      "2015-08-01T01:01:01",
      "2015-09-01T01:01:01",
      "2015-10-01T01:01:01",
      "2015-11-01T01:01:01",
      "2015-12-01T01:01:01"
    ]
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-trunc-millis">
            <title>DATE_TRUNC_MILLIS(date1, part)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Truncates an Epoch/UNIX timestamp up to the specified date component.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds. This is the
                                    date used as the date to truncate.<p> If this argument is not an
                                        integer, then<codeph> null </codeph>is returned.</p></dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>part</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> to
                                    truncate to.<p>If an invalid part is specified, then<codeph>
                                            null </codeph>is returned.</p></dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer representing the truncated timestamp in Epoch/UNIX time.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>In some cases, where the timestamp is smaller than the duration of the provided part, this function returns the incorrect result. 
                        It is recommended that you do not use this function for very small Epoch/UNIX timestamps.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DATE_TRUNC_MILLIS(1463284740000, 'day') as day,
       DATE_TRUNC_MILLIS(1463284740000, 'month') as month,
       DATE_TRUNC_MILLIS(1463284740000, 'year') as year;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "day": 1463270400000,
    "month": 1462147200000,
    "year": 1451696400000
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-trunc-str">
            <title>DATE_TRUNC_STR(date1, part)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Truncates a date string up to the specified date component.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>.
                                    This is the date that is truncated.</dd>
                                <dd>If this argument is not a valid date format, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>part</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/manipulating-components">component</xref> to
                                    truncate to.</dd>
                                <dd>If an invalid part is specified, then<codeph> null </codeph>is
                                    returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string representing the truncated date.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DATE_TRUNC_STR('2016-05-18T03:59:00Z', 'day') as day,
       DATE_TRUNC_STR('2016-05-18T03:59:00Z', 'month') as month,
       DATE_TRUNC_STR('2016-05-18T03:59:00Z', 'year') as year;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "day": "2016-05-18T00:00:00Z",
    "month": "2016-05-01T00:00:00Z",
    "year": "2016-01-01T00:00:00Z"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-duration-to-str">
            <title>DURATION_TO_STR(duration)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts a number into a human-readable time duration with units.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>duration</b></dt>
                                <dd>A number, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a number, which represents the duration to
                                    convert to a string. This value is specified in nanoseconds
                                            (<codeph>1x10<sup>-9</sup> seconds</codeph>). </dd>
                                <dd>If a value which is not a number is specified, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A string representing the human-readable duration.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT DURATION_TO_STR(2000) as microsecs,
       DURATION_TO_STR(2000000) as millisecs,
       DURATION_TO_STR(2000000000) as secs;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "microsecs": "2Âµs",
    "millisecs": "2ms",
    "secs": "2s"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-millis">
            <title>MILLIS(date1)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts a date string to Epoch/UNIX milliseconds.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>.
                                    This is the date to convert to Epoch/UNIX milliseconds.</dd>
                                <dd>If this argument is not a valid date format. then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer representing the date string converted to Epoch/UNIX
                        milliseconds.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT MILLIS("2016-05-15T03:59:00Z") as DateStringInMilliseconds;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "DateStringInMilliseconds": 1463284740000
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-millis-to-local">
            <title>MILLIS_TO_LOCAL(date1 [, fmt])</title>
            <p>Alias for <xref href="#datefun/fn-date-millis-to-str">MILLIS_TO_STR()</xref>.</p>
        </section>
        <section id="fn-date-millis-to-str">
            <title>MILLIS_TO_STR(date1 [, fmt ])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts an Epoch/UNIX timestamp into the specified date string format.
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds. This is the
                                    date to convert.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>fmt</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as. </dd>
                                <dd><b>Optional argument</b>, if unspecified or an incorrect format
                                    is specified, then this defaults to the combined full date and
                                    time.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string representing the local date in the specified format.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>In some cases, where the timestamp is smaller than the duration of the provided part, this function returns the incorrect result. 
                        It is recommended that you do not use this function for very small Epoch/UNIX timestamps.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT MILLIS_TO_STR(1463284740000) as full_date, 
       MILLIS_TO_STR(1463284740000, 'invalid format') as invalid_format,
       MILLIS_TO_STR(1463284740000, '1111-11-11') as short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_date": "2016-05-14T20:59:00-07:00",
    "invalid_format": "2016-05-14T20:59:00-07:00",
    "short_date": "2016-05-14"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
	    <section id="fn-date-millis-to-tz">
	        <title>MILLIS_TO_TZ(date1, tz [, fmt])</title>
	        <dl>
	            <dlentry>
	                <dt><b>Description</b></dt>
	                <dd>Converts an Epoch/UNIX timestamp into the specified time zone in the specified date string format.
	                </dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Arguments</b></dt>
	                <dd>
	                    <dl>
	                        <dlentry>
	                            <dt><b>date1</b></dt>
	                            <dd>An integer, or any valid <xref href="index.dita"
	                                >expression</xref> which evaluates to an integer,
	                                representing a Epoch/UNIX timestamp in milliseconds. This is the
	                                date to convert.</dd>
	                            <dd>If this argument is not an integer, then<codeph> null </codeph>is
                                    returned.</dd>
	                        </dlentry>
	                        <dlentry>
	                            <dt><b>tz</b></dt>
	                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
	                                which evaluates to a string, representing the <xref
	                                    href="#datefun/date-timezone">timezone</xref> to convert the
	                                local time to. <b>Optional argument</b>, defaults to the system
	                                timezone if not specified. </dd>
	                            <dd>If an incorrect time zone is provided, then<codeph> null
                                    </codeph>is returned.</dd>
	                        </dlentry>
	                        <dlentry>
	                            <dt><b>fmt</b></dt>
	                            <dd>A string, or any valid <xref href="index.dita">expression</xref>
	                                which evaluates to a string, representing a <xref
	                                    href="#datefun/date-string">supported date format</xref> to
	                                output the result as.</dd>
	                            <dd><b>Optional argument</b>, if no format or an incorrect format is
                                    specified, then this defaults to the combined full date and
                                    time.</dd>
	                        </dlentry>
	                    </dl>
	                </dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Return Value</b></dt>
	                <dd>A date string representing the date in the specified timezone in the specified
                        format..</dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Examples</b></dt>
	                <dd><codeblock outputclass="language-json">SELECT MILLIS_TO_TZ(1463284740000, 'America/New_York') as est,
	   MILLIS_TO_TZ(1463284740000, 'Asia/Kolkata') as ist,
	   MILLIS_TO_TZ(1463284740000, 'UTC') as utc;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "est": "2016-05-14T23:59:00-04:00",
    "ist": "2016-05-15T09:29:00+05:30",
    "utc": "2016-05-15T03:59:00Z"
  }
]</codeblock></dd>
	            </dlentry>
	        </dl>
	    </section>
        <section id="fn-date-millis-to-utc">
            <title>MILLIS_TO_UTC(date1 [, fmt])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts an Epoch/UNIX timestamp into local time in the specified date string format.
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing a Epoch/UNIX timestamp in milliseconds. This is the
                                    date to convert to UTC.</dd>
                                <dd>If this argument is not an integer, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>fmt</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as. </dd>
                                <dd><b>Optional argument</b>, if unspecified or an incorrect format
                                    is specified, then this defaults to the combined full date and
                                    time.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string representing the date in UTC in the specified format.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT MILLIS_TO_UTC(1463284740000) as full_date, 
       MILLIS_TO_UTC(1463284740000, 'invalid format') as invalid_format,
       MILLIS_TO_UTC(1463284740000, '1111-11-11') as short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_date": "2016-05-15T03:59:00Z",
    "invalid_format": "2016-05-15T03:59:00Z",
    "short_date": "2016-05-15"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
	    <section id="fn-date-millis-to-zone-name">
	        <title>MILLIS_TO_ZONE_NAME(date1, tz [, fmt])</title>
	        <p>Alias for <xref href="#datefun/fn-date-millis-to-tz">MILLIS_TO_TZ()</xref></p>
	    </section>
	    <section id="fn-date-now-local">
	        <title>NOW_LOCAL([fmt])</title>
	        <dl>
	            <dlentry>
	                <dt><b>Description</b></dt>
	                <dd>The timestamp of the query as date string in the system timezone. Will not vary during a query.</dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Arguments</b></dt>
	                <dd><dl>
	                    <dlentry>
	                        <dt><b>fmt</b></dt>
	                        <dd>A string, or any valid <xref href="index.dita">expression</xref> which
                                    evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as.</dd>
	                        <dd><b>Optional argument</b>, if no format or an incorrect format is
                                    specified, then this defaults to the combined full date and
                                    time.</dd>
	                    </dlentry>
	                </dl></dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Return Value</b></dt>
	                <dd>A date time string in the format specified.</dd>
	            </dlentry>
	            <dlentry>
	                <dt><b>Limitations</b></dt>
	                <dd>If this function is called multiple times within the same query it will always return the same time. 
	                    If you wish to use the system time when the function is evaluated, use <xref href="#datefun/fn-date-clock-local">CLOCK_LOCAL()</xref> instead.</dd>
	            </dlentry>
	            
	            <dlentry>
	                <dt><b>Examples</b></dt>
	                <dd><b>Example 1:</b> Various arguments of
                        NOW_LOCAL().<codeblock outputclass="language-json">SELECT NOW_LOCAL() as full_date, 
       NOW_LOCAL('invalid date') as invalid_date,
       NOW_LOCAL('1111-11-11') as short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_date": "2018-01-23T14:03:40.26-08:00",
    "invalid_date": "2018-01-23T14:03:40.26-08:00",
    "short_date": "2018-01-23"
  }
]</codeblock>Example
                        2: Difference between NOW_LOCAL() and
                        CLOCK_LOCAL().<codeblock outputclass="language-json">SELECT NOW_LOCAL(), NOW_LOCAL(), NOW_LOCAL(), NOW_LOCAL(), NOW_LOCAL(), CLOCK_LOCAL();</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "$1": "2018-01-23T14:06:20.254-08:00",
    "$2": "2018-01-23T14:06:20.254-08:00",
    "$3": "2018-01-23T14:06:20.254-08:00",
    "$4": "2018-01-23T14:06:20.254-08:00",
    "$5": "2018-01-23T14:06:20.254-08:00",
    "$6": "2018-01-23T14:06:20.256-08:00"
  }
]</codeblock></dd>
	            </dlentry>
	        </dl>
	    </section>
        <section id="fn-date-now-millis">
            <title>NOW_MILLIS()</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>The timestamp of the query as an Epoch/UNIX timestamp. Will not vary during a query.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>This function accepts no arguments.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A floating point number representing the Epoch/UNIX timestamp of the
                        query.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>If this function is called multiple times within the same query it will always return the same time. 
                        If you wish to use the system time when the function is evaluated, use <xref href="#datefun/fn-date-clock-millis">CLOCK_MILLIS()</xref> instead.</dd>
                </dlentry>
                
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><b>Example 1:</b> The time now in
                            milliseconds.<codeblock outputclass="language-json">SELECT NOW_MILLIS() as NowInMilliseconds;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "NowInMilliseconds": 1516745378065.12
  }
]</codeblock><b>Example
                            2:</b> Difference between NOW_MILLIS() and
                        CLOCK_MILLIS().<codeblock outputclass="language-json">SELECT NOW_MILLIS(), NOW_MILLIS(), NOW_MILLIS(), NOW_MILLIS(), CLOCK_MILLIS();</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "$1": 1516745528579.607,
    "$2": 1516745528579.607,
    "$3": 1516745528579.607,
    "$4": 1516745528580.29
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-now-tz">
            <title>NOW_TZ(tz [, fmt])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>The timestamp of the query as date string in the specified timezone. Will
                        not vary during a query.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>tz</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/date-timezone">timezone</xref> to convert the
                                    query timestamp to. </dd>
                                <dd>If an incorrect time zone is provided then <codeph>null</codeph>
                                    is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>fmt</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as. </dd>
                                <dd><b>Optional argument</b>, if unspecified or an incorrect format
                                    is specified, then this defaults to the combined full date and
                                    time.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string in the format specified representing the timestamp of the
                        query in the specified timezone.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>If this function is called multiple times within the same query it will
                        always return the same time. If you wish to use the system time when the
                        function is evaluated, use <xref href="#datefun/fn-date-clock-tz">CLOCK_TZ()</xref> instead.</dd>
                </dlentry>
                
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><b>Example 1:</b> Various arguments for
                            NOW_TZ().<codeblock outputclass="language-json">SELECT NOW_TZ('invalid tz') as invalid_tz,
       NOW_TZ('Asia/Kolkata') as ist,
       NOW_TZ('UTC') as utc,
       NOW_TZ('UTC', '1111-11-11') as utc_short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "invalid_tz": null,
    "ist": "2018-01-24T03:43:36.457+05:30",
    "utc": "2018-01-23T22:13:36.457Z",
    "utc_short_date": "2018-01-23"
  }
]</codeblock><b>Example
                            2:</b> Difference between NOW_TZ() and
                        CLOCK_TZ().<codeblock outputclass="language-json">SELECT NOW_TZ('UTC'), NOW_TZ('UTC'), NOW_TZ('UTC'), CLOCK_TZ('UTC');</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "$1": "2018-01-23T22:15:59.551Z",
    "$2": "2018-01-23T22:15:59.551Z",
    "$3": "2018-01-23T22:15:59.551Z",
    "$4": "2018-01-23T22:15:59.552Z"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-now-str">
            <title>NOW_STR([fmt])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>The timestamp of the query as date string in the system timezone. Will not
                        vary during a query.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>fmt</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as.</dd>
                                <dd><b>Optional argument</b>, if unspecified or an incorrect format
                                    is specified, then this defaults to the combined full date and
                                    time.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string in the format specified representing the timestamp of the
                        query.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>If this function is called multiple times within the same query it will
                        always return the same time. If you wish to use the system time when the
                        function is evaluated, use <xref href="#datefun/fn-date-clock-str">CLOCK_STR()</xref> instead.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><b>Example 1:</b> Various arguments for
                            NOW_STR().<codeblock outputclass="language-json">SELECT NOW_STR() as full_date,
       NOW_STR('invalid date') as invalid_date,
       NOW_STR('1111-11-11') as short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_date": "2018-01-23T14:16:58.075-08:00",
    "invalid_date": "2018-01-23T14:16:58.075-08:00",
    "short_date": "2018-01-23"
  }
]</codeblock><b>Example
                            2:</b> Difference between NOW_STR() and
                        CLOCK_STR().<codeblock outputclass="language-json">SELECT NOW_STR(), NOW_STR(), NOW_STR(), NOW_STR(), NOW_STR(), NOW_STR(), CLOCK_STR();</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "$1": "2018-01-23T14:18:37.605-08:00",
    "$2": "2018-01-23T14:18:37.605-08:00",
    "$3": "2018-01-23T14:18:37.605-08:00",
    "$4": "2018-01-23T14:18:37.605-08:00",
    "$5": "2018-01-23T14:18:37.605-08:00",
    "$6": "2018-01-23T14:18:37.605-08:00",
    "$7": "2018-01-23T14:18:37.607-08:00"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-now-utc">
            <title>NOW_UTC([fmt])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>The timestamp of the query as date string in UTC. Will not vary during a
                        query.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>fmt</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a <xref
                                        href="#datefun/date-string">supported date format</xref> to
                                    output the result as.</dd>
                                <dd><b>Optional argument</b>, if unspecified or an incorrect format
                                    is specified, then this defaults to the combined full date and
                                    time.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A date string in the format specified representing the timestamp of the
                        query in UTC.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Limitations</b></dt>
                    <dd>If this function is called multiple times within the same query it will
                        always return the same time. If you wish to use the system time when the
                        function is evaluated, use <xref href="#datefun/fn-date-clock-utc">CLOCK_MILLIS()</xref> instead.</dd>
                </dlentry>
                
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><b>Example 1:</b> The current UTC
                            time.<codeblock outputclass="language-json">SELECT NOW_UTC() as CurrentUTC;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "CurrentUTC": "2018-01-23T22:20:43.971Z"
  }
]</codeblock><b>Example
                            2:</b> Difference between NOW_UTC() and
                        CLOCK_UTC().<codeblock outputclass="language-json">SELECT NOW_UTC(), NOW_UTC(), NOW_UTC(), NOW_UTC(), NOW_UTC(), NOW_UTC(), NOW_UTC(), CLOCK_UTC();</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "$1": "2018-01-23T22:21:46.769Z",
    "$2": "2018-01-23T22:21:46.769Z",
    "$3": "2018-01-23T22:21:46.769Z",
    "$4": "2018-01-23T22:21:46.769Z",
    "$5": "2018-01-23T22:21:46.769Z",
    "$6": "2018-01-23T22:21:46.769Z",
    "$7": "2018-01-23T22:21:46.769Z",
    "$8": "2018-01-23T22:21:46.77Z"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-str-to-duration">
            <title>STR_TO_DURATION(duration)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts a string representation of a time duration into nanoseconds. This
                        accepts the following units: <ul id="ul_mg5_nhy_5y">
                            <li>nanoseconds (<codeph>ns</codeph>)</li>
                            <li>microseconds (<codeph>us</codeph> or <codeph>Âµs</codeph>)</li>
                            <li>milliseconds (<codeph>ms</codeph>)</li>
                            <li>seconds (<codeph>s</codeph>)</li>
                            <li>minutes (<codeph>m</codeph>)</li>
                            <li>hours (<codeph>h</codeph>)</li>
                        </ul></dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>duration</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the duration to
                                    convert. </dd>
                                <dd>If an invalid duration string is specified, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A single integer representing the duration in nanoseconds.</dd>
                </dlentry>
                
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT STR_TO_DURATION('1h') as hour,
STR_TO_DURATION('1us') as microsecond,
STR_TO_DURATION('1ms') as millisecond,
STR_TO_DURATION('1m') as minute,
STR_TO_DURATION('1ns') as nanosecond,
STR_TO_DURATION('1s') as second;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "hour": 3600000000000,
    "microsecond": 1000,
    "millisecond": 1000000,
    "minute": 60000000000,
    "nanosecond": 1,
    "second": 1000000000
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-str-to-millis">
            <title>STR_TO_MILLIS(date1)</title>
        </section>
        <section id="section_bwc_tty_5y">
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts a date string to Epoch/UNIX milliseconds.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>.
                                    This is the date to convert to Epoch/UNIX milliseconds.</dd>
                                <dd>If this argument is not a valid date format, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>An integer representing the date string converted to Epoch/UNIX
                        milliseconds.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT STR_TO_MILLIS("2016-05-15T03:59:00Z") as Milliseconds;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Milliseconds": 1463284740000
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-str-to-utc">
            <title>STR_TO_UTC(date1)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts a date string into the equivalent date in UTC. The output date
                        format follows the date format of the date passed as input.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>.
                                    This is the date to convert to UTC.</dd>
                                <dd>If this argument is not a valid date format, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A single date string representing the date string converted to UTC.</dd>
                </dlentry>
                
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT STR_TO_UTC('1111-11-11T00:00:00+08:00') as full_date,
STR_TO_UTC('1111-11-11') as short_date;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "full_date": "1111-11-10T16:00:00Z",
    "short_date": "1111-11-11"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="fn-date-str-to-tz">
            <title>STR_TO_TZ(date1, tz)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts a date string to its equivalent in the specified timezone. The
                        output date format follows the date format of the date passed as input.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date1</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>.
                                    This is the date to convert to UTC.</dd>
                                <dd>If this argument is not a valid date format then
                                        <codeph>null</codeph> is returned.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>tz</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/date-timezone">timezone</xref> to convert the
                                    local time to. </dd>
                                <dd>If this argument is not a valid timezone, then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A single date string representing the date string converted to the specified
                        timezone.</dd>
                </dlentry>
                
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT STR_TO_TZ('1111-11-11T00:00:00+08:00', 'America/New_York') as est,
    STR_TO_TZ('1111-11-11T00:00:00+08:00', 'UTC') as utc,
    STR_TO_TZ('1111-11-11', 'UTC') as utc_short;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "est": "1111-11-10T11:00:00-05:00",
    "utc": "1111-11-10T16:00:00Z",
    "utc_short": "1111-11-11"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
	    <section id="fn-date-str-to-zone-name">
	        <title>STR_TO_ZONE_NAME(date1, tz)</title>
	        <p>Alias for <xref href="#datefun/fn-date-str-to-tz">STR_TO_TZ()</xref>.</p>
	    </section>
        <section id="section_pjh_514_qz">
            <title>WEEKDAY_MILLIS(expr [, tz ])</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Converts a date string to its equivalent in the specified timezone. The
                        output date format follows the date format of the date passed as input.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>expr</b></dt>
                                <dd>An integer, or any valid <xref href="index.dita"
                                        >expression</xref> which evaluates to an integer,
                                    representing an Epoch/UNIX timestamp in milliseconds.</dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>tz</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing the <xref
                                        href="#datefun/date-timezone">timezone</xref> to for the
                                    expr argument.</dd>
                                <dd><b>Optional argument</b>, defaults to the system timezone if not
                                    specified. If an incorrect time zone is provided then<codeph>
                                        null </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>A single date string representing the date string converted to the specified
                        timezone.</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT WEEKDAY_MILLIS(1486237655742, 'America/Tijuana') as Day;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Day": "Saturday"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
        <section id="section_wfd_dzn_qz">
            <title>WEEKDAY_STR(date)</title>
            <dl>
                <dlentry>
                    <dt><b>Description</b></dt>
                    <dd>Returns the day of the week string value from the input date string. Returns
                        the weekday name from the input date in Unix timestamp. Note that his
                        function returns the string value of the day of the week, where <xref
                            href="#datefun/fn-date-part-str" format="dita">DATE_PART_STR()</xref>
                        with part = "dow" returns an integer value of the weekday (0-6).</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Arguments</b></dt>
                    <dd>
                        <dl>
                            <dlentry>
                                <dt><b>date</b></dt>
                                <dd>A string, or any valid <xref href="index.dita">expression</xref>
                                    which evaluates to a string, representing a date in a <xref
                                        href="#datefun/date-string">supported date format</xref>.
                                    This is the date to convert to UTC.</dd>
                                <dd>If this argument is not a valid date format then<codeph> null
                                    </codeph>is returned.</dd>
                            </dlentry>
                        </dl>
                    </dd>
                </dlentry>
                <dlentry>
                    <dt><b>Return Value</b></dt>
                    <dd>The text string name of the day of the week, such as "Monday" or
                        "Friday".</dd>
                </dlentry>
                <dlentry>
                    <dt><b>Examples</b></dt>
                    <dd><codeblock outputclass="language-json">SELECT WEEKDAY_STR('2017-02-05') as Day;</codeblock>Results:<codeblock outputclass="language-json">[
  {
    "Day": "Sunday"
  }
]</codeblock></dd>
                </dlentry>
            </dl>
        </section>
    </conbody>
</concept>
