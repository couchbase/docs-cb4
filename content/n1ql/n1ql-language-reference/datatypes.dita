<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="topic_4" xml:lang="en-US">
	<title id="title__Toc272567214">Data types</title>
	<shortdesc>N1QL supports many data types: Boolean values, numeric values, string values,
		arrays, objects, NULL, and MISSING.</shortdesc>
	<conbody>
		
		<p>These types are described in detail in their respective sections. While N1QL does not
			support the Date data type, it does provide a robust set of functions to work with dates. </p>

		<section>
			<title>Boolean</title>
			<p>This type can have a value of TRUE and FALSE. The values are case insensitive. </p>
		</section>
		
		<section>
			<title>Numbers</title>
			<p>Numbers can be a signed decimal number that can contain a fractional part. Numbers can
				also use E-notation. </p>
		</section>

		<section>
			<title>String values</title>
			<p>Strings include all Unicode characters and backslash escape characters. They are
				delimited by single quotation marks ('') or double quotation marks (""). </p>
		</section>

		<section>
			<title>Arrays</title>
			<p> Arrays are an ordered list of zero or more values. The values can be of any type.
				Arrays are enclosed in square brackets ( [ ] ). Commas separate each value. </p>

			<p> Here are some array examples: [“one”, “two”, “three”] and [1, 2, 3], and ["one", 2,
				"three"]. </p>

		</section>

		<section>
			<title>Objects</title>
			<p> Objects consist of name-value pairs. The name must be a string, and the value can be
				any supported JSON data type. </p>
			<p> Objects are enclosed in curly braces ( { } ). Commas separate each pair. The colon (:)
				character separates the name from its value within each pair. </p>
			<p> Here are some object examples: {"age": 17}, {"fname": "Jane", "lname": "Doe"} </p>

			<p> All names must be strings and should be distinct from each other within that
				object.</p>
		</section>

		<section>
			<title>NULL</title>
			<p> Nulls represent empty values using the keyword NULL. For example, a developer might
				initially set a field value to null by default until a user enters a value. </p>

			<p>Null values are also generated by certain operations, for example, when dividing by zero
				or passing arguments of the wrong type. </p>

			<p> Note that NULL is case insensitive. For example, null, NULL, Null, and nUll are all
				equivalent. </p>
		</section>

		<section>
			<title>MISSING</title>
			<p>Missing represents a missing name-value pair in a JSON document. If the referenced field
				does not exist, an empty result value is returned by the query. Missing is added as a
				literal expression, although it is not returned in the final results. It is omitted from
				objects, and is converted to null in result arrays. </p>
			<p>Because N1QL is not constrained by a fixed schema, some objects and documents can
				contain fields that others do not contain; so a field can be present in one document and
				MISSING in another. (MISSING is not present in SQL, because every record in a table
				follows an identical schema.) </p>
		</section>

		<section>
			<title>Collation</title>
			<p> Collation defines the sort order for data types. Here is the collation order used for N1QL data types: </p>
			<ul>
				<li>MISSING</li>
				<li>NULL</li>
				<li>Boolean</li>
				<li>number</li>
				<li>string</li>
				<li>array</li>
				<li>object</li>
				<li>binary (non-JSON)</li>
			</ul>
		</section>

		<section>
			<title>Date</title>
			<p>N1QL does not support the Date data type; however N1QL does provide a full range of functions which you can use to manipulate dates. See <xref href="datefun.dita"></xref> for more information.</p>

		</section>
		
		<section><title>Binary</title>
			<p>When Couchbase Server is used as a key-value store and the value is a non-JSON value, the value is exposed as binary. N1QL does not parse the binary data. The returned value only signifies that the value is a binary value. For example, "<systemoutput>\u003cbinary (<varname>size_in_bytes</varname> b)\u003e</systemoutput>", where <varname>size_in_bytes</varname> signifies the size of the binary data in bytes. You can use the <apiname>TYPE()</apiname> function to retrieve the type of the value as binary. Functions that return metadata such as <apiname>META()</apiname> still operate as expected. However, operations on binary data are limited. </p>
		</section>

	</conbody>
</concept>
