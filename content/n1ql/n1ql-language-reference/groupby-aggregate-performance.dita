<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="groupby-aggregate-performance">
    <title>Group By and Aggregate Performance</title>
    <shortdesc>N1QL Pushdowns optimize the performance of N1QL queries by supporting GROUP BY and
        Aggregate expressions.</shortdesc>
    <body>
        <p><i>(Introduced in Couchbase Server 5.5 - Enterprise Edition)</i></p>
        <section id="Overview">
            <title>Overview</title>
            <p>This features improves performance of N1QL queries with aggregations and GROUP BY
                execution. </p>
            <p>After the optimizer selects an index for a query block, it attempts the two
                optimizations below:<ul id="ul_pkn_zcq_xcb">
                    <li>Pagination optimization, by pushing the OFFSET and LIMIT parameters to the
                        index scan.</li>
                    <li>Grouping and aggregation pushdown to the indexer (introduced in Couchbase
                        5.5).</li>
                </ul>Prior to Couchbase 5.5, even when a query with aggregate and/or GROUP BY is
                covered by an index, the query fetched all relevant data from the indexer and group
                the data within the query engine. With this enhancement, the query intelligently
                requests the indexer to perform grouping and aggregation in addition to range scan.
                The Indexer has been enhanced to perform grouping, COUNT(), SUM(), MIN(), MAX(),
                AVG(), and related operations.</p>
            <p>This requires no changes to the user query, but a good index design to cover the
                query and order the keys is required. Not every query will benefit from this
                optimization, and not every index can accelerate every grouping and aggregation.
                Understanding the right patterns will help you to design your indexes and queries.
                Aggregate Pushdown to the global secondary index is supported on both storage
                engines: Standard GSI and Memory Optimized GSI (MOI).</p>
            <p>This reduction step of performing the GROUP BY and Aggregation on the indexer reduces
                the amount of data transfer and disk I/O, resulting in:<ul id="ul_cnz_fdq_xcb">
                    <li>Improved query response time</li>
                    <li>Improved resource utilization</li>
                    <li>Low latency</li>
                    <li>High scalability</li>
                    <li>Low TCO</li>
                </ul>For example, let's compare the previous vs. current performance of using GROUP
                BY and examine the EXPLAIN plan of the following query that is defined in the
                Couchbase <codeph>travel-sample</codeph>
                index:<codeblock>CREATE INDEX `def_type` ON `travel-sample`(`type`) </codeblock>Consider
                the
                query:<codeblock id="codeblocktst">SELECT type, COUNT(type)
FROM `travel-sample`
WHERE type IS NOT MISSING
GROUP BY type;</codeblock>Before
                Couchbase version 5.5, this query engine fetched relevant data from the indexer and
                group the data within the query engine and then aggregate. This simple query takes
                about 250 ms.</p>
            <p><image href="images/GBAP_Ex0_QP_before55.png" id="image_lnh_v4q_xcb"/></p>
            <p>Now, in Couchbase version 5.5, this query use the same <codeph>def_type</codeph>
                index, but executes in under 70 ms. In the explain below, you can see fewer steps
                and the lack of the grouping step after the index scan because the index scan step
                does the grouping and aggregation as well.</p>
            <p><image href="images/GBAP_Ex0_QP_after55.png" id="image_bln_w4q_xcb" height="100"
                /></p>
            <p>As the data and query complexity grows, the performance benefit (both latency and
                throughput) will grow as well.</p>
            <p>For example, consider the
                query:<codeblock>SELECT type, COUNT(type)
FROM `travel-sample`
WHERE type IS NOT MISSING
GROUP BY type;</codeblock></p>
            <p>The text explain plan shows the accelerated aggregation details. For details, see the
                    <xref href="#groupby-aggregate-performance/section_bpf_wjf_ycb" format="dita"
                    >Query Plan Fields</xref>
                section.<codeblock>...
        "index_group_aggs": {
          "aggregates": [
            {
              "aggregate": "COUNT",
              "expr": "1",
              "id": 2,
              "keypos": -1
            }
          ],
          "depends": [
            0
          ],
          "group": [
            {
              "depends": [
                0
              ],
              "expr": "cover ((`travel-sample`.`type`))",
              "id": 0,
              "keypos": 0
            }
          ]
        },
        "index_id": "c5bbb792c69c1704",
        "index_projection": {
          "entry_keys": [
            0,
            2
          ]
        },
...</codeblock>Here’s
                is how this query executes when the indexer executes the GROUP BY and aggregation.
                The query engine does not fetch any data from the data service (KV service), as
                shown below:</p>
            <p><image href="images/GBAP_55execution.png" id="image_ngr_kzv_xcb" scale="70"
                    height="700" width="700"/></p>
            <p>For your reference, this is how the same query executed before 5.5.</p>
            <p><image href="images/GBAP_pre55execution.png" id="image_pbg_4zv_xcb" height="700"
                    width="700"/></p>
        </section>
        <section id="section_fw5_ypq_xcb"><title>Examples for Indexer GROUP BY and
        Aggregation</title><p><b>Example A:</b> Let’s Consider a composite index to explore some
        scenarios:<codeblock>CREATE INDEX idx_a ON `travel-sample` (geo.alt, geo.lat, geo.lon, id) WHERE type = "airport"</codeblock>Let’s
        consider sample queries that can benefit from this optimization and the queries that
        cannot.</p><p><b>Positive Case examples of queries that use indexing grouping and
          aggregation:</b><ul id="ul_fmx_sqq_xcb">
          <li><codeph>SELECT COUNT(*) FROM `travel-sample` WHERE geo.alt > 10 AND
              type="airport";</codeph></li>
          <li><codeph>SELECT COUNT(geo.alt) FROM `travel-sample` WHERE geo.alt BETWEEN 10 AND 30 AND
              type = "airport";</codeph></li>
          <li><codeph>SELECT COUNT(geo.lat) FROM `travel-sample` WHERE geo.alt BETWEEN 10 AND 30 AND
              geo.lat = 40 AND type = "airport";</codeph></li>
          <li><codeph>SELECT geo.alt, AVG(id), SUM(id), COUNT(geo.alt), MIN (geo.lon),
              MAX(ABS(geo.lon)) FROM `travel-sample` WHERE geo.alt > 100 AND type = "airport" GROUP
              BY geo.alt;</codeph></li>
          <li><codeph>SELECT lat_count, SUM(id) FROM `travel-sample` WHERE geo.alt > 100 AND type =
              "airport" GROUP BY geo.alt LETTING lat_count = COUNT(geo.lat) HAVING lat_count >
              1;</codeph></li>
          <li><codeph>SELECT AVG(DISTINCT geo.lat) FROM `travel-sample` WHERE geo.alt > 100 AND type
              = "airport" GROUP BY geo.alt;</codeph></li>
        </ul></p><p><b>Negative Case examples:</b><ul id="ul_p3p_drq_xcb">
          <li><codeph>SELECT COUNT(*) FROM `travel-sample` WHERE geo.lat > 20 AND type =
              "airport";</codeph><ul id="ul_syp_2rq_xcb">
              <li>This query has no predicate on the leading key <codeph>geo.alt</codeph>. The index
                  <codeph>idx_a</codeph> cannot be used.</li>
            </ul></li>
          <li><codeph>SELECT COUNT(*) FROM `travel-sample`;</codeph><ul id="ul_kc1_grq_xcb">
              <li>This query has no predicate at all.</li>
            </ul></li>
          <li><codeph>SELECT COUNT(v1) FROM `travel-sample` LET v1 = ROUND(geo.lat) WHERE geo.lat >
              10 AND type = "airport";</codeph><ul id="ul_mwm_hrq_xcb">
              <li>The aggregate depends on <codeph>LET</codeph> variable.</li>
            </ul></li>
          <li><codeph>SELECT ARRAY_AGG(geo.alt) FROM `travel-sample` WHERE geo.alt > 10 AND type =
              "airport";</codeph><ul id="ul_af2_jrq_xcb">
              <li><codeph>ARRAY_AGG</codeph> is not supported.</li>
            </ul></li>
        </ul></p><p><b>Positive query examples with GROUP BY on leading index
          keys</b></p><p><b>Example B:</b> Consider the following
        index:<codeblock>CREATE INDEX idx_b ON `travel-sample`(geo.alt, geo.lat, geo.lon, id)</codeblock>In
        the following query, the GROUP BY keys<codeph> (geo.alt, geo.lat) </codeph>are the leading
        keys of the index, so the index is naturally ordered and grouped by the order of the index
        key definition. Therefore, the query below is suitable for indexer to handle grouping and
        aggregation.<codeblock>SELECT geo.alt, geo.lat, SUM(geo.lon), AVG(id), COUNT(DISTINCT geo.lon)
FROM `travel-sample`
WHERE geo.alt BETWEEN 10 AND 30
AND type = "airport" 
GROUP BY geo.alt, geo.lat
HAVING SUM(geo.lon) > 1000;</codeblock>Here's
        the executed query plan showing that index scan handled grouping and aggregation:</p><image
        href="images/GBAP_ExB_Plan.png" id="image_lhl_5xy_jdb" scale="70"/><p><b
          id="docs-internal-guid-c3d7738b-b0d1-f78b-9de2-09a4baf058a5">Positive query examples with
          GROUP BY on non-leading index keys</b></p><p><b>Example C:</b> Consider the following
        index and
        query:<codeblock>CREATE INDEX idx_c ON `travel-sample`(geo.alt, geo.lat, geo.lon, id)
 WHERE type = "airport"

SELECT geo.lat, id, SUM(geo.lon)
FROM `travel-sample`
WHERE geo.alt BETWEEN 10 AND 30
AND type = "airport" 
GROUP BY geo.lat, id
HAVING SUM(geo.lon) > 1000;</codeblock>The
        following is a bottom-up rendering of the execution plan for easier viewing. In this case,
        the indexer sends partial group aggregation, which the query merges to create the final
        group and aggregation. In this scenario (when the grouping is on non-leading keys), any
        query with aggregation and DISTINCT modifier cannot be accelerated by the indexer, such as
          <codeph>COUNT(DISTINCT id)</codeph>.</p><p><image href="images/GBAP_ExC_Plan.png"
          id="image_fjx_cyy_jdb" scale="50"/></p><p><b
          id="docs-internal-guid-4376996d-b457-baf4-35a7-55c27622ed76">Positive query examples on
          array indexes with GROUP BY on leading index keys</b></p><p><b>Example D:</b> Consider the
        following index and
        query:<codeblock>CREATE INDEX idx_d ON `travel-sample` (geo.lat, geo.lon, DISTINCT public_likes, id) WHERE type = "hotel"

SELECT geo.lat, geo.lon, SUM(id), AVG(id)
FROM `travel-sample`
WHERE geo.lat BETWEEN 10 AND 30  
 <b>AND geo.lon > 50</b>
 AND type = "hotel"
 AND ANY v IN public_likes SATISFIES  v = “%a%” END
GROUP BY geo.lat, geo.lon
HAVING SUM(id) > 100;</codeblock>In
        this case, the predicates are on the leading keys up to and including the array key.
        Therefore, indexer can efficiently do the grouping as seen by the optimal plan below. It’s
        important to note the array index key is created with a <codeph>DISTINCT</codeph> modifier
        (not the <codeph>ALL</codeph> modifier) to get this optimization and that the
          <codeph>SATISFIES</codeph> clause in the <codeph>ANY</codeph> predicate must be that of
        equality (that is, <codeph>v = “%a%”</codeph>).</p><image href="images/GBAP_ExD_Plan.png"
        id="image_p31_ryy_jdb" scale="70"/><p><b>Example D2:</b> On the other hand, if there’s a
        predicate missing on<codeph> geo.lon</codeph>--which is prior to the array key--while using
        the same<codeph> idx_d </codeph>index as above, then the grouping is done by the old
        method:<codeblock>SELECT geo.lat, geo.lon, SUM(id), AVG(id)
FROM `travel-sample`
WHERE geo.lat BETWEEN 10 AND 30  
 AND type = "hotel"
 AND ANY v IN public_likes SATISFIES  v = “%a%” END
GROUP BY geo.lat, geo.lon
HAVING SUM(id) > 100;</codeblock></p><image
        href="images/GBAP_ExD2_Plan.png" id="image_shx_czy_jdb"/><p><b>Example E:</b> Consider the
        index and
        query:<codeblock>CREATE INDEX idx_e ON `travel-sample` (ALL public_likes, geo.lat, geo.lon, id) WHERE type = "hotel"

SELECT un, t.geo.lat, COUNT(un), AVG(t.geo.lat)
FROM `travel-sample` AS t
 UNNEST t.public_likes AS un
WHERE un > "J"
AND t.type = "hotel"
GROUP BY un, t.geo.lat;</codeblock>In
        this case, the <codeph>UNNEST</codeph> operation can use the index because the leading
          <codeph>ALL</codeph> array key is the array being unwound. Note, the unwound operation
        repeats the parent document (<codeph>travel-sample</codeph>) and the
          <codeph>t.geo.lat</codeph> reference would have duplicates compared to the original
          <codeph>travel-sample</codeph> documents.</p><p><image href="images/GBAP_ExE_Plan.png"
          id="image_dkl_w1z_jdb" scale="50"/></p></section>
    <section id="section_nyj_2bz_jdb">
      <title>Query Qualification and Pushdown</title>
      <p>Not every GROUP BY and aggregate query can be handled by the indexer. Following are some
        simple rules that will help you to write the proper queries and design the required indexes
        to get the most of this feature.</p>
      <p>The following are necessary in order for an indexer to execute GROUP BY and aggregates:<ul
          id="ul_rm2_xdw_xcb">
          <li>All the query predicates are able to convert into ranges and able to push to
            indexer.</li>
          <li>The whole query must be covered by an index.<ul id="ul_epn_ydw_xcb">
              <li>For a query to be covered by an index, every attribute referenced in the query
                should be in one index.</li>
              <li>Query should not have operations such as joins, subquery, or derived table
                queries.</li>
            </ul></li>
          <li>GROUP BY keys and Aggregate expressions must be one of the following:<ul
              id="ul_mtn_12w_xcb">
              <li>Index keys or document key</li>
              <li>An expression based on index keys or document key</li>
            </ul></li>
          <li>GROUP BY and aggregate expressions must be simple.</li>
        </ul></p>
    </section>
        <section id="section_khk_52w_xcb">
            <title>Scenarios for Group By and Aggregation</title>
            <p>Like any feature in a query language, there are subtle variations between each query
                and index that affects this optimization. We use the <codeph>travel-sample</codeph>
                dataset to illustrate both positive and negative use cases.</p>
            <p>The following table lists the scenarios and requirements for queries to request the
                indexer to do the grouping and acceleration. When the requirements are unmet, the
                query will fetch the relevant data and then do the grouping and acceleration as
                usual. No application changes are necessary. The query plan generated reflects this
                decision.</p>
            <p>
                <dl>
                    <dlentry>
                        <dt>GROUP BY Scenarios:</dt>
                        <dd>1. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-44fa3035-b9c8-1706-a73e-b0f1c03d91da"
                                format="dita">GROUP BY on leading keys</xref></dd>
                        <dd>2. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-b944b625-b4b7-85b3-0987-2afeb4f88289"
                                format="dita">GROUP BY on non-leading keys</xref></dd>
                        <dd>3. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-3e3d5b1a-b5b6-ef35-da76-906170103e59"
                                format="dita">GROUP BY keys in different CREATE INDEX
                            order</xref></dd>
                        <dd>4. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-9640b8bb-b679-d376-cf13-9a0dd1211391"
                                format="dita">GROUP BY on expression</xref></dd>
                        <dd>5. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-29f284c7-ba1c-b38b-97a7-1a2d9a3d998b"
                                format="dita">Heterogeneous data types for GROUP BY key</xref></dd>
                        <dd>6. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-e3f2aba4-ba21-bda0-6921-b83d1b3a30fa"
                                format="dita">GROUP BY META().id Primary Index</xref></dd>
                        <dd>7. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-67306400-ba24-c55f-4713-86943530e62c"
                                format="dita">LIMIT with GROUP BY on leading keys</xref></dd>
                        <dd>8. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-82a268f5-ba2b-e5a4-7785-827a5d72d1d1"
                                format="dita">OFFSET with GROUP BY on leading keys</xref></dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Aggregate Scenarios:</dt>
                        <dd>9. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-62fed86e-ba30-23d8-b1eb-ec7749f8b015"
                                format="dita">Aggregate without GROUP BY</xref></dd>
                        <dd>10. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-af7d26f3-ba4e-e380-4deb-14da7f213d50"
                                format="dita">Expression in aggregate function</xref></dd>
                        <dd>11. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-c2a14520-ba57-2a9f-b0b1-4688448cadcb"
                                format="dita">SUM, COUNT, MIN, MAX, or AVG Aggregate
                            function</xref></dd>
                        <dd>12. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-a09e0778-ba63-b476-8b94-010a6fa15ca8"
                                format="dita">DISTINCT aggregates</xref></dd>
                        <dd>13. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-9773d2db-ba85-f585-ea05-595abd843c10"
                                format="dita">HAVING with an aggregate function inside</xref></dd>
                        <dd>14. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-19518afc-ba8a-3f81-650a-f64236d62a51"
                                format="dita">LETTING with an aggregate function inside</xref></dd>
                    </dlentry>
                </dl>
              <!--
                <dl>
                    <dlentry>
                        <dt>Aggregate on Array Index Scenarios:</dt>
                        <dd>15. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-f14f9e5d-ba8d-b654-70f2-27f204564ae0"
                                format="dita">Aggregate on non-array index field</xref></dd>
                        <dd>16. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-6b830f6f-babe-926c-480c-d3ddd586babc"
                                format="dita">Aggregate on array index field</xref></dd>
                        <dd>17. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-c6e690e3-bada-1180-5846-bd30e534ac57"
                                format="dita">DISTINCT Aggregate on non-array index
                            field</xref></dd>
                        <dd>18. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-3d16d747-baee-8dc9-5248-bcf386260db4"
                                format="dita">DISTINCT Aggregate on array index field</xref></dd>
                        <dd>19. <xref
                                href="#groupby-aggregate-performance/docs-internal-guid-6af647a9-baf9-d11a-f512-01f0fdc2c587"
                                format="dita">Array of arrays</xref></dd>
                    </dlentry>
                </dl>
              -->
            </p>
            <p><b id="docs-internal-guid-44fa3035-b9c8-1706-a73e-b0f1c03d91da">1. GROUP BY on
                    leading keys</b></p>
            <p>One of the common cases is to have both predicates and GROUP BY on leading keys of
                the index. First create the index so that the query is covered by the index. You can
                then think about the order of the keys.</p>
            <p>The query requires a predicate on leading keys to consider an index. The simplest
                predicate is <codeph>IS NOT MISSING</codeph>.
                    <codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>Keyspace_ref</varname> (<b><i>a</i></b>, b, c);

SELECT <b>a, b</b>, <varname>Aggregate_Function</varname>(c)  /* MIN(c), MAX(c), COUNT(c), or SUM(c) */
FROM <varname>Keyspace_ref</varname>
WHERE <b><i>a</i></b> IS NOT MISSING              /* 1st <b><i>index</i></b> field must be in a WHERE clause */
GROUP BY <b>a, b</b>;</codeblock><b>Example
                    1:</b> List the cities with the landmarks with the highest latitude.</p>
            <p>Use the <codeph>MAX()</codeph> aggregate to find the highest landmark latitude in
                each state, group the results by <codeph>country</codeph> and
                <codeph>state</codeph>, and then sort in reverse order by the highest latitudes per
                    <codeph>state</codeph>.<codeblock>CREATE INDEX idx1 ON `travel-sample`(country, state, geo.lat) 
WHERE type="landmark";

SELECT country, state, MAX(ROUND(geo.lat)) AS Max_Latitude
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "landmark"
GROUP BY country, state
ORDER BY Max_Latitude DESC;</codeblock>In
                this query, we need to give the predicate<codeph> country IS NOT MISSING
                </codeph>(or any WHERE clause) to ensure this index is selected for the query.
                Without a matching predicate, the query will use the primary index.</p>
            <p>Results:<codeblock>[
  {
    "Max_Latitude": 60,
    "country": "United Kingdom",
    "state": null
  },
  {
    "Max_Latitude": 51,
    "country": "United Kingdom",
    "state": "England"
  },
  {
    "Max_Latitude": 50,
    "country": "France",
    "state": "Picardie"
  },
...</codeblock>The
                Example 1 EXPLAIN Plan shows that <codeph>GROUP BY</codeph> is executed by the
                indexer and is detailed in the <xref
                    href="#groupby-aggregate-performance/table_bw2_nrf_ycb" format="dita">GROUP BY
                    Query Plan
                table</xref>:<codeblock>{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
<b>            "#operator": "IndexScan3",</b>
            "covers": [
              "cover ((`travel-sample`.`country`))",
              "cover ((`travel-sample`.`state`))",
              "cover (((`travel-sample`.`geo`).`lat`))",
              "cover ((meta(`travel-sample`).`id`))",
              "cover (count(cover ((`travel-sample`.`country`))))",
              "cover (min(round(cover (((`travel-sample`.`geo`).`lat`)))))"
            ],
            "filter_covers": {
              "cover ((`travel-sample`.`type`))": "landmark"
            },
<b>            "index": "idx1",</b>
            "index_group_aggs": {
              "aggregates": [
                {
                  "aggregate": "MAX",
                  "depends": [
                    2
                  ],
                  "expr": "round(cover (((`travel-sample`.`geo`).`lat`)))",
                  "id": 4,
                  "keypos": -1 
                }
              ],
              "depends": [
                0,
                1,
                2
              ],
              "group": [
                {
                  "depends": [
                    0
                  ],
                  "expr": "cover ((`travel-sample`.`country`))",
                  "id": 0,
                  "keypos": 0
                },
                {
                  "depends": [
                    1
                  ],
                  "expr": "cover ((`travel-sample`.`state`))",
                  "id": 1,
                  "keypos": 1
                }
              ]
            },
...</codeblock></p>
            <p><b id="docs-internal-guid-b944b625-b4b7-85b3-0987-2afeb4f88289">2. GROUP BY on
                    non-leading keys</b></p>
            <p>When using GROUP BY on a non-leading key:<ul id="ul_c1d_5nw_xcb">
                    <li>The indexer will return <i>pre-aggregated</i> results.</li>
                    <li>Results can have duplicate or out-of-order groups. The N1QL indexer will do
                        2nd level of aggregation and compute the final result.</li>
                    <li>The N1QL indexer can pushdown only if the leading key has a predicate.</li>
                </ul>To use Aggregate Pushdown, use the following syntax of the index and query
                    statements:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>Keyspace_ref</varname> (<i>a, <b>b, c</b></i>);</codeblock><b>Syntax
                    A:</b><codeblock>SELECT <varname>Aggregate_Function</varname>(<varname>a</varname>), <b><i>b</i></b>, A<varname>ggregate_Function</varname>(<b><i>c</i></b>) 
FROM <varname>Keyspace_ref</varname>
WHERE <varname>a</varname> IS NOT MISSING
GROUP BY <i><b>b</b></i>;</codeblock><b>Syntax
                    B:</b><codeblock>SELECT <varname>Aggregate_Function</varname>(a), <varname>Aggregate_Function</varname>(<b><i>b</i></b>), <b><i>c</i></b> 
FROM <varname>Keyspace_ref</varname>
WHERE <varname>a</varname> IS NOT MISSING
GROUP BY <b><i>c</i></b>;</codeblock><b>Example
                    2 (A):</b> List the states with their total number of landmarks and the lowest
                latitude of any landmark.</p>
            <p>Use the <codeph>COUNT()</codeph> operator to find the total number of landmarks and
                use the <codeph>MIN()</codeph> operator to find the lowest landmark latitude in each
                state, group the results by <codeph>state</codeph>, and then sort in order by the
                lowest latitudes per
                <codeph>state</codeph>.<codeblock>CREATE INDEX idx2 ON `travel-sample`(country, state, ROUND(geo.lat)) 
WHERE type="landmark";

SELECT COUNT(country) AS Total_landmarks, <b>state, MIN(ROUND(geo.lat)) AS Min_Latitude</b>
FROM `travel-sample`
WHERE country IN ["France", "United States", "United Kingdom"]
AND type = "landmark"
GROUP BY state
ORDER BY Min_Latitude;</codeblock>Explain
                Plan:</p>
            <p><image href="images/GBAP_Ex2A_EP.png" id="image_l3d_gvx_xcb"
                    /><codeblock>{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
            "#operator": "IndexScan3",
            "covers": [
              "cover ((`travel-sample`.`country`))",
              "cover ((`travel-sample`.`state`))",
              "cover (((`travel-sample`.`geo`).`lat`))",
              "cover ((meta(`travel-sample`).`id`))",
              "cover (count(cover ((`travel-sample`.`country`))))",
              "cover (min(round(cover (((`travel-sample`.`geo`).`lat`)))))"
            ],
            "filter_covers": {
              "cover ((`travel-sample`.`type`))": "landmark"
            },
            "index": "idx2",
            "index_group_aggs": {
             <b> "aggregates": [
                {
                  "aggregate": "COUNT",
                  "depends": [
                    0
                  ],
                  "expr": "cover ((`travel-sample`.`country`))",
                  "id": 4,
                  "keypos": 0
                },
                {
                  "aggregate": "MIN",
                  "depends": [
                    2
                  ],
                  "expr": "round(cover (((`travel-sample`.`geo`).`lat`)))",
                  "id": 5,
                  "keypos": -1</b>
                }
              ],
              "depends": [
                0,
                1,
                2
              ],
             <b> "group": [
                {
                  "depends": [
                    1
                  ],
                  "expr": "cover ((`travel-sample`.`state`))",
                  "id": 1,
                  "keypos": 1</b>
                }
              ],
             <b> "partial": true</b>
            },
...</codeblock><note>The
                        <codeph>"partial": true</codeph> line means it was
                    pre-aggregated.</note>Results:<codeblock>[
  {
    "Min_Latitude": 33,
    "Total_landmarks": 1900,
    "state": "California"
  },
  {
    "Min_Latitude": 41,
    "Total_landmarks": 8,
    "state": "Corse"
  },
  {
    "Min_Latitude": 43,
    "Total_landmarks": 6,
    "state": "Languedoc-Roussillon"
  },
...</codeblock><b>Example
                    2 (B):</b> List the number of landmarks by latitude and the state it's in.</p>
            <p>Use <codeph>COUNT(country)</codeph> for the total number of landmarks at each
                latitude. At a particular latitude, the <codeph>state</codeph> will be the same; but
                an aggregate function on it is needed, so <codeph>MIN()</codeph> or
                    <codeph>MAX()</codeph> is used to return the original
                    value.<codeblock>SELECT COUNT(country) Num_Landmarks, MIN(state) State_Name, ROUND(geo.lat) Latitude
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "landmark"
GROUP BY ROUND(geo.lat)
ORDER BY ROUND(geo.lat);</codeblock>Results:<codeblock>[
  {
    "Latitude": 33,
    "Num_Landmarks": 227,
    "State_Name": "California"
  },
  {
    "Latitude": 34,
    "Num_Landmarks": 608,
    "State_Name": "California"
  },
  {
    "Latitude": 35,
    "Num_Landmarks": 27,
    "State_Name": "California"
  },
...</codeblock><b
                    id="docs-internal-guid-3e3d5b1a-b5b6-ef35-da76-906170103e59">3. GROUP BY keys in
                    different CREATE INDEX order</b></p>
            <p>When using GROUP BY on keys in a different order than they appear in the CREATE INDEX
                statement, use the following
                    syntax:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>Keyspace_ref</varname>(<i>a, b, c</i>);

SELECT <varname>Aggregate_Function</varname>(<b><i>c</i></b>) 
FROM <varname>Keyspace_ref</varname>
WHERE <varname>a</varname> IS NOT MISSING
GROUP BY <i><b>b, a</b></i>;</codeblock><b>Example
                    3:</b> Like Example 1 with the GROUP BY fields swapped, list the landmarks with
                the lowest longitude.</p>
            <p>Use the <codeph>MIN()</codeph> operator to find the lowest landmark longitude in each
                city, group the results by <codeph>activity</codeph> and <codeph>city</codeph>, and
                then sort in reverse order by the lowest longitudes per
                    <codeph>activity</codeph>.<codeblock>CREATE INDEX idx3 ON `travel-sample`(activity, city, geo.lon) 
WHERE type="landmark";

SELECT activity, city, MIN(ROUND(geo.lon)) AS Max_Longitude
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "landmark"
GROUP BY activity, city
ORDER BY Min_Longitude;</codeblock>Results:<codeblock>[
  {
    "Min_Longitude": -124,
    "activity": "buy",
    "city": "Eureka"
  },
  {
    "Min_Longitude": -123,
    "activity": "drink",
    "city": "Glen Ellen"
  },
  {
    "Min_Longitude": -123,
    "activity": "do",
    "city": "Santa Rosa"
  },
  {
    "Min_Longitude": -123,
    "activity": "eat",
    "city": "Moss Beach"
  },
...</codeblock><b
                    id="docs-internal-guid-9640b8bb-b679-d376-cf13-9a0dd1211391">4. GROUP BY on
                    expression</b></p>
            <p>When grouping on an expression or operation, the indexer will return pre-aggregated
                results whenever the GROUP BY and leading index keys are not an exact match.</p>
            <p>To use Aggregate Pushdown and avoid pre-aggregated results, use one of the two
                following syntaxes of the index and query statements:</p>
            <p><b>Syntax A: Field with an expression</b> (GROUP BY and Index keys
                    match)<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>Keyspace_ref</varname>(<i><b>a+b</b>, b, c</i>);

SELECT <varname>Aggregate_Function</varname>(<varname>c</varname>) 
FROM <varname>Keyspace_ref</varname>
WHERE a IS NOT MISSING
GROUP BY <i><b>a+b</b></i>;</codeblock><b>Syntax
                    B: Operation on a field </b>(GROUP BY and Index keys
                match)<codeblock>CREATE INDEX <varname>idx_operation</varname> ON <varname>Keyspace_ref</varname> (<i><b>LOWER(a)</b>, b, c</i>);

SELECT <varname>Aggregate_Function</varname>(<i>c</i>) 
FROM <varname>Keyspace_ref</varname>
WHERE <varname>a</varname> IS NOT MISSING
GROUP BY <i><b>LOWER(a)</b></i>;</codeblock>For
                comparison, the below index and query combination will yield pre-aggregated
                results.</p>
            <p><b>Pre-aggregated Syntax: </b>The GROUP BY and Index keys don't
                    match.<codeblock>CREATE INDEX <varname>idx_operation</varname> ON <varname>Keyspace_ref</varname> (<i><b>a</b>, b, c</i>);

SELECT <varname>Aggregate_Function</varname>(<varname>c</varname>) 
FROM <varname>Keyspace_ref</varname>
WHERE <varname>a</varname> IS NOT MISSING
GROUP BY <i><b>UPPER(a)</b></i>;</codeblock><b>Example
                    4 (A): </b>A field with an expression.</p>
            <p>Let's say the distance of a flight feels like "nothing" when it's direct, but feels
                like the true distance when there is one layover. Then we can list and group by
                flight distances by calculating the distance multiplied by the stops it
                makes.<codeblock>CREATE INDEX idx4_expr 
ON `travel-sample`(ROUND(distance*stops), ROUND(distance), sourceairport)
WHERE type="route";

SELECT <b>ROUND(distance*stops)</b> AS Distance_Feels_Like, 
       MAX(ROUND(distance)) AS Distance_True, 
       COUNT(sourceairport) Number_of_Airports
FROM `travel-sample`
WHERE ROUND(distance*stops) IS NOT MISSING
AND type = "route"
<b>GROUP BY ROUND(distance*stops)</b>;</codeblock>Query
                Plan:</p>
            <p><image href="images/GBAP_Ex4A_VP.png" id="image_kp1_yxd_ycb" scale="50"
                    /><codeblock>...
        "index_group_aggs": {
          "aggregates": [
            {
              "aggregate": "COUNT",
              "depends": [
                2
              ],
             <b> "expr": "cover ((`travel-sample`.`sourceairport`))",
              "id": 4,
              "keypos": 2</b>
            },
            {
              "aggregate": "MAX",
              "depends": [
                1
              ],
             <b> "expr": "cover (round((`travel-sample`.`distance`)))",
              "id": 5,
              "keypos": 1</b>
            }
          ],
          "depends": [
            0,
            1,
            2
          ],
          "group": [
            {
              "depends": [
                0
              ],
            <b>  "expr": "cover (round(((`travel-sample`.`distance`) * (`travel-sample`.`stops`))))",
              "id": 0,
              "keypos": 0</b>
            }
          ]
...</codeblock>Results:<codeblock>[
  {
    "Distance_Feels_Like": 1055,
    "Distance_True": 1055,
    "Number_of_Airports": 1
  },
  {
    "Distance_Feels_Like": 1806,
    "Distance_True": 1806,
    "Number_of_Airports": 2
  },
  {
    "Distance_Feels_Like": 0,
    "Distance_True": 13808,
    "Number_of_Airports": 24018
  },
...</codeblock><b>Example
                    4 (B): An operation on a field.</b></p>
            <p>Let's say the distance of a flight feels like "nothing" when it's direct, but feels
                like the true distance when there is one layover. Then we can list and group by the
                uppercase of the airport codes and listing the flight distances by calculating the
                distance multiplied by the stops it makes along with the total
                    distance.<codeblock>CREATE INDEX idx4_oper 
ON `travel-sample`(sourceairport, ROUND(distance*stops), distance)
WHERE type="route";

SELECT <b>UPPER</b>(sourceairport) AS Airport_Code, 
       MIN(ROUND(distance*stops)) AS Distance_Feels_Like, 
       SUM(ROUND(distance)) AS Total_Distance 
FROM `travel-sample`
WHERE sourceairport IS NOT MISSING
AND type = "route"
GROUP BY <b>UPPER</b>(sourceairport);</codeblock>Results:<codeblock>[
  {
    "Airport_Code": "ESU",
    "Distance_Feels_Like": 0,
    "Total_Distance": 6223
  },
  {
    "Airport_Code": "QSF",
    "Distance_Feels_Like": 0,
    "Total_Distance": 3285
  },
  {
    "Airport_Code": "LHW",
    "Distance_Feels_Like": 0,
    "Total_Distance": 13837
  },
...</codeblock><b
                    id="docs-internal-guid-29f284c7-ba1c-b38b-97a7-1a2d9a3d998b">5. Heterogeneous
                    data types for GROUP BY key</b></p>
            <p>When a field has a mix of data types for the GROUP BY key:<ul id="ul_ztr_5d2_ycb">
          <li><codeph>NULLS</codeph> and <codeph>MISSING</codeph> are two separate groups.</li>
        </ul><b>Example 5</b>:</p>
      <p>To see a separate grouping of <codeph>MISSING</codeph> and <codeph>NULL</codeph>, we need
        to <codeph>GROUP BY</codeph> a field we know exists in one document but not in another
        document while both documents have another field in common. For example, create 3 such
        documents:<codeblock>INSERT INTO `travel-sample` VALUES("01",{"<b>type</b>":1, "email":"abc","<b>xx</b>":<b>3</b>});

INSERT INTO `travel-sample` VALUES("01",{"<b>type</b>":1, "email":"abc","<b>xx</b>":<b>null</b>});

INSERT INTO `travel-sample` VALUES("02",{"<b>type</b>":1, "email":"abcd"});</codeblock>Then
        run the following
          query:<codeblock>SELECT type, <b>xx</b>, MIN(email) AS Min_Email
FROM `travel-sample`
WHERE type IS NOT NULL
GROUP BY type, <b>xx</b>;</codeblock>Results:<codeblock>[
  {
    "Min_Email": "abc",
    "<b>type": 1</b>,
    "<b>xx": 3</b>
  },
  {
    "Min_Email": "abc",
    "<b>type": 1</b>,
    "<b>xx": null</b>
  },
  {
    "Min_Email": "abcd",
    "<b>type": 1</b>              &lt;-- is a separate result since field "xx" is MISSING
  },
  {
    "Min_Email": null,
    "type": "airline"
  },
...</codeblock><b
          id="docs-internal-guid-e3f2aba4-ba21-bda0-6921-b83d1b3a30fa">6. GROUP BY META().ID Primary
          Index</b></p>
            <p>If there is no filter, then pushdown is supported for an expression on the Document
                ID <codeph>META().id</codeph> in the <codeph>GROUP BY</codeph> clause.</p>
            <p>To use Aggregate Pushdown, use the following example of the index and query
          statement:<codeblock>CREATE PRIMARY INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname>;

SELECT COUNT(1)
FROM <varname>named_keyspace_ref</varname>
GROUP BY SUBSTR(META().id, 0, 10);</codeblock><note>If
          there is a filter on the Document ID, then the primary index can be used as a secondary
          scan.</note><b>Example 6:</b> List the number of countries that are in each decile of the
          <codeph>META().id</codeph>
          field.<codeblock>CREATE PRIMARY INDEX idx6 ON `travel-sample`;

SELECT COUNT(1) AS Cnt, SUBSTR(META().id,0,9) AS Meta_Group
FROM `travel-sample`
GROUP BY SUBSTR(META().id,0,9);</codeblock>Results:<codeblock>[
  {
    "Meta_Group": "airport_9",
    "Number_of_Country": 121
  },
  {
    "Meta_Group": "airport_1",
    "Number_of_Country": 187
  },
  {
    "Meta_Group": "airport_3",
    "Number_of_Country": 482
  },
...</codeblock><b
          id="docs-internal-guid-67306400-ba24-c55f-4713-86943530e62c">7. LIMIT with GROUP BY on
          leading keys</b></p>
            <p>To use Aggregate Pushdown when there is a LIMIT clause and a GROUP BY clause on one
        or more leading keys, use the following example of the index and query
          statement:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>k0, k1</varname>);     

SELECT <varname>k0</varname>, COUNT(<varname>k1</varname>) 
FROM <varname>named_keyspace_ref</varname>
WHERE <varname>k0</varname> IS NOT MISSING
GROUP BY <varname>k0</varname>
LIMIT <varname>n</varname>;</codeblock><b>Example
          7:</b> LIMIT with GROUP BY on the leading
        key.<codeblock>CREATE INDEX idx7 ON `travel-sample` (<b>city</b>, name) 
WHERE type = "landmark";

SELECT city AS City, COUNT(DISTINCT name) AS Landmark_Count 
FROM `travel-sample`
WHERE city IS NOT MISSING
AND type = "landmark"
GROUP BY <b>city</b>
<b>LIMIT 4;</b></codeblock>Explain
          Plan:<codeblock>{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
        <b>    "#operator": "IndexScan3",</b>
            "covers": [
              "cover ((`travel-sample`.`city`))",
              "cover ((`travel-sample`.`name`))",
              "cover ((meta(`travel-sample`).`id`))",
              "cover (count(distinct cover ((`travel-sample`.`name`))))"
            ],
            "filter_covers": {
              "cover ((`travel-sample`.`type`))": "landmark"
            },
         <b>   "index": "idx7",
            "index_group_aggs": {</b>
              "aggregates": [
                {
                  "aggregate": "COUNT",
                  "depends": [
                    1
                  ],
                  "distinct": true,
                  "expr": "cover ((`travel-sample`.`name`))",
                  "id": 3,
                  "keypos": 1
                }
              ],
              "depends": [
                0,
                1
              ],
              "group": [
                {
                  "depends": [
                    0
                  ],
                  "expr": "cover ((`travel-sample`.`city`))",
                  "id": 0,
                  "keypos": 0
                }
              ]
            },
            "index_id": "7852b5e2c07281f3",
            "index_projection": {
              "entry_keys": [
                0,
                3
              ]
            },
            "keyspace": "travel-sample",
        <b>    "limit": "4",</b>
            "namespace": "default",
...</codeblock><note>The
            <codeph>limit</codeph> is pushed to the indexer because the GROUP BY key matched with
          the leading index
          key.</note>Results:<codeblock>[
  {
    "City": null,
    "Landmark_Count": 15
  },
  {
    "City": "Abbeville",
    "Landmark_Count": 1
  },
  {
    "City": "Abbots Langley",
    "Landmark_Count": 19
  },
  {
    "City": "Aberdeenshire",
    "Landmark_Count": 6
  }
]</codeblock><b
          id="docs-internal-guid-82a268f5-ba2b-e5a4-7785-827a5d72d1d1">8. OFFSET with GROUP BY on
          leading keys</b></p>
            <p>To use Aggregate Pushdown when there is an OFFSET clause and a GROUP BY clause on one
        or more leading keys, use the following example of the index and query
          statement.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>k0</varname>, <varname>k1</varname>);     

SELECT <varname>k0</varname>, COUNT(k1) 
FROM <varname>named_keyspace_ref</varname>
WHERE <varname>k0</varname> IS NOT MISSING
GROUP BY <varname>k0</varname>
OFFSET <varname>n</varname>;</codeblock><b>Example
          8:</b> OFFSET with GROUP BY on a leading
        key.<codeblock>CREATE INDEX idx8 ON `travel-sample` (<b>city</b>, name) 
WHERE type = "landmark";

SELECT city AS City, COUNT(DISTINCT name) AS Landmark_Count 
FROM `travel-sample`
WHERE city IS NOT MISSING
AND type = "landmark"
GROUP BY <b>city</b>
<b>OFFSET 4;</b></codeblock>Explain
          Plan:<codeblock>{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
         <b>   "#operator": "IndexScan3",</b>
            "covers": [
              "cover ((`travel-sample`.`city`))",
              "cover ((`travel-sample`.`name`))",
              "cover ((meta(`travel-sample`).`id`))",
              "cover (count(distinct cover ((`travel-sample`.`name`))))"
            ],
            "filter_covers": {
              "cover ((`travel-sample`.`type`))": "landmark"
            },
            "index": "idx7",
            "index_group_aggs": {
              "aggregates": [
                {
                  "aggregate": "COUNT",
                  "depends": [
                    1
                  ],
                  "distinct": true,
                  "expr": "cover ((`travel-sample`.`name`))",
                  "id": 3,
                  "keypos": 1
                }
              ],
              "depends": [
                0,
                1
              ],
              "group": [
                {
                  "depends": [
                    0
                  ],
                  "expr": "cover ((`travel-sample`.`city`))",
                  "id": 0,
                  "keypos": 0
                }
              ]
            },
            "index_id": "7852b5e2c07281f3",
            "index_projection": {
              "entry_keys": [
                0,
                3
              ]
            },
            "keyspace": "travel-sample",
            "namespace": "default",
          <b>  "offset": "4",</b>
            "spans": [
...</codeblock><note>The
            <codeph>offset</codeph> is pushed to the indexer because the GROUP BY key matched with
          the leading index
          key.</note>Results:<codeblock>[
  {
    "City": "Aberdour",
    "Landmark_Count": 4
  },
  {
    "City": "Aberdulais",
    "Landmark_Count": 1
  },
  {
    "City": "Abereiddy",
    "Landmark_Count": 1
  },
  {
    "City": "Aberfeldy",
    "Landmark_Count": 2
  },
...</codeblock><b
          id="docs-internal-guid-62fed86e-ba30-23d8-b1eb-ec7749f8b015">9. Aggregate without GROUP BY
          key</b></p>
            <p>This is a case of aggregation over a range without groups. If the index can be used
                for computing the aggregate, the indexer will return a single aggregate value. To
                use Aggregate Pushdown, use the following syntax of index and
                    queries:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>a, b, c</varname>);

Q1: SELECT <varname>Aggregate_Function</varname>(<varname>c</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>a</varname> IS NOT MISSING;

Q2: SELECT SUM(<varname>a</varname>)
    FROM <varname>named_keyspace_ref</varname>
    WHERE <varname>a</varname> IS NOT MISSING;

Q3: SELECT SUM(<varname>a</varname>), COUNT(<varname>a</varname>), MIN(<varname>a</varname>)
    FROM <varname>named_keyspace_ref</varname>
    WHERE <varname>a</varname> IS NOT MISSING;

Q4: SELECT SUM(<varname>a</varname>), COUNT(<varname>b</varname>), MIN(<varname>c</varname>)
    FROM <varname>named_keyspace_ref</varname>
    WHERE <varname>a</varname> IS NOT MISSING;</codeblock><b>Example
                    9 (Q1):</b> Multiple Aggregate without GROUP BY
                    key.<codeblock>CREATE INDEX idx9 
ON `travel-sample`(ROUND(distance), stops, sourceairport) 
WHERE type = "airport";

Q1: SELECT SUM(ROUND(distance)) AS Total_Distance, 
           SUM(stops) AS Total_Stops, 
           COUNT(sourceairport) AS Total_Airports
    FROM `travel-sample`
    WHERE distance IS NOT MISSING
    AND type = "airport";</codeblock>Results:<codeblock>[
  {
    "Total_Airports": 24024,
    "Total_Distance": 53538071,
    "Total_Stops": 6
  }
]</codeblock><b>Example
                    9 (Q2):</b> Aggregate without GROUP BY
                    key.<codeblock>Q2: SELECT SUM(ROUND(distance)) AS Total_Distance
    FROM `travel-sample`;</codeblock>Results:<codeblock>[
  {
    "Total_Distance": 53538071
  }
]</codeblock><b>Example
                    9 (Q3):</b> Multiple Aggregate without GROUP BY
                    key.<codeblock>Q3: SELECT SUM(ROUND(distance)) AS Total_Distance,
           COUNT(ROUND(distance)) AS Count_of_Distance,
           MIN(ROUND(distance)) AS Min_of_Distance
    FROM `travel-sample`
    WHERE distance IS NOT MISSING;</codeblock>Results:<codeblock>[
  {
    "Count_of_Distance": 24024,
    "Min_of_Distance": 3,
    "Total_Distance": 53538071
  }
]</codeblock><b>Example
                    9 (Q4):</b> Multiple Aggregate without GROUP BY
                    key.<codeblock>Q4: SELECT SUM(ROUND(distance)) AS Total_Distance,
           COUNT(stops) AS Count_of_Stops,
           MIN(sourceairport) AS Min_of_Airport
    FROM `travel-sample`
    WHERE distance IS NOT MISSING;</codeblock>Results:<codeblock>[
  {
    "Count_of_Stops": 24024,
    "Min_of_Airport": "AAE",
    "Total_Distance": 53538071
  }
]</codeblock><b
                    id="docs-internal-guid-af7d26f3-ba4e-e380-4deb-14da7f213d50">10. Expression in
                    Aggregate function</b></p>
            <p>Aggregations with scalar expressions can be speeded up even if the index key does not
                have the matching expression on the key. To use Aggregate Pushdown, use the
                following syntax of the index and query
                    statement:<codeblock>CREATE INDEX idx_expr ON named_keyspace_ref (a,b,c);

SELECT Aggregate_Function1(Expression(c))
FROM named_keyspace_ref
WHERE a IS NOT MISSING
GROUP BY a,b;</codeblock><b
                    id="docs-internal-guid-be60f70b-ba52-b179-cd13-728a00e7c632">Example 10:</b>
                List the landmarks with the highest latitude.</p>
            <p>Use the <codeph>MAX()</codeph> operator to find the highest landmark latitude in each
                state, group the results by <codeph>country</codeph> and <codeph>state</codeph>, and
                then sort in reverse order by the highest
                latitudes.<codeblock>CREATE INDEX idx10 ON `travel-sample`(country, state, ABS(ROUND(geo.lat))) 
WHERE type="landmark";

SELECT country, state, SUM(ABS(ROUND(geo.lat))) AS SumAbs_Latitude
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "landmark"
GROUP BY country, state
ORDER BY SumAbs_Latitude DESC;</codeblock>The
                Example 10 Explain Plan shows that Aggregates are executed by the indexer and is
                detailed in the <xref
                    href="#groupby-aggregate-performance/docs-internal-guid-facfdbc0-bb3d-b00f-2ec0-6bee4921dabc"
                    format="dita">Aggregate Query Plan table</xref>:</p>
            <p><image href="images/GBAP_Ex10_VP.png" id="image_kj3_xl2_ycb" scale="70"
                    /><codeblock>{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
            "#operator": "IndexScan3",
            "covers": [
              "cover ((`travel-sample`.`country`))",
              "cover ((`travel-sample`.`state`))",
              "cover (abs(round(((`travel-sample`.`geo`).`lat`))))",
              "cover ((meta(`travel-sample`).`id`))",
              "cover (sum(cover (abs(round(((`travel-sample`.`geo`).`lat`))))))"
            ],
            "filter_covers": {
              "cover ((`travel-sample`.`type`))": "landmark"
            },
            "index": "idx10",
            "index_group_aggs": {
              "aggregates": [
                {
                  "aggregate": "SUM",
                  "depends": [
                    2
                  ],
                <b>  "expr": "cover (abs(round(((`travel-sample`.`geo`).`lat`))))",
                  "id": 4,
                  "keypos": 2</b>
                }
              ],
              "depends": [
                0,
                1,
                2
              ],
              "group": [
                {
                  "depends": [
                    0
                  ],
               <b>   "expr": "cover ((`travel-sample`.`country`))",
                  "id": 0,
                  "keypos": 0</b>
                },
                {
                  "depends": [
                    1
                  ],
               <b>   "expr": "cover ((`travel-sample`.`state`))",
                  "id": 1,
                  "keypos": 1</b>
                }
...</codeblock>Results:<codeblock>[
  {
    "SumAbs_Latitude": 117513,
    "country": "United Kingdom",
    "state": null
  },
  {
    "SumAbs_Latitude": 68503,
    "country": "United States",
    "state": "California"
  },
  {
    "SumAbs_Latitude": 10333,
    "country": "France",
    "state": "Île-de-France"
  },
...</codeblock><b
                    id="docs-internal-guid-c2a14520-ba57-2a9f-b0b1-4688448cadcb">11. SUM, COUNT,
                    MIN, MAX, or AVG Aggregate functions</b></p>
            <p>Currently, the only aggregate functions that are supported are SUM(), COUNT(), MIN(),
                MAX(), and AVG() with or without the DISTINCT modifier.</p>
            <p>To use Aggregate Pushdown, use the below syntax of the index and query
                    statement:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i>a,b,c,d</i>);

SELECT <varname>Aggregate_Function</varname>(<varname>a</varname>), <varname>Aggregate_Function</varname>(<varname>b</varname>), 
       <varname>Aggregate_Function</varname>(<varname>c</varname>), <varname>Aggregate_Function</varname>(<varname>d</varname>)
FROM <varname>named_keyspace_ref</varname>
WHERE <varname>a</varname> IS NOT MISSING
GROUP BY <varname>a</varname>;</codeblock><b>Example
                    11:</b><codeblock>CREATE INDEX idx11 ON `travel-sample`(ROUND(geo.lat), geo.alt, city, ROUND(geo.lon)) 
       WHERE type = "airport";

SELECT MIN(ROUND(geo.lat)) AS Min_Lat, 
       SUM(geo.alt) AS Sum_Alt, 
       COUNT(city) AS Count_City,  
       MAX(ROUND(geo.lon)) AS Max_Lon
FROM `travel-sample`
WHERE geo.lat IS NOT MISSING
AND type = "airport"
<b>GROUP BY (ROUND(geo.lat)) </b>
ORDER BY (ROUND(geo.lat)) DESC;</codeblock>Results:<codeblock>[
  {
    "Count_City": 1,
    "Max_Lon": 43,
   <b> "Min_Lat": 72,</b>
    "Sum_Alt": 149
  },
  {
    "Count_City": 3,
    "Max_Lon": -157,
  <b>  "Min_Lat": 71,</b>
    "Sum_Alt": 120
  },
  {
    "Count_City": 6,
    "Max_Lon": -144,
  <b>  "Min_Lat": 70,</b>
    "Sum_Alt": 292
  },
...</codeblock><b
                    id="docs-internal-guid-a09e0778-ba63-b476-8b94-010a6fa15ca8">12. DISTINCT
                    aggregates</b></p>
            <p>There are four cases when DISTINCT aggregates can use this feature:<ol
                    id="ol_jbx_zn2_ycb">
                    <li>If the DISTINCT aggregate is on the leading GROUP BY key(s).</li>
                    <li>If the DISTINCT aggregate is on the leading GROUP By key(s) + 1 (the
                        immediate next key).</li>
                    <li>If the DISTINCT aggregate is on a constant expression (GROUP BY can be on
                        any key).</li>
                    <li>If there is no GROUP BY and the DISTINCT aggregate is on the first key only
                        or in a constant expression.</li>
                </ol>To use Aggregate Pushdown, use one of the following syntaxes of the index and
                query statements:</p>
            <p><b>Case #1:</b> If the DISTINCT aggregate is on the leading GROUP BY key(s).<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i><b>a, b</b>, c</i>);</codeblock><dl>
                    <dlentry>
                        <dt>Syntax A:</dt>
                        <dd>
                            <codeblock>SELECT SUM(DISTINCT <b><i>a</i></b>)
FROM named_keyspace_ref
WHERE <i>a</i> IS NOT MISSING
GROUP BY <b><i>a</i></b>;</codeblock>
                        </dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt>Syntax B:</dt>
                        <dd>
                            <codeblock>SELECT COUNT(DISTINCT <i><b>a</b></i>), SUM(DISTINCT <i><b>b</b></i>)
FROM <varname>named_keyspace_ref</varname>
WHERE <i>a</i> IS NOT MISSING
GROUP BY <i><b>a, b</b></i>;</codeblock>
                        </dd>
                    </dlentry>
                </dl><b>Example 12-1 (A):</b> A DISTINCT aggregate on the leading GROUP BY
                    key(s).<codeblock>CREATE INDEX idx12_1 ON `travel-sample`(<b>ROUND(geo.lat)</b>, <b>ROUND(geo.lon)</b>, country) 
WHERE type = "airport";

SELECT SUM(DISTINCT <b>ROUND(geo.lat)</b>) AS Sum_Lat
FROM `travel-sample`
WHERE geo.lat IS NOT MISSING
AND type = "airport"
GROUP BY <b>ROUND(geo.lat)</b>;</codeblock>Results:<codeblock>[
  {
    "Sum_Lat": 27
  },
  {
    "Sum_Lat": 36
  },
  {
    "Sum_Lat": 71
  },
...</codeblock><b>Example
                    12-1 (B):</b> A DISTINCT aggregate on the leading GROUP BY
                    key(s).<codeblock>SELECT COUNT(DISTINCT <b>ROUND(geo.lat)</b>) AS Count_Lat, 
       SUM(DISTINCT <b>ROUND(geo.lon)</b>) AS Sum_Lon
FROM `travel-sample`
WHERE geo.lat IS NOT MISSING
AND type = "airport"
GROUP BY <b>ROUND(geo.lat), ROUND(geo.lon)</b>;</codeblock>Results:<codeblock>[
  {
    "Count_Lat": 1,
    "Sum_Lon": -166
  },
  {
    "Count_Lat": 1,
    "Sum_Lon": -107
  },
  {
    "Count_Lat": 1,
    "Sum_Lon": -159
  },
...</codeblock><b>Case
                    #2:</b> If the DISTINCT aggregate is on the leading GROUP BY key(s) + 1 (the
                next key)<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i><b>a, b</b>, c</i>);</codeblock><dl>
                    <dlentry>
                        <dt>Syntax A:</dt>
                        <dd>
                            <codeblock>SELECT SUM(DISTINCT <b><i>b</i></b>)
FROM <varname>named_keyspace_ref</varname>
WHERE <i>a</i> IS NOT MISSING
GROUP BY <b><i>a</i></b>;</codeblock>
                        </dd>
                    </dlentry>
                </dl><dl>
                    <dlentry>
                        <dt>Syntax B:</dt>
                        <dd>
                            <codeblock>SELECT COUNT(DISTINCT <b><i>c</i></b>)
FROM <varname>named_keyspace_ref</varname>
WHERE <i>a</i> IS NOT MISSING
GROUP BY <b><i>a, b</i></b>;</codeblock>
                        </dd>
                    </dlentry>
                </dl><b>Example 12-2 (A):</b> A DISTINCT aggregate  on the leading GROUP BY key(s) +
                1 (the next
                    key).<codeblock>CREATE INDEX idx12_2 ON `travel-sample`(<b>country, ROUND(geo.lat)</b>, ROUND(geo.lon)) 
WHERE type = "airport";

SELECT COUNT(DISTINCT country) AS Count_Country, 
       SUM(DISTINCT <b>ROUND(geo.lat)</b>) AS Sum_Lat
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "airport"
GROUP BY <b>country</b>;</codeblock>Results:<codeblock>[
  {
    "Count_Country": 1,
    "Sum_Lat": 483
  },
  {
    "Count_Country": 1,
    "Sum_Lat": 2290
  },
  {
    "Count_Country": 1,
    "Sum_Lat": 591
  }
]</codeblock><b>Example
                    12-2 (B):</b> A DISTINCT aggregate on the leading GROUP BY key(s) + 1 (the next
                    key)<codeblock>SELECT COUNT(DISTINCT country) AS Count_Country, 
       SUM(DISTINCT ROUND(geo.lat)) AS Sum_Lat, 
       COUNT(DISTINCT <b>ROUND(geo.lon)</b>) AS Count_Lon
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "airport"
GROUP BY <b>country, ROUND(geo.lat)</b>;</codeblock>Results:<codeblock>[
  {
    "Count_Country": 1,
    "Count_Lon": 16,
    "Sum_Lat": 483
  },
  {
    "Count_Country": 1,
    "Count_Lon": 103,
    "Sum_Lat": 2290
  },
  {
    "Count_Country": 1,
    "Count_Lon": 13,
    "Sum_Lat": 591
  }
]</codeblock><b>Case
                    #3:</b> If the DISTINCT aggregate is on a constant expression (GROUP BY can be
                on any
                    key)<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i>a, <b>b</b>, c</i>);

SELECT <i>a</i>, COUNT(DISTINCT 1)
FROM <varname>named_keyspace_ref</varname>
WHERE <varname>a</varname> IS NOT MISSING
GROUP BY <b><i>b</i></b>;</codeblock><note>The
                    results will be pre-aggregated if the <codeph>GROUP BY</codeph> key is
                    non-leading, as in this case and example.</note><b>Example 12-3:</b> A DISTINCT
                aggregate on a constant expression (GROUP BY can be on any
                    key)<codeblock>CREATE INDEX idx12_3 ON `travel-sample`(country, <b>geo.lat</b>, geo.lon) 
WHERE type = "airport";

SELECT MIN(country) AS Min_Country, 
       COUNT(DISTINCT 1) AS Constant_Value,
       MIN(ROUND(geo.lon)) AS Min_Logitude
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "airport"
GROUP BY <b>geo.lat</b>;</codeblock>Results:<codeblock>[
  {
    "Constant_Value": 1,
    "Min_Country": "United States",
    "Min_Longitude": -75
  },
  {
    "Constant_Value": 1,
    "Min_Country": "United States",
    "Min_Longitude": -169
  },
  {
    "Constant_Value": 1,
    "Min_Country": "United States",
    "Min_Longitude": -165
  },
...</codeblock><b>Case
                    #4:</b> If the DISTINCT aggregate is on the first key only or in a constant
                expression, and there is no GROUP BY
                clause<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i>a, b, c</i>);

Q1: SELECT SUM(DISTINCT a)
    FROM <varname>named_keyspace_ref</varname>;               /* ok */

Q2: SELECT COUNT(DISTINCT 1)
    FROM <varname>named_keyspace_ref</varname>;               /* ok */

Q3: SELECT SUM(DISTINCT c)
    FROM <varname>named_keyspace_ref</varname>;                /* not ok */</codeblock>All
                other cases of DISTINCT pushdown will return an error.</p>
            <p><b>Example 12-4:</b> A DISTINCT aggregate on the first key only or in a constant
                expression, and there is no GROUP BY
                clause.<codeblock>CREATE INDEX idx12_4 ON `travel-sample`(<b>geo.alt</b>, geo.lat, <b>geo.lon</b>) 
WHERE type = "airport";

Q1: SELECT SUM(DISTINCT ROUND(geo.alt)) AS Sum_Alt
    FROM `travel-sample`
    WHERE geo.alt IS NOT MISSING
    AND type = "airport";</codeblock>Results:<codeblock>[
  {
    "Sum_Alt": 1463241
  }
]</codeblock>Another
                query with index<codeph>
                idx12_4:</codeph><codeblock>Q2: SELECT COUNT(DISTINCT 1) AS Const_expr
    FROM `travel-sample`
    WHERE type = "airport";</codeblock>Results:<codeblock>[
  {
    "Const_expr": 1
  }
]</codeblock>Another
                query with index<codeph> idx12_4</codeph> but will not pushdown the aggregate to the
                    indexer:<codeblock>Q3: SELECT SUM(DISTINCT ROUND(geo.lon)) AS Sum_Lon
    FROM `travel-sample`
    WHERE geo.alt IS NOT MISSING
    AND type = "airport";</codeblock>Results:<codeblock>[
  {
    "Sum_Lon": -11412
  }
]</codeblock><b
                    id="docs-internal-guid-9773d2db-ba85-f585-ea05-595abd843c10">13. HAVING with an
                    aggregate function inside</b></p>
            <p>To use Aggregate Pushdown when a HAVING clause has an aggregate function inside, use
                the following syntax of index and query
                    statement:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i>k0, k1</i>);     

SELECT <varname>k0</varname>, COUNT(<varname>k1</varname>) 
FROM <varname>named_keyspace_ref</varname>
WHERE <varname>k0</varname> IS NOT MISSING
GROUP BY <varname>k0</varname>
<b>HAVING Aggregate_Function(<i>k1</i>);</b></codeblock><b>Example
                    13: </b>HAVING with an aggregate function inside.</p>
            <p>List the cities that have more than 180
                    landmarks.<codeblock>CREATE INDEX idx13 ON `travel-sample` (city, name) 
WHERE type = "landmark";

SELECT city AS City, COUNT(DISTINCT name) AS Landmark_Count 
FROM `travel-sample`
WHERE city IS NOT MISSING
AND type = "landmark"
GROUP BY city
<b>HAVING COUNT(DISTINCT name) > 180;</b></codeblock>Results:<codeblock>[
  {
    "City": "London",
    "Landmark_Count": 443
  },
  {
    "City": "Los Angeles",
    "Landmark_Count": 284
  },
  {
    "City": "San Diego",
    "Landmark_Count": 197
  },
  {
    "City": "San Francisco",
    "Landmark_Count": 797
  }
]</codeblock><b
                    id="docs-internal-guid-19518afc-ba8a-3f81-650a-f64236d62a51">14. LETTING with an
                    aggregate function inside</b></p>
            <p>To use Aggregate Pushdown when a LETTING clause has an aggregate function inside, use
                the following syntax of the index and query
                    statement.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i>k0, k1</i>);     

SELECT <varname>k0</varname>, COUNT(<varname>k1</varname>) 
FROM <varname>named_keyspace_ref</varname>
WHERE <varname>k0</varname> IS NOT MISSING
GROUP BY <varname>k0</varname>
<b>LETTING <i>var_expr</i> = Aggregate_Function(<i>k1</i>)</b>
HAVING <i>var_expr</i>;</codeblock><b>Example
                    14: </b>LETTING with an aggregate function inside.</p>
            <p>List cities that have more than half of all
                    landmarks.<codeblock>CREATE INDEX idx14 ON `travel-sample` (city, name) 
WHERE type = "landmark";

SELECT city AS City, COUNT(DISTINCT name) AS Landmark_Count 
FROM `travel-sample`
WHERE city IS NOT MISSING
AND type = "landmark"
GROUP BY city
<b>LETTING MinimumThingsToSee = COUNT(DISTINCT name)</b>
HAVING MinimumThingsToSee > 180;</codeblock>Results:<codeblock>[
  {
    "City": "London",
    "Landmark_Count": 443
  },
  {
    "City": "Los Angeles",
    "Landmark_Count": 284
  },
  {
    "City": "San Diego",
    "Landmark_Count": 197
  },
  {
    "City": "San Francisco",
    "Landmark_Count": 797
  }
]</codeblock>
              <!--
              <b
                    id="docs-internal-guid-f14f9e5d-ba8d-b654-70f2-27f204564ae0">15. Aggregate on
                    non-array index field</b></p>
            <p>For cases where your query involves arrays, consider the aggregates on array and
                non-array fields. For details on array indexes, see <xref
                    href="#groupby-aggregate-performance/docs-internal-guid-6b830f6f-babe-926c-480c-d3ddd586babc"
                    format="dita">Aggregate on Array Index Field</xref>.</p>
            <p>When using aggregates on non-array index fields, keep the following in mind:<ul
                    id="ul_hxv_k52_ycb">
                    <li>Pushdown is supported for MIN() and MAX() functions.</li>
                    <li>Pushdown is not supported for SUM() or COUNT() functions, since they can
                        give wrong results due to duplicate entries caused by array explosion, even
                        when using a DISTINCT Array Index.</li>
                    <li><xref
                            href="#groupby-aggregate-performance/docs-internal-guid-a09e0778-ba63-b476-8b94-010a6fa15ca8"
                            format="dita">DISTINCT Aggregate</xref> cases apply to pre-aggregate for
                        non-leading GROUP BY keys.</li>
                    <li>Filters can be pushed on any leading or non-leading key.</li>
                    <li>API3 will use KeyPos to specify the array index field.</li>
                </ul>To use Aggregate Pushdown, there are three cases of GROUP BY:<ol
                    id="ol_vgq_x52_ycb">
                    <li>GROUP BY a non-array index field.</li>
                    <li>GROUP BY an array index field.</li>
                    <li>Without a GROUP BY clause.</li>
                </ol><b>Case #1: </b>GROUP BY a non-array index field.</p>
            <p>To use Aggregate Pushdown, use the following syntax of the index and query
                    statements:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>k0</varname>, ALL <varname>ka0</varname>, <varname>k1</varname>);

Q1: SELECT MIN(<varname>k0</varname>)
    FROM <varname>named_keyspace_ref</varname>
    WHERE <varname>k0</varname> > <i>n</i>
    GROUP BY <varname>k0</varname>;      /* ok */

Q2: SELECT MAX(<varname>k1</varname>)
    FROM <varname>named_keyspace_ref</varname>
    WHERE <varname>k0</varname> > <i>n</i>
    GROUP BY <varname>k0</varname>;      /* ok */

Q3: SELECT MAX(<varname>k1</varname>)
    FROM <varname>named_keyspace_ref</varname>
    WHERE <varname>k0</varname> > <i>n</i>
    GROUP BY <varname>k1</varname>;      /* ok (pre-aggregated) */

Q4: SELECT SUM(<varname>k0</varname>)
    FROM <varname>named_keyspace_ref</varname>
    WHERE <varname>k0</varname> > <i>n</i>
    GROUP BY <varname>k0</varname>;      /* no Aggregate Pushdown */

Q5: SELECT COUNT(<varname>k1</varname>)
    FROM <varname>named_keyspace_ref</varname>
    WHERE <varname>k0</varname> > <i>n</i>
    GROUP BY <varname>k0</varname>;      /* no Aggregate Pushdown */</codeblock><b>Example
                    15-1: </b>GROUP BY non-array index
                field.<codeblock>CREATE INDEX idx15_1 ON `travel-sample` (geo.alt, ALL geo.alt, geo.lat) WHERE type = "airport";

Q1: SELECT MIN(geo.alt) AS Min_Altitude
    FROM `travel-sample`
    WHERE type = "airport"
    AND geo.alt > 7800
    GROUP BY geo.alt;</codeblock>Results:<codeblock>[
  {
    "Min_Altitude": 7820
  },
  {
    "Min_Altitude": 8544
  },
  {
    "Min_Altitude": 9078
  }
]</codeblock>Another
                query with index
                <codeph>idx15_1</codeph>:<codeblock>Q2: SELECT MAX(geo.lat) AS Max_Latitude
    FROM `travel-sample`
    WHERE geo.alt > 7800
    AND type = "airport"
    GROUP BY geo.alt;</codeblock>Results:<codeblock>[
  {
    "Max_Latitude": 39.2232
  },
  {
    "Max_Latitude": 38.893889
  },
  {
    "Max_Latitude": 37.953759
  }
]</codeblock>Another
                query with index <codeph>idx15_1</codeph>, but is
                pre-aggregated:<codeblock>Q3: SELECT MAX(geo.lat) AS Max_Latitude
    FROM `travel-sample`
    WHERE geo.alt IS NOT MISSING
    AND type = "airport"
    AND geo.alt > 7800
    GROUP BY geo.lat;</codeblock>Results:<codeblock>[
  {
    "Max_Latitude": 39.2232
  },
  {
    "Max_Latitude": 38.893889
  },
  {
    "Max_Latitude": 37.953759
  }
]</codeblock>Another
                query with index <codeph>idx15_1</codeph>, but does not push down the
                aggregate:<codeblock>Q4: SELECT SUM(geo.alt) AS Max_Latitude
    FROM `travel-sample`
    WHERE type = "airport"
    AND geo.alt > 7800
    GROUP BY geo.alt;</codeblock>Results:<codeblock>[
  {
    "Max_Latitude": 7820
  },
  {
    "Max_Latitude": 8544
  },
  {
    "Max_Latitude": 9078
  }
]</codeblock>Another
                query with index <codeph>idx15_1</codeph>, but does not push down the
                    aggregate:<codeblock>Q5: SELECT COUNT(geo.lat) AS Num_of_Latitude
    FROM `travel-sample`
    WHERE type = "airport"
    AND geo.alt > 7800
    GROUP BY geo.alt;</codeblock>Results:<codeblock>[
  {
    "Num_of_Latitude": 1
  },
  {
    "Num_of_Latitude": 1
  },
  {
    "Num_of_Latitude": 1
  }
]</codeblock><b>Case
                    #2: </b>GROUP BY an array index
                    field.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (ALL <varname>ka0</varname>, <varname>k0</varname>, <varname>k1</varname>);

Q1: SELECT MIN(d.k0)
    FROM named_keyspace_ref d
    UNNEST d.ka0 AS x
    WHERE d.ka0 IS NOT MISSING
    AND x > 10
    GROUP BY x;         /* ok */

Q2: SELECT MAX(k1)
    FROM named_keyspace_ref d
    UNNEST d.ka0 AS x 
    WHERE d.ka0 IS NOT MISSING
    AND x > 10 
    GROUP BY x;         /* ok */

Q3: SELECT SUM(k0) 
    FROM named_keyspace_ref d 
    UNNEST d.ka0 AS x 
    WHERE d.ka0 IS NOT MISSING
    AND x > 10 
    GROUP BY x;         /* no Aggregate Pushdown */

Q4: SELECT COUNT(k1) 
    FROM named_keyspace_ref d 
    UNNEST d.ka0 AS x 
    WHERE d.ka0 IS NOT MISSING
    AND x > 10 
    GROUP BY x;         /* no Aggregate Pushdown */</codeblock><b>Example
                    15-2: </b>GROUP BY an array index
                field.<codeblock>CREATE INDEX idx15_2 ON `travel-sample` (ALL public_likes, city, country)
WHERE type = "hotel";

Q1: SELECT MIN(t.city) AS City
    FROM `travel-sample` t
    UNNEST t.public_likes AS x
    WHERE t.type = "hotel"
    AND x > "A"
    GROUP BY x;</codeblock>Results:<codeblock>[
  {
    "City": "Na h-Eileanan an Iar"
  },
  {
    "City": "San Francisco"
  },
  {
    "City": "Paris-17E-Arrondissement"
  },
...</codeblock>Another
                query with index<codeph>
                idx15_2</codeph>:<codeblock>Q2: SELECT MAX(t.city) AS City
    FROM `travel-sample` t
    UNNEST t.public_likes AS x 
    WHERE t.type = "hotel"
    AND x > "A" 
    GROUP BY x;</codeblock>Results:<codeblock>[
  {
    "City": "Na h-Eileanan an Iar"
  },
  {
    "City": "San Francisco"
  },
  {
    "City": "Paris-17E-Arrondissement"
  },
...</codeblock>Another
                query with index<codeph> idx15_2</codeph>, but does not push down the
                aggregate:<codeblock>Q3: SELECT SUM(TONUMBER(t.pets_ok)) AS Allows_Pets  
    FROM `travel-sample` t 
    UNNEST t.pets_ok AS x 
    WHERE type = "hotel"
    AND x IS NOT MISSING
    GROUP BY x;</codeblock>Another
                query with index<codeph> idx15_2</codeph>, but does not push down the
                aggregate:<codeblock>Q4: SELECT COUNT(airline) 
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE type = "route"
    AND x > 10 
    GROUP BY x;</codeblock>Or
                create an index that swaps the first two
                    arguments:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<b><i>k0</i>, ALL <i>ka0</i></b>, <i>k1</i>);

Q1: SELECT MIN(<i>k0</i>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0</varname>, <varname>ka0</varname>   /* ok */

Q2: SELECT MAX(<varname>k1</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>ka0</varname>       /* ok (pre-aggregated) */

Q3: SELECT SUM(<varname>k0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0</varname>, <varname>ka0</varname>   /* no Aggregate Pushdown */

Q4: SELECT COUNT(<varname>k1</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>ka0</varname>       /* no Aggregate Pushdown */</codeblock><b>Example
                    15-2b: </b>Queries with an index that swaps the first two arguments of Example
                15-2.<codeblock>CREATE INDEX idx15-2b ON `travel-sample` (<b>distance, ALL schedule</b>, airline)
WHERE type = "route";

Q1: SELECT MIN(distance)
    FROM `travel-sample` t
    UNNEST t.schedule AS x
    WHERE type = "route"
    AND distance > 10
    GROUP BY distance, schedule;</codeblock>Another
                query with index<codeph> idx15_2b</codeph>, but is
                pre-aggregated:<codeblock>Q2: SELECT MAX(airline)
    FROM `travel-sample` t
    UNNEST t.schedule AS x 
    WHERE type = "route"
    AND distance > 10 
    GROUP BY schedule; </codeblock>Another
                query with index<codeph> idx15_2b</codeph>, but does not push down the
                aggregate:<codeblock>Q3: SELECT SUM(distance) 
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE type = "route"
    AND distance > 10 
    GROUP BY distance, schedule;</codeblock>Another
                query with index<codeph> idx15_2b</codeph>, but does not push down the
                    aggregate:<codeblock>Q4: SELECT COUNT(airline) 
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE type = "route"
    AND distance > 10 
    GROUP BY schedule;</codeblock><b>Case
                    #3: </b>Without a GROUP BY
                    clause.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i>k0</i>, ALL <i>ka0</i>, <i>k1</i>);

Q1: SELECT MIN(<varname>k0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname>;     /* ok */

Q2: SELECT MAX(<varname>k1</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname>;     /* ok */

Q3: SELECT SUM(<varname>k0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname>;     /* no Aggregate Pushdown */

Q4: SELECT COUNT(k1) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname>;     /* no Aggregate Pushdown */</codeblock><b>Example
                    15-3: </b>Queries without GROUP
                BY.<codeblock>CREATE INDEX idx15_3 ON `travel-sample` (distance, ALL schedule, airline);

Q1: SELECT MIN(distance)
    FROM `travel-sample` t
    UNNEST t.schedule AS x
    WHERE type = "route"
    AND distance > 10;</codeblock>Another
                query with index<codeph>
                idx15_3</codeph>:<codeblock>Q2: SELECT MAX(airline)
    FROM `travel-sample` t
    UNNEST t.schedule AS x 
    WHERE type = "route"
    AND distance > 10; </codeblock>Another
                query with index<codeph> idx15_3</codeph>, but does not push down the
                    aggregate:<codeblock>Q3: SELECT SUM(distance) 
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE type = "route"
    AND distance > 10;</codeblock><b
                    id="docs-internal-guid-6b830f6f-babe-926c-480c-d3ddd586babc">16. Aggregate on
                    array index field</b></p>
            <p>When using aggregates on an array index field, keep the following in mind:<ul
                    id="ul_e4y_z1f_ycb">
                    <li>Pushdown is supported for MIN(), MAX(), SUM(), and COUNT(), as well as for
                        DISTINCT Array Index.</li>
                    <li><xref
                            href="#groupby-aggregate-performance/docs-internal-guid-a09e0778-ba63-b476-8b94-010a6fa15ca8"
                            format="dita">DISTINCT Aggregate</xref> cases apply to pre-aggregates
                        for non-leading GROUP BY keys.</li>
                    <li>Filters can be pushed on any leading or non-leading key.</li>
                    <li>API3 will use KeyPos to specify the array index field.</li>
                </ul>To use Aggregate Pushdown, there are three cases of GROUP BY:<ol
                    id="ol_t2s_2bf_ycb">
                    <li>GROUP BY a non-array index field.</li>
                    <li>GROUP BY an array index field.</li>
                    <li>Without a GROUP BY clause.</li>
                </ol><note><codeph>SUM()</codeph> of an array works only if every element is a
                    number.</note><b>Case #1:</b> GROUP BY a non-array index
                    field.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i>k0</i>, ALL <i>ka0</i>, <i>k1</i>);

Q1: SELECT MIN(<varname>ka0</varname>)
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0</varname>;        /* ok */

Q2: SELECT MAX(<varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k1</varname>;        /* ok (pre-aggregated) */

Q3: SELECT SUM(<varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0</varname>         /* ok */

Q4: SELECT COUNT(<varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k1</varname>         /* ok (pre-aggregated) */</codeblock><b>Example
                    16-1: </b>GROUP BY a non-array index
                field.<codeblock>CREATE INDEX idx16_1 ON `travel-sample`(distance, ALL schedule, airline) 
WHERE type = "route";

Q1: SELECT MIN(schedule) AS Min_Schedule
    FROM `travel-sample`
    WHERE distance IS NOT MISSING
    AND type = "route"
    AND distance > 2000
    GROUP BY distance;</codeblock>Results:<codeblock>[
  {
    "Min_Schedule": [
      {
        "day": 0,
        "flight": "SS221",
        "utc": "22:05:00"
      },
      {
        "day": 0,
        "flight": "SS225",
        "utc": "18:41:00"
      },
      {
        "day": 0,
        "flight": "SS741",
        "utc": "16:40:00"
      },
...</codeblock>Another
                query with index<codeph>
                idx16_1</codeph>:<codeblock>Q2: SELECT MAX(schedule) AS Max_Schedule
    FROM `travel-sample`
    WHERE type = "route"
    AND distance > 1000
    GROUP BY airline;</codeblock>Results:<codeblock>[
  {
    "Max_Schedule": [
      {
        "day": 0,
        "flight": "XL631",
        "utc": "09:03:00"
      },
      {
        "day": 0,
        "flight": "XL967",
        "utc": "12:36:00"
      },
...</codeblock>Another
                query with index<codeph>
                    idx16_1</codeph>:<codeblock>Q3: SELECT SUM(schedule) AS Sum_Schedule
    FROM `travel-sample`
    WHERE type = "route"
    AND distance > 1000
    GROUP BY distance;</codeblock>Results:<codeblock>[
  {
    "Sum_Schedule": null
  },
  {
    "Sum_Schedule": null
  },
  {
    "Sum_Schedule": null
  },
...</codeblock><note>All
                    result in<codeph> null </codeph>since not every element of the array is a
                    number.</note><b>CASE #2: </b>GROUP BY array index
                    field.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (ALL <varname>ka0</varname>, <varname>k0</varname>, <varname>k1</varname>);

Q1: SELECT MIN(x) 
    FROM <varname>named_keyspace_ref d</varname>
    UNNEST <varname>d</varname>.<varname>ka0</varname> AS x 
    WHERE <varname>x</varname> > <varname>n</varname> 
    GROUP BY <varname>x</varname>;         /* ok */

Q2: SELECT MAX(<varname>x</varname>) 
    FROM <varname>named_keyspace_ref d </varname>
    UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
    WHERE <varname>x > n</varname> 
    GROUP BY <varname>x</varname>;         /* ok */

Q3: SELECT SUM(<varname>x</varname>) 
    FROM <varname>named_keyspace_ref d</varname> 
    UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
    WHERE <varname>x > n </varname>
    GROUP BY <varname>x</varname>;         /* ok */

Q4: SELECT COUNT(<varname>x</varname>) 
    FROM <varname>named_keyspace_ref d</varname> 
    UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
    WHERE <varname>x > n</varname>
    GROUP BY <varname>x</varname>;         /* ok */</codeblock><b>Example
                    16-2: </b>GROUP BY array index
                field.<codeblock>CREATE INDEX idx16_2 ON `travel-sample` (ALL schedule, distance, airline);

Q1: SELECT MIN(x) AS Min_Schedule
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE x > 10 
    GROUP BY x
    LIMIT 4;</codeblock>Results:<codeblock>[
  {
    "Min_Schedule": {
      "day": 0,
      "flight": "2L039",
      "utc": "15:53:00"
    }
  },
  {
    "Min_Schedule": {
      "day": 0,
      "flight": "2L120",
      "utc": "16:16:00"
    }
  },
  {
    "Min_Schedule": {
      "day": 0,
      "flight": "2L187",
      "utc": "07:19:00"
    }
  },
  {
    "Min_Schedule": {
      "day": 0,
      "flight": "2L211",
      "utc": "07:14:00"
    }
  }
]</codeblock>Another
                query with index
                <codeph>idx16_2</codeph>:<codeblock>Q2: SELECT MAX(x) AS Max_Schedule
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE x > 10 
    GROUP BY x
    LIMIT 4;</codeblock>Results:<codeblock>[
  {
    "Max_Schedule": {
      "day": 0,
      "flight": "2L039",
      "utc": "15:53:00"
    }
  },
  {
    "Max_Schedule": {
      "day": 0,
      "flight": "2L120",
      "utc": "16:16:00"
    }
  },
  {
    "Max_Schedule": {
      "day": 0,
      "flight": "2L187",
      "utc": "07:19:00"
    }
  },
  {
    "Max_Schedule": {
      "day": 0,
      "flight": "2L211",
      "utc": "07:14:00"
    }
  }
]</codeblock>Another
                query with index
                    <codeph>idx16_2</codeph>:<codeblock>Q3: SELECT SUM(x) AS Sum_Schedule
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE x > 10 
    GROUP BY x
    LIMIT 4;</codeblock>Results:<codeblock>[
  {
    "Sum_Schedule": null
  },
  {
    "Sum_Schedule": null
  },
  {
    "Sum_Schedule": null
  },
  {
    "Sum_Schedule": null
  }
]</codeblock><note>These
                    result in<codeph> null </codeph>since not every element of the array is a
                    number.</note>Another query with index
                    <codeph>idx16_2</codeph>:<codeblock>Q4: SELECT COUNT(x) AS Count_Schedule
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE x > 10 
    GROUP BY x
    LIMIT 4;</codeblock>Results:<codeblock>[
  {
    "Count_Schedule": 1
  },
  {
    "Count_Schedule": 1
  },
  {
    "Count_Schedule": 1
  },
  {
    "Count_Schedule": 1
  }
]</codeblock><b>Case
                    #3: </b>Without a GROUP BY
                    clause.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>k0</varname>, ALL <varname>ka0</varname>, <varname>k1</varname>);

Q1: SELECT MIN(<varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname>;      /* ok */

Q2: SELECT MAX(<varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname>;      /* ok */

Q3: SELECT SUM(<varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname>;      /* ok */

Q4: SELECT COUNT(<varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname>;      /* ok */</codeblock><b>Example
                    16-3: </b>Without a GROUP BY
                clause.<codeblock>CREATE INDEX idx16_3 ON `travel-sample` (distance, ALL schedule, airline);

Q1: SELECT MIN(schedule) AS Min_Schedule
    FROM `travel-sample` 
    WHERE distance > 10;</codeblock>Results:<codeblock>[
  {
    "Min_Schedule": [
      {
        "day": 0,
        "flight": "2L039",
        "utc": "15:53:00"
      },
      {
        "day": 0,
        "flight": "2L211",
        "utc": "07:14:00"
      },
      {
        "day": 1,
        "flight": "2L537",
        "utc": "02:11:00"
      },
...</codeblock>Another
                query with index<codeph>
                idx16_3:</codeph><codeblock>Q2: SELECT MAX(schedule) AS Max_Schedule
    FROM `travel-sample` 
    WHERE distance > 10;</codeblock>Results:<codeblock>[
  {
    "Max_Schedule": [
      {
        "day": 0,
        "flight": "XQ808",
        "utc": "22:38:00"
      },
      {
        "day": 0,
        "flight": "XQ458",
        "utc": "14:11:00"
      },
      {
        "day": 0,
        "flight": "XQ864",
        "utc": "00:02:00"
      },
...</codeblock>Another
                query with index<codeph>
                idx16_3:</codeph><codeblock>Q3: SELECT SUM(schedule) AS Sum_Schedule
    FROM `travel-sample` 
    WHERE distance > 10;</codeblock>Results:<codeblock>[
  {
    "Sum_Schedule": null
  }
]</codeblock>Another
                query with index<codeph>
                    idx16_3:</codeph><codeblock>Q4: SELECT COUNT(schedule) AS Count_Schedule
    FROM `travel-sample` 
    WHERE distance > 10;</codeblock>Results:<codeblock>[
  {
    "Count_Schedule": 24014
  }
]</codeblock><b
                    id="docs-internal-guid-c6e690e3-bada-1180-5846-bd30e534ac57">17. DISTINCT
                    Aggregate on non-array index field</b></p>
            <p>When using DISTINCT aggregates on a non-array index field, keep the following in
                    mind:<ul id="ul_jkp_y2f_ycb">
                    <li>The DISTINCT aggregate is supported only on leading GROUP BY key(s) or
                        leading GROUP BY key(s) + 1.</li>
                    <li>Pushdown supported for SUM() and COUNT().</li>
                    <li>Filter can be pushed on any leading or non-leading key.</li>
                    <li>API3 will use KeyPos to specify the array index field.</li>
                </ul>To use Aggregate Pushdown, there are three cases of GROUP BY:<ol
                    id="ol_szs_cff_ycb">
                    <li>GROUP BY a non-array index field.</li>
                    <li>GROUP BY an array index field.</li>
                    <li>Without a GROUP BY clause.</li>
                </ol><b>Case #1: </b>GROUP BY a non-array index
                    field.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>k0</varname>, ALL <varname>ka0</varname>, <varname>k1</varname>);

Q1: SELECT SUM(DISTINCT <varname>k0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0</varname>;             /* ok */

Q2: SELECT COUNT(DISTINCT <varname>k1</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0</varname>;             /* no Aggregate Pushdown */

Q3: SELECT COUNT(DISTINCT <varname>k1</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k1</varname>;             /* no Aggregate Pushdown */</codeblock><b>Example
                    17-1: </b>GROUP BY a non-array index
                field.<codeblock>CREATE INDEX idx17_1 ON `travel-sample` (distance, ALL schedule, airline)
WHERE type = "route";

Q1: SELECT SUM(DISTINCT distance) AS Sum_Distance
    FROM `travel-sample` 
    WHERE distance > 10 
    GROUP BY distance;</codeblock>Results:<codeblock>[
  {
    "Sum_Distance": 10.164110830325237
  },
  {
    "Sum_Distance": 10.349883467475943
  },
  {
    "Sum_Distance": 10.773191332888711
  },
...</codeblock>Another
                query with index<codeph>
                idx17_1:</codeph><codeblock>Q2: SELECT COUNT(DISTINCT airline) AS Sum_Distance
    FROM `travel-sample` 
    WHERE distance > 10 
    GROUP BY distance;</codeblock>Results:<codeblock>[
  {
    "Sum_Distance": 4
  },
  {
    "Sum_Distance": 1
  },
  {
    "Sum_Distance": 1
  },
...</codeblock>Another
                query with index<codeph>
                    idx17_1:</codeph><codeblock>Q3: SELECT COUNT(DISTINCT airline) AS Sum_Distance
    FROM `travel-sample` 
    WHERE distance > 10 
    GROUP BY airline;</codeblock>Results:<codeblock>[
  {
    "Sum_Distance": 1
  },
  {
    "Sum_Distance": 1
  },
  {
    "Sum_Distance": 1
  },
...</codeblock><b>Case
                    #2:</b> GROUP BY an array index
                    field.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (ALL <varname>ka0</varname>, <varname>k0</varname>, <varname>k1</varname>);

Q1: SELECT SUM(DISTINCT <i>d.<b>k0</b></i>) 
    FROM <varname>named_keyspace_ref d</varname> 
    UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
    WHERE <varname>x</varname> > <varname>n</varname> 
    GROUP BY <i><b>x</b></i>;         /* ok */

Q2: SELECT COUNT(DISTINCT <i>d.<b>k1</b></i>) 
    FROM <varname>named_keyspace_ref d</varname> 
    UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
    WHERE <varname>x</varname> > <varname>n</varname> 
    GROUP BY <i><b>x</b></i>;         /* no Aggregate Pushdown */

Q3: SELECT COUNT(DISTINCT <i>d.<b>k1</b></i>) 
    FROM <varname>named_keyspace_ref d</varname> 
    UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
    WHERE <varname>x</varname> > <varname>n</varname> 
    GROUP BY <b><i>x, k0</i></b>      /* ok */</codeblock><b>Example
                    17-2: </b>GROUP BY an array index
                field.<codeblock>CREATE INDEX idx17_2 ON `travel-sample` (ALL schedule, distance, airline)
WHERE type = "route";

Q1: SELECT SUM(DISTINCT t.distance) AS Sum_Distance
    FROM `travel-sample` t 
    UNNEST t.schedule AS x 
    WHERE t.type = "route"
    AND x > 10 
    GROUP BY x
    LIMIT 4;</codeblock>Results:<codeblock>[
  {
    "Sum_Distance": 922.7579695456559
  },
  {
    "Sum_Distance": 770.9691328580009
  },
  {
    "Sum_Distance": 770.969132858001
  },
  {
    "Sum_Distance": 922.7579695456559
  }
]</codeblock>Another
                query with index<codeph>
                idx17_2:</codeph><codeblock>Q2: SELECT COUNT(DISTINCT t.distance) AS Count_Distance
    FROM `travel-sample` t
    UNNEST t.schedule AS x 
    WHERE t.type = "route"
    AND x > 10 
    GROUP BY x
    LIMIT 4;</codeblock>Results:<codeblock>[
  {
    "Count_Distance": 1
  },
  {
    "Count_Distance": 1
  },
  {
    "Count_Distance": 1
  },
  {
    "Count_Distance": 1
  }
]</codeblock>Another
                query with index<codeph>
                idx17_2:</codeph><codeblock>Q3: SELECT COUNT(DISTINCT t.airline) AS Count_Airline
    FROM `travel-sample` t
    UNNEST t.schedule AS x 
    WHERE t.type = "route"
    AND x > 10 
    GROUP BY x, t.distance
    LIMIT 4;</codeblock>Results:<codeblock>[
  {
    "Count_Airline": 1
  },
  {
    "Count_Airline": 1
  },
  {
    "Count_Airline": 1
  },
  {
    "Count_Airline": 1
  }
]</codeblock>Or
                swap the first two
                    arguments:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<i><b>k0, ALL ka0</b></i>, <varname>k1</varname>);

Q1: SELECT SUM(DISTINCT <varname>k0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0</varname>, <varname>ka0</varname>;   /* ok */

Q2: SELECT COUNT(DISTINCT <varname>k1</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0, ka0</varname>;   /* ok */</codeblock><b>Example
                    17-2b: </b>GROUP BY an array index field (Index first two arguments
                swapped).<codeblock>CREATE INDEX ix17_2b ON `travel-sample` (<b>distance, ALL schedule</b>, airline);

Q1: SELECT SUM(DISTINCT distance) AS Sum_Distance
    FROM `travel-sample` 
    WHERE distance > 10 
    GROUP BY distance, schedule;</codeblock>Results:<codeblock>[
  {
    "Sum_Distance": 26.97769224141249
  },
  {
    "Sum_Distance": 1580.6490479675
  },
  {
    "Sum_Distance": 1934.5220892996838
  },
...</codeblock>Another
                query with index<codeph>
                    idx17_2b:</codeph><codeblock>Q2: SELECT COUNT(DISTINCT airline) AS Count_Airline
    FROM `travel-sample` 
    WHERE distance > 10 
    GROUP BY distance, schedule;</codeblock>Results:<codeblock>[
  {
    "Count_Airline": 1
  },
  {
    "Count_Airline": 1
  },
  {
    "Count_Airline": 1
  },
...</codeblock><b>Case
                    #3: </b>Without a GROUP BY
                    clause<codeblock>CREATE INDEX <varname>idx_expr</varname> ON n<varname>amed_keyspace_ref</varname> (<varname>k0</varname>, ALL <varname>ka0</varname>, <varname>k1</varname>);

Q1: SELECT SUM(DISTINCT <varname>k0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0 > n</varname>;           /* ok */

Q2: SELECT COUNT(DISTINCT <varname>k1</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0 > n</varname>;           /* ok */</codeblock><b>Example
                    17-3: </b>Without a GROUP BY
                clause.<codeblock>CREATE INDEX idx17_3 ON `travel-sample` (distance, ALL schedule, airline);

Q1: SELECT SUM(DISTINCT distance) AS Sum_Distance
    FROM `travel-sample` 
    WHERE distance > 10;</codeblock>Results:<codeblock>[
  {
    "Sum_Distance": 14736742.838651348
  }
]</codeblock>Another
                query with index<codeph>
                    idx17_3:</codeph><codeblock>Q2: SELECT COUNT(DISTINCT airline) AS Count_Airline
    FROM `travel-sample` 
    WHERE distance > 10;</codeblock>Results:<codeblock>[
  {
    "Count_Airline": 223
  }
]</codeblock><b
                    id="docs-internal-guid-3d16d747-baee-8dc9-5248-bcf386260db4">18. DISTINCT
                    Aggregate on array index field.</b></p>
            <p>When using a DISTINCT Aggregate on an array index field, keep the following in
                    mind:<ul id="ul_gsb_xhf_ycb">
                    <li>DISTINCT aggregate is supported on only leading GROUP BY key or leading
                        GROUP BY key + 1.</li>
                    <li>Pushdown supported for MIN(), MAX(), SUM(), and COUNT() operations.</li>
                    <li>Filter can be pushed on any leading or non-leading key.</li>
                </ul>To use Aggregate Pushdown, there are three cases of GROUP BY:<ol
                    id="ol_gxs_c3f_ycb">
                    <li>GROUP BY a non-array index field.</li>
                    <li>GROUP BY an array index field.</li>
                    <li>Without a GROUP BY clause.</li>
                </ol><b>Case #1: </b>GROUP BY a non-array index
                    field.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>k0</varname>, ALL <varname>ka0</varname>, <varname>k1</varname>);

Q1: SELECT SUM(DISTINCT <varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k0</varname>;              /* ok */

Q2: SELECT COUNT(DISTINCT <varname>ka0</varname>) 
    FROM <varname>named_keyspace_ref</varname> 
    WHERE <varname>k0</varname> > <varname>n</varname> 
    GROUP BY <varname>k1</varname>;              /* no Aggregate Pushdown */</codeblock><b>Example
                    18-1: </b>GROUP BY a non-array index
                    field.<codeblock>CREATE INDEX idx18_1 ON `travel-sample` (distance, ALL schedule, airline);

Q1: SELECT SUM(DISTINCT schedule) AS Sum_Schedule
    FROM `travel-sample` 
    WHERE distance > 10 
    GROUP BY distance;</codeblock>Results:<codeblock>[
  {
    "Sum_Schedule": null
  },
  {
    "Sum_Schedule": null
  },
  {
    "Sum_Schedule": null
  },
...</codeblock><note>All
                    results are<codeph> null </codeph>since not every element of the array is a
                    number.</note>Another query with index<codeph>
                    idx18_1:</codeph><codeblock>Q2: SELECT COUNT(DISTINCT schedule) AS Max_Schedule
    FROM `travel-sample` 
    WHERE distance > 10 
    GROUP BY airline;</codeblock>Results:<codeblock>[
  {
    "Max_Schedule": 23
  },
  {
    "Max_Schedule": 12
  },
  {
    "Max_Schedule": 38
  },
...</codeblock><b>Case
                    #2: </b>GROUP BY an array index
                    field.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (ALL <varname>ka0</varname>, <varname>k0</varname>, <varname>k1</varname>);

SELECT MIN(DISTINCT <varname>ka0</varname>) 
FROM <varname>named_keyspace_ref d</varname> 
UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
WHERE <varname>x > n</varname> 
GROUP BY <varname>x</varname>;         /* ok */

SELECT MAX(DISTINCT <varname>ka0</varname>) 
FROM <varname>named_keyspace_ref d </varname>
UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
WHERE <varname>x</varname> > <varname>n</varname> 
GROUP BY <varname>x</varname>;         /* ok */

SELECT SUM(DISTINCT <varname>ka0</varname>) 
FROM <varname>named_keyspace_ref d</varname> 
UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
WHERE <varname>x > n</varname> 
GROUP BY <varname>x</varname>;         /* ok */

SELECT COUNT(DISTINCT <varname>ka0</varname>) 
FROM <varname>named_keyspace_ref d</varname> 
UNNEST <varname>d.ka0</varname> AS <varname>x</varname> 
WHERE <varname>x > n</varname> 
GROUP BY <varname>x</varname>;         /* ok */</codeblock><b>Case
                    #3: </b>Without a GROUP BY
                    clause.<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>k0</varname>, ALL <varname>ka0</varname>, <varname>k1</varname>);

SELECT MIN(DISTINCT <varname>ka0</varname>) 
FROM <varname>named_keyspace_ref</varname> 
WHERE <varname>k0 > n</varname>;      /* ok */

SELECT MAX(DISTINCT <varname>ka0</varname>) 
FROM <varname>named_keyspace_ref</varname> 
WHERE <varname>k0 > n</varname>;      /* ok */

SELECT SUM(DISTINCT <varname>ka0</varname>) 
FROM <varname>named_keyspace_ref</varname> 
WHERE <varname>k0 > n</varname>;      /* ok */

SELECT COUNT(DISTINCT <varname>ka0</varname>) 
FROM <varname>named_keyspace_ref</varname> 
WHERE <varname>k0 > n</varname>;      /* ok */</codeblock><b
                    id="docs-internal-guid-6af647a9-baf9-d11a-f512-01f0fdc2c587">19. Array of
                    arrays</b></p>
            <p>To use Aggregate Pushdown with an array of arrays, use the following syntax of the
                index and query
                statement:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>named_keyspace_ref</varname> (<varname>name</varname>, ALL <varname>val2</varname>);  /* val2 is 2-D array */

SELECT <varname>name</varname>, SUM(<varname>q</varname>) 
FROM <varname>t</varname> UNNEST <varname>val2 p</varname> UNNEST <varname>p q </varname>
GROUP BY <varname>name</varname>;</codeblock>

--></p>
        </section>
        <section id="section_bq1_rjf_ycb">
            <title>Limitations</title>
            <p>The following are currently not supported and not pushed to the indexer:<ul
                    id="ul_pyr_sjf_ycb">
                    <li><codeph>HAVING</codeph> or <codeph>LETTING</codeph> clauses, unless there is
                        an aggregate function inside.</li>
                    <li><codeph>ORDER BY</codeph> clauses.</li>
                    <li><codeph>ARRAY_AGG() </codeph>or any facility to add new Aggregate function,
                        such as Median.</li>
                    <li><codeph>LIMIT</codeph> pushdown with <codeph>GROUP BY</codeph> on
                        non-leading keys.</li>
                    <li><codeph>OFFSET</codeph> pushdown with <codeph>GROUP BY</codeph> on
                        non-leading keys.</li>
                    <li>A subquery in a <codeph>GROUP BY</codeph> or Aggregate pushdown.</li>
                </ul></p>
            <p><b>Aggregate Comparison</b><table frame="all" rowsep="1" colsep="1"
                    id="table_hvz_skf_ycb">
                    <tgroup cols="5" align="center">
                        <colspec colname="c1" colnum="1" colwidth="1.5*"/>
                        <colspec colname="c2" colnum="2" colwidth="1*"/>
                        <colspec colname="c3" colnum="3" colwidth="1*"/>
                        <colspec colname="c4" colnum="4" colwidth="1*"/>
                        <colspec colname="c5" colnum="5" colwidth="1*"/>
                        <thead>
                            <row>
                                <entry>Item</entry>
                                <entry>Aggregate on Non-Array Index Field</entry>
                                <entry>Aggregate on Array Index Field</entry>
                                <entry>DISTINCT Aggregate on Non-Array Index Field</entry>
                                <entry>DISTINCT Aggregate on Array Index Field</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Supports <codeph>MIN()</codeph> and
                                    <codeph>MAX()</codeph></entry>
                                <entry><b>✓</b></entry>
                                <entry><b>✓</b></entry>
                                <entry>-</entry>
                                <entry>-</entry>
                            </row>
                            <row>
                                <entry>Supports <codeph>SUM()</codeph> and
                                    <codeph>COUNT()</codeph></entry>
                                <entry>-</entry>
                                <entry><b>✓</b></entry>
                                <entry><b>✓</b></entry>
                                <entry><b>✓</b></entry>
                            </row>
                            <row>
                                <entry>Supports <codeph>AVG()</codeph></entry>
                                <entry><b>✓</b></entry>
                                <entry><b>✓</b></entry>
                                <entry><b>✓</b></entry>
                                <entry><b>✓</b></entry>
                            </row>
                            <row>
                                <entry>Supports <codeph>ARRAY_AGG()</codeph></entry>
                                <entry>-</entry>
                                <entry>-</entry>
                                <entry>-</entry>
                                <entry>-</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table></p>
        </section>
        <section id="section_bpf_wjf_ycb"><title>Appx 1 - Query Plan Fields</title><p>Consider the
                example:<codeblock>EXPLAIN SELECT type, COUNT(type)
FROM `travel-sample`
WHERE type IS NOT MISSING
GROUP BY type;</codeblock>In
                the query plan:<ul id="ul_slq_q4f_ycb">
                    <li><codeph>plan.`~children`[0].covers </codeph>shows that the index covers the
                        query.</li>
                    <li><codeph>plan.`~children`[0].index_group_aggs </codeph>shows the aggregation
                        and groupings done by the indexer.</li>
                    <li><codeph>index_group_aggs </codeph>object has details on the aggregate, index
                        key position, expression dependency, and group expressions handled by the
                        indexer. This object is present in the plan only when the indexer handles
                        the grouping and aggregation.<table frame="all" rowsep="1" colsep="1"
                            id="table_xlp_x4f_ycb">
                            <tgroup cols="3" align="left">
                                <colspec colname="c1" colnum="1" colwidth="1*"/>
                                <colspec colname="c2" colnum="2" colwidth="2.5*"/>
                                <colspec colname="c3" colnum="3" colwidth="2.5*"/>
                                <thead>
                                    <row>
                                        <entry>Item Name</entry>
                                        <entry>Description</entry>
                                        <entry>Explain Text in This Example</entry>
                                    </row>
                                </thead>
                                <tbody>
                                    <row>
                                        <entry><codeph>aggregates</codeph></entry>
                                        <entry>Array of Aggregate objects, and each object
                                            represents one aggregate function. The absence of this
                                            item means there is no Aggregate function.</entry>
                                        <entry><codeph>aggregates</codeph></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... aggregate</codeph></entry>
                                        <entry>Aggregate operation.</entry>
                                        <entry><codeph>COUNT</codeph></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... depends</codeph></entry>
                                        <entry>List of index key positions the GROUP BY expression
                                            depends on, starting with 0.</entry>
                                        <entry><codeph>0</codeph><p>(because it's the 1st
                                            item)</p></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... expr</codeph></entry>
                                        <entry>Group expression or an aggregate expression.</entry>
                                        <entry><codeph>"cover
                                            ((`travel-sample`.`type`))"</codeph></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... id</codeph></entry>
                                        <entry>Unique ID given internally and will be used in
                                                <codeph>index_projection</codeph></entry>
                                        <entry><codeph>2</codeph></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... keypos</codeph></entry>
                                        <entry>Key Position to use the Index expr or the query
                                                expr.<ul id="ul_tlg_2qf_ycb">
                                                <li>A value > -1 means the group key exactly matches
                                                  the corresponding index keys, where 0 is the 1st
                                                  index key.</li>
                                                <li>A value of -1 means the group key does not match
                                                  the index key and uses the query expression
                                                  instead.</li>
                                            </ul></entry>
                                        <entry><codeph>0</codeph><p>(because it matches the 1st
                                                index key)</p></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>depends</codeph></entry>
                                        <entry>List of index key positions the GROUP BY expression
                                            depends on, starting with 0.</entry>
                                        <entry><codeph>0</codeph><p>(because it's the 1st
                                            item)</p></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>group</codeph></entry>
                                        <entry>Array of GROUP BY objects, and each object represents
                                            one group key. The absence of this item means there is
                                            no GROUP BY clause.</entry>
                                        <entry><codeph>group</codeph></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... depends</codeph></entry>
                                        <entry>Index key position of a single GROUP BY
                                            expression</entry>
                                        <entry><codeph>0</codeph><p>(because it's the 1st GROUP BY
                                                key)</p></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... expr</codeph></entry>
                                        <entry>Single GROUP BY expression.</entry>
                                        <entry><codeph>"cover
                                            ((`travel-sample`.`type`))"</codeph></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... id</codeph></entry>
                                        <entry>Unique ID given internally and will be used in
                                                <codeph>index_projection</codeph></entry>
                                        <entry><codeph>0</codeph></entry>
                                    </row>
                                    <row>
                                        <entry><codeph>... keypos</codeph></entry>
                                        <entry>Key Position to use the Index expr or the query
                                                expr.<ul id="ul_qbx_vqf_ycb">
                                                <li>A value > -1 means the group key exactly matches
                                                  the corresponding index keys, where 0 is the 1st
                                                  index key.</li>
                                                <li>A value of -1 means the group key does not match
                                                  the index key and uses the query expression
                                                  instead.</li>
                                            </ul></entry>
                                        <entry><codeph>0</codeph><p>(because it matches the 1st key
                                                in the index expression)</p></entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </table><codeblock>{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "IndexScan3",
     <b>   "covers": [
          "cover ((`travel-sample`.`name`))",
          "cover ((meta(`travel-sample`).`id`))",
          "cover (count(1))"</b>
        ],
        "index": "idx_name",
     <b>   "index_group_aggs": {
          "aggregates": [
            {
              "aggregate": "COUNT",
              "expr": "1",
              "id": 2,
              "keypos": -1
            }
          ],
          "depends": [
            0
          ],
          "group": [
            {
              "depends": [
                0
              ],
              "expr": "cover ((`travel-sample`.`name`))",
              "id": 0,
              "keypos": 0</b>
            }
          ]
        },
        "index_id": "5dfe130db88b4ec",
        "index_projection": {
          "entry_keys": [
            0,
            2
          ]
        },
        "keyspace": "travel-sample",
        "namespace": "default",
        "spans": [
          {
            "exact": true,
            "range": [
              {
                "inclusion": 1,
                "low": "null"
              }
            ]
          }
        ],
        "using": "gsi"
      },
      {
        "#operator": "Parallel",
        "~child": {
          "#operator": "Sequence",
          "~children": [
            {
              "#operator": "InitialProject",
              "result_terms": [
                {
            <b>      "expr": "cover ((`travel-sample`.`name`))"</b>
                },
                {
                  "expr": "cover (count(1))"
                }
              ]
            },
            {
              "#operator": "FinalProject"
            }
          ]
        }
      }
    ]
  },
  "text": "select name, count(1)\nfrom `travel-sample` use index (idx_name)\nwhere name is not missing\ngroup by name;"
}</codeblock></li>
                </ul><note>When the<codeph> index_group_aggs </codeph>section is present, it means
                    that the query is using Index Aggregations.</note></p>GROUP BY Query Plan<table
                frame="all" rowsep="1" colsep="1" id="table_bw2_nrf_ycb">
                <tgroup cols="3" align="left">
                    <colspec colname="c1" colnum="1" colwidth="1*"/>
                    <colspec colname="c2" colnum="2" colwidth="2.5*"/>
                    <colspec colname="c3" colnum="3" colwidth="2.5*"/>
                    <thead>
                        <row>
                            <entry>Item Name</entry>
                            <entry>Description</entry>
                            <entry>EXPLAIN Text in <xref
                                    href="#groupby-aggregate-performance/docs-internal-guid-44fa3035-b9c8-1706-a73e-b0f1c03d91da"
                                    format="dita">Example #1 (GROUP BY)</xref></entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><codeph>aggregates</codeph></entry>
                            <entry>Array of Aggregate objects, and each object represents one
                                aggregate function. The absence of this item means there is no
                                Aggregate function.</entry>
                            <entry><codeph>aggregates</codeph></entry>
                        </row>
                        <row>
                            <entry><codeph>... aggregate</codeph></entry>
                            <entry>Aggregate operation.</entry>
                            <entry><codeph>MAX</codeph></entry>
                        </row>
                        <row>
                            <entry><codeph>... depends</codeph></entry>
                            <entry>List of index key positions the GROUP BY expression depends on,
                                starting with 0.</entry>
                            <entry><codeph>2</codeph><p>(because it's the 3rd item)</p></entry>
                        </row>
                        <row>
                            <entry><codeph>... expr</codeph></entry>
                            <entry>Group expression or an aggregate expression.</entry>
                            <entry><codeph>round(cover (((`travel-sample`.
                                `geo`).`lat`)))</codeph></entry>
                        </row>
                        <row>
                            <entry><codeph>... id</codeph></entry>
                            <entry>Unique ID given internally and will be used in
                                    <codeph>index_projection</codeph></entry>
                            <entry><codeph>4</codeph></entry>
                        </row>
                        <row>
                            <entry><codeph>... keypos</codeph></entry>
                            <entry>Key Position to use the Index expr or the query expr.<ul>
                                    <li>A value > -1 means the group key exactly matches the
                                        corresponding index keys, where 0 is the 1st index key.</li>
                                    <li>A value of -1 means the group key does not match the index
                                        key and uses the query expression instead.</li>
                                </ul></entry>
                            <entry><codeph>-1</codeph><p>(because the index has the field
                                        <codeph>geo.lat</codeph> but the query adds the
                                        <codeph>ROUND()</codeph> function to
                                        <codeph>geo.lat</codeph>)</p></entry>
                        </row>
                        <row>
                            <entry><codeph>depends</codeph></entry>
                            <entry>List of index key positions the GROUP BY expression depends on,
                                starting with 0.</entry>
                            <entry><codeph>0, 1, 2</codeph></entry>
                        </row>
                        <row>
                            <entry><codeph>group</codeph></entry>
                            <entry>Array of GROUP BY objects, and each object represents one group
                                key. The absence of this item means there is no GROUP BY
                                clause.</entry>
                            <entry><codeph>group</codeph></entry>
                        </row>
                        <row>
                            <entry><codeph>... depends</codeph></entry>
                            <entry>Index key position of a single GROUP BY expression, starting with
                                0.</entry>
                            <entry><codeph>0</codeph><p>(because it's the 1st GROUP BY
                                key)</p></entry>
                        </row>
                        <row>
                            <entry><codeph>... expr</codeph></entry>
                            <entry>Single GROUP BY expression.</entry>
                            <entry><codeph>`travel-sample`.`country`</codeph></entry>
                        </row>
                        <row>
                            <entry><codeph>... id</codeph></entry>
                            <entry>Unique ID given internally and will be used in
                                    <codeph>index_projection.</codeph></entry>
                            <entry><codeph>0</codeph></entry>
                        </row>
                        <row>
                            <entry><codeph>... keypos</codeph></entry>
                            <entry>Key Position to use the Index expr or the query expr.<ul
                                    id="ul_lrk_tsf_ycb">
                                    <li>A value > -1 means the group key exactly matches the
                                        corresponding index keys, where 0 is the 1st index key.</li>
                                    <li>A value of -1 means the group key does not match the index
                                        key and uses the query expression instead.</li>
                                </ul></entry>
                            <entry><codeph>0</codeph><p>(because it matches the first key in the
                                    index expression)</p></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table><p>The Query Plan sections of an Aggregate pushdown are slightly different than
                those used in a GROUP BY.</p><p><b
                    id="docs-internal-guid-facfdbc0-bb3d-b00f-2ec0-6bee4921dabc">Aggregate Query
                    Plan</b><table frame="all" rowsep="1" colsep="1" id="table_vyv_ftf_ycb">
                    <tgroup cols="3" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="2.5*"/>
                        <colspec colname="c3" colnum="3" colwidth="2.5*"/>
                        <thead>
                            <row>
                                <entry>Item Name</entry>
                                <entry>Description</entry>
                                <entry>EXPLAIN Text in <xref
                                        href="#groupby-aggregate-performance/docs-internal-guid-be60f70b-ba52-b179-cd13-728a00e7c632"
                                        format="dita">Example #10 (Aggregate)</xref></entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><codeph>aggregates</codeph></entry>
                                <entry>Array of Aggregate objects, and each object represents one
                                    aggregate function. The absence of this item means there is no
                                    Aggregate function.</entry>
                                <entry><codeph>aggregates</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... aggregate</codeph></entry>
                                <entry>Aggregate operation.</entry>
                                <entry><codeph>SUM</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... depends</codeph></entry>
                                <entry>List of index key positions the GROUP BY expression depends
                                    on, starting with 0.</entry>
                                <entry><codeph>2</codeph><p>(because it's the 3rd item)</p></entry>
                            </row>
                            <row>
                                <entry><codeph>... expr</codeph></entry>
                                <entry>Group expression or an aggregate expression.</entry>
                                <entry><codeph>"abs(round(cover
                                        (((`travel-sample`.`geo`).`lat`))))"</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... id</codeph></entry>
                                <entry>Unique ID given internally and will be used in
                                        <codeph>index_projection</codeph></entry>
                                <entry><codeph>4</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... keypos</codeph></entry>
                                <entry>Key Position to use the Index expr or the query expr.<ul>
                                        <li>A value > -1 means the group key exactly matches the
                                            corresponding index keys, where 0 is the 1st index
                                            key.</li>
                                        <li>A value of -1 means the group key does not match the
                                            index key and uses the query expression instead.</li>
                                    </ul></entry>
                                <entry><codeph>2</codeph><p>(because the query's 3rd key exactly
                                        matches the index's 3rd key)</p></entry>
                            </row>
                            <row>
                                <entry><codeph>depends</codeph></entry>
                                <entry>List of index key positions the GROUP BY expression depends
                                    on, starting with 0.</entry>
                                <entry><codeph>0, 1, 2</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>group</codeph></entry>
                                <entry>Array of GROUP BY objects, and each object represents one
                                    group key. The absence of this item means there is no GROUP BY
                                    clause.</entry>
                                <entry><codeph>group</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... depends</codeph></entry>
                                <entry>Index key position of a single GROUP BY expression, starting
                                    with 0.</entry>
                                <entry><codeph>0</codeph><p>(because it's the 1st GROUP BY
                                    key)</p></entry>
                            </row>
                            <row>
                                <entry><codeph>... expr</codeph></entry>
                                <entry>Single GROUP BY expression.</entry>
                                <entry><codeph>"cover ((`travel-sample`.`state`))"</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... id</codeph></entry>
                                <entry>Unique ID given internally and will be used in
                                        <codeph>index_projection.</codeph></entry>
                                <entry><codeph>0</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... keypos</codeph></entry>
                                <entry>Key Position to use the Index expr or the query expr.<ul>
                                        <li>A value > -1 means the group key exactly matches the
                                            corresponding index keys, where 0 is the 1st index
                                            key.</li>
                                        <li>A value of -1 means the group key does not match the
                                            index key and uses the query expression instead.</li>
                                    </ul></entry>
                                <entry><codeph>0</codeph><p>(because it matches the 1st  key in the
                                        index expression)</p></entry>
                            </row>
                            <row>
                                <entry><codeph>... depends</codeph></entry>
                                <entry>Index key position of a single GROUP BY expression, starting
                                    with 0.</entry>
                                <entry><codeph>0</codeph><p>(because it's the 1st GROUP BY
                                    key)</p></entry>
                            </row>
                            <row>
                                <entry><codeph>... expr</codeph></entry>
                                <entry>Single GROUP BY expression.</entry>
                                <entry><codeph>"cover ((`travel-sample`.`state`))"</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... id</codeph></entry>
                                <entry>Unique ID given internally and will be used in
                                        <codeph>index_projection.</codeph></entry>
                                <entry><codeph>1</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>... keypos</codeph></entry>
                                <entry>Key Position to use the Index expr or the query expr.<ul>
                                        <li>A value > -1 means the group key exactly matches the
                                            corresponding index keys, where 0 is the 1st index
                                            key.</li>
                                        <li>A value of -1 means the group key does not match the
                                            index key and uses the query expression instead.</li>
                                    </ul></entry>
                                <entry><codeph>1</codeph><p>(because it matches the 2nd key in the
                                        index expression)</p></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table></p></section>
    </body>
</topic>
