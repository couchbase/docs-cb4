<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="groupby-aggregate-performance">
    <title>Group By and Aggregate Performance</title>
    <shortdesc>N1QL Pushdowns optimize the performance of N1QL queries by supporting GROUP BY and Aggregate expressions.</shortdesc>
    <body>
        <p><i>(Introduced in Couchbase Server 5.5 - Enterprise Edition)</i></p>
        <section id="section_hj3_vcq_xcb">
            <title>Overview</title>
            <p>This features improves performance of N1QL queries with aggregations and GROUP BY
                execution. </p>
            <p>After the optimizer selects an index for a query block, it attempts the two
                optimizations below:<ul id="ul_pkn_zcq_xcb">
                    <li>Pagination optimization, by pushing the OFFSET and LIMIT parameters to the
                        index scan.</li>
                    <li>Grouping and aggregation pushdown to the indexer (introduced in Couchbase
                        5.5).</li>
                </ul>Prior to Couchbase 5.5, even when a query with aggregate and/or GROUP BY is
                covered by an index, the query fetched all relevant data from the indexer and group
                the data within the query engine. With this enhancement, the query intelligently
                requests the indexer to perform grouping and aggregation in addition to range scan.
                The Indexer has been enhanced to perform grouping, COUNT(), SUM(), MIN(), MAX(),
                AVG(), and related operations.</p>
            <p>This requires no changes to the user query, but a good index design to cover the
                query and order the keys is required. Not every query will benefit from this
                optimization, and not every index can accelerate every grouping and aggregation.
                Understanding the right patterns will help you to design your indexes and queries.
                Aggregate Pushdown to the global secondary index is supported on both storage
                engines: Standard GSI and Memory Optimized GSI (MOI).</p>
            <p>This reduction step of performing the GROUP BY and Aggregation on the indexer reduces
                the amount of data transfer and disk I/O, resulting in:<ul id="ul_cnz_fdq_xcb">
                    <li>Improved query response time</li>
                    <li>Improved resource utilization</li>
                    <li>Low latency</li>
                    <li>High scalability</li>
                    <li>Low TCO</li>
                </ul>For example, let's compare the previous vs. current performance of using GROUP
                BY and examine the EXPLAIN plan of the following query that is defined in the
                Couchbase <codeph>travel-sample</codeph>
                index:<codeblock>CREATE INDEX `def_type` ON `travel-sample`(`type`) </codeblock>Consider
                the
                query:<codeblock>SELECT type, COUNT(type)
FROM `travel-sample`
WHERE type IS NOT MISSING
GROUP BY type;</codeblock>Before
                Couchbase version 5.5, this query engine fetched relevant data from the indexer and
                group the data within the query engine and then aggregate. This simple query takes
                about 250 ms.</p>
            <p><image href="images/GBAP_Ex0_QP_before55.png" id="image_lnh_v4q_xcb"/></p>
            <p>Now, in Couchbase version 5.5, this query use the same <codeph>def_type</codeph>
                index, but executes in under 70 ms. In the explain below, you can see fewer steps
                and the lack of the grouping step after the index scan because the index scan step
                does the grouping and aggregation as well.</p>
            <p><image href="images/GBAP_Ex0_QP_after55.png" id="image_bln_w4q_xcb" height="100"
                /></p>
            <p>As the data and query complexity grows, the performance benefit (both latency and
                throughput) will grow as well.</p>
            <p>For example, consider the
                query:<codeblock>SELECT type, COUNT(type)
FROM `travel-sample`
WHERE type IS NOT MISSING
GROUP BY type;</codeblock></p>
            <p>The text explain plan shows the accelerated aggregation details. For details, see the
                <?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?>Query Plan
                Explained<?oxy_custom_end?>
                section.<codeblock>...
        "index_group_aggs": {
          "aggregates": [
            {
              "aggregate": "COUNT",
              "expr": "1",
              "id": 2,
              "keypos": -1
            }
          ],
          "depends": [
            0
          ],
          "group": [
            {
              "depends": [
                0
              ],
              "expr": "cover ((`travel-sample`.`type`))",
              "id": 0,
              "keypos": 0
            }
          ]
        },
        "index_id": "c5bbb792c69c1704",
        "index_projection": {
          "entry_keys": [
            0,
            2
          ]
        },
...</codeblock>Here’s
                is how this query executes when the indexer executes the GROUP BY and aggregation.
                The query engine does not fetch any data from the data service (KV service), as
                shown below:</p>
            <p><image href="images/GBAP_55execution.png" id="image_ngr_kzv_xcb" scale="70"
                    height="700" width="700"/></p>
            <p>For your reference, this is how the same query executed before 5.5.</p>
            <p><image href="images/GBAP_pre55execution.png" id="image_pbg_4zv_xcb" height="700"
                    width="700"/></p>
        </section>
        <section id="section_fw5_ypq_xcb"><title>Examples for Indexer GROUP BY and
                Aggregation</title><p>Let’s Consider a composite index to explore some
                scenarios:<codeblock>CREATE INDEX idx ON customer(c1, c2, c3, c4, c5)</codeblock>Let’s
                consider sample queries that can benefit from this optimization and the queries that
                cannot.</p><p><b>Positive Case examples of queries that use indexing grouping and
                    aggregation:</b><ul id="ul_fmx_sqq_xcb">
                    <li><codeph>SELECT COUNT(*) FROM customer WHERE c1 > 10;</codeph></li>
                    <li><codeph>SELECT COUNT(c1) FROM customer WHERE c1 between 10 and
                        30;</codeph></li>
                    <li><codeph>SELECT COUNT(c2) FROM customer WHERE c1 between 10 and 30 and c2 =
                            40;</codeph></li>
                    <li><codeph>SELECT c1, AVG(c5), sum(c4), COUNT(c1), MIN (c3), MAX(ABS(c3)) WHERE
                            c1 > 100 GROUP BY c1;</codeph></li>
                    <li><codeph>SELECT c2count , SUM(c4) WHERE c1 > 100 GROUP BY c1 LETTING c2count
                            = COUNT(c2) HAVING c2count > 1;</codeph></li>
                </ul></p><p><b>Negative Case examples:</b><ul id="ul_p3p_drq_xcb">
                    <li><codeph>SELECT COUNT(*) FROM customer WHERE c2 > 20;</codeph><ul
                            id="ul_syp_2rq_xcb">
                            <li>This query has no predicate on the leading key c1. The index
                                    <codeph>idx</codeph> cannot be used.</li>
                        </ul></li>
                    <li><codeph>SELECT COUNT(*) FROM customer;</codeph><ul id="ul_kc1_grq_xcb">
                            <li>This query has no predicate at all.</li>
                        </ul></li>
                    <li><codeph>SELECT COUNT(v1) FROM customer LET v1 = ROUND(c2) WHERE c1 >
                            10;</codeph><ul id="ul_mwm_hrq_xcb">
                            <li>The aggregate depends on <codeph>LET</codeph> variable.</li>
                        </ul></li>
                    <li><codeph>SELECT ARRAY_AGG(c1) FROM customer WHERE c1 > 10;</codeph><ul
                            id="ul_af2_jrq_xcb">
                            <li><codeph>ARRAY_AGG</codeph> is not supported.</li>
                        </ul></li>
                </ul></p><p><b>Positive query examples with GROUP BY on leading index
                keys</b></p><p>Consider the following
                index:<codeblock>CREATE INDEX idx ON customer(a, b, c, d, e)</codeblock>In the
                following query, the GROUP BY keys<codeph> (a, b) </codeph>are the leading keys of
                the index, so the index is naturally ordered and grouped by the order of the index
                key definition. Therefore, the query below is suitable for indexer to handle
                grouping and
                aggregation.<codeblock>SELECT a, b, SUM(c), AVG(e), COUNT(DISTINCT c)
FROM customer
WHERE a BETWEEN “AZ” AND “CA” 
GROUP BY a, b
HAVING SUM(c) > 1000;</codeblock>Here's
                the executed query plan showing that index scan handled grouping and
                aggregation:</p><image href="images/GBAP_PosEx_QP.png" id="image_lqb_41r_xcb"/><p><b
                    id="docs-internal-guid-c3d7738b-b0d1-f78b-9de2-09a4baf058a5">Positive query
                    examples with GROUP BY on non-leading index keys</b></p><p>Consider the
                following index and
                query:<codeblock>CREATE INDEX idx ON customer(a, b, c, d, e)

SELECT b, d, SUM(c), AVG(e)
FROM customer
WHERE a BETWEEN “AZ” AND “CA” 
GROUP BY b, d
HAVING SUM(c) > 1000;</codeblock>The
                following is a bottom-up rendering of the execution plan for easier viewing. In this
                case, the indexer sends partial group aggregation, which the query merges to create
                the final group and aggregation. In this scenario (when the grouping is on
                non-leading keys), any query with aggregation and DISTINCT modifier cannot be
                accelerated by the indexer, such as <codeph>COUNT(DISTINCT e)</codeph>.</p><p><image
                    href="images/GBAP_BottomUp_GB_non-leading.png" id="image_bpw_c1w_xcb"
                    height="750"/></p><p><b
                    id="docs-internal-guid-4376996d-b457-baf4-35a7-55c27622ed76">Positive query
                    examples on array indexes with GROUP BY on leading index keys</b></p><p>Consider
                the following index and
                query:<codeblock>SELECT a,b, SUM(d), AVG(e)
FROM customer
WHERE a BETWEEN “AZ” AND “CA”  
 AND b > 500
 AND ANY v IN array1 SATISFIES  v = “XYZ” END
GROUP BY a,b
HAVING SUM(d) > 1000;</codeblock>In
                this case, the predicates are on the leading keys up to and including the array key.
                Therefore, indexer can efficiently do the grouping as seen by the optimal plan
                below. It’s important to note the array index key is created with a
                    <codeph>DISTINCT</codeph> modifier (not the <codeph>ALL</codeph> modifier) to
                get this optimization and that the <codeph>SATISFIES</codeph> clause in the
                    <codeph>ANY</codeph> predicate must be that of equality (that is, <codeph>v =
                    “XYZ”</codeph>).</p><image href="images/GBAP_leadingkey_arraykey.png"
                id="image_xlp_4cw_xcb"/><p>On the other hand, if there’s a predicate missing on b,
                which is prior to the array key, the grouping is done by the old
                method:<codeblock>CREATE INDEX idx_array ON customer(a, b, DISTINCT array1, d, e)

SELECT a,b, SUM(d), AVG(e)
FROM customer
WHERE a between "AZ" AND "CA"               
 AND ANY v IN array1 SATISFIES  v = "XYZ" END
GROUP BY a,b
HAVING SUM(d) > 1000;</codeblock></p><image
                href="images/GBAP_LeadingKey_OldMethod.png" id="image_ggn_ycw_xcb"/><p>Consider the
                index and
                query:<codeblock>CREATE INDEX idx_all_array ON customer(ALL array2, a, b, d, e)

SELECT p,c.a, SUM(p), AVG(c.a)
FROM customer AS c UNNEST c.array2 AS p
WHERE p > 10             
GROUP BY p, c.a;</codeblock>In
                this case, the <codeph>UNNEST</codeph> operation can use the index because the
                leading <codeph>ALL</codeph> array key is the array being unwound. Note, the unwound
                operation repeats the parent document (<codeph>customer</codeph>) and the
                    <codeph>c.a</codeph> reference would have duplicates compared to the original
                    <codeph>customer</codeph> documents.</p><p><image
                    href="images/GBAP_Unnest_All_ArrayKey.png" id="image_ghz_q2w_xcb"/></p><p><b
                    id="docs-internal-guid-3c74c5b0-b46f-0a48-66b0-058d528fa9c2">Query qualification
                    and pushdown</b></p><p>Not every GROUP BY and aggregate query can be handled by
                the indexer. Following are some simple rules that will help you to write the proper
                queries and design the required indexes to get the most of this feature.</p><p>The
                following are necessary in order for an indexer to execute GROUP BY and
                    aggregates:<ul id="ul_rm2_xdw_xcb">
                    <li>All the query predicates are able to convert into ranges and able to push to
                        indexer.</li>
                    <li>The whole query must be covered by an index.<ul id="ul_epn_ydw_xcb">
                            <li>For a query to be covered by an index, every attribute referenced in
                                the query should be in one index.</li>
                            <li>Query should not have operations such as joins, subquery, or derived
                                table queries.</li>
                        </ul></li>
                    <li>GROUP BY keys and Aggregate expressions must be one of the following:<ul
                            id="ul_mtn_12w_xcb">
                            <li>Index keys or document key</li>
                            <li>An expression based on index keys or document key</li>
                        </ul></li>
                    <li>GROUP BY and aggregate expressions must be simple.</li>
                </ul></p></section>
        <section id="section_khk_52w_xcb">
            <title>Scenarios for Group By and Aggregation</title>
            <p>Like any feature in a query language, there are subtle variations between each query
                and index that affects this optimization. We use the <codeph>travel-sample</codeph>
                dataset to illustrate both positive and negative use cases.</p>
            <p>The following table lists the scenarios and requirements for queries to request the
                indexer to do the grouping and acceleration. When the requirements are unmet, the
                query will fetch the relevant data and then do the grouping and acceleration as
                usual. No application changes are necessary. The query plan generated reflects this
                decision.</p>
            <p>
                <dl>
                    <dlentry>
                        <dt>GROUP BY Scenarios:</dt>
                        <dd>1. GROUP BY on leading keys</dd>
                        <dd>2. GROUP BY on non-leading keys</dd>
                        <dd>3. GROUP BY keys in different CREATE INDEX order</dd>
                        <dd>4. GROUP BY on expression</dd>
                        <dd>5. Heterogeneous data types for GROUP BY key</dd>
                        <dd>6. GROUP BY META().id Primary Index</dd>
                        <dd>7. LIMIT with GROUP BY on leading keys</dd>
                        <dd>8. OFFSET with GROUP BY on leading keys</dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Aggregate Scenarios:</dt>
                        <dd>9. Aggregate without GROUP BY</dd>
                        <dd>10. Expression in Aggregate function</dd>
                        <dd>11. SUM, COUNT, MIN, MAX, or AVG Aggregate function</dd>
                        <dd>12. HAVING with an aggregate function inside</dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Aggregate on Array Index Scenarios:</dt>
                        <dd>13. Aggregate on non-array index field</dd>
                        <dd>14. </dd>
                    </dlentry>
                </dl>
            </p>
            <p>GROUP BY Scenarios:<table frame="none" rowsep="0" colsep="0" id="table_zjq_t3w_xcb">
                    <tgroup cols="2" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="30*"/>
                        <tbody>
                            <row>
                                <entry>1.</entry>
                                <entry>GROUP BY on leading keys</entry>
                            </row>
                            <row>
                                <entry>2.</entry>
                                <entry>GROUP BY on non-leading keys</entry>
                            </row>
                            <row>
                                <entry>3.</entry>
                                <entry>GROUP BY keys in different CREATE INDEX order</entry>
                            </row>
                            <row>
                                <entry>4.</entry>
                                <entry>GROUP BY on expression</entry>
                            </row>
                            <row>
                                <entry>5.</entry>
                                <entry>Heterogeneous data types for GROUP BY key</entry>
                            </row>
                            <row>
                                <entry>6.</entry>
                                <entry>GROUP BY META().id Primary Index</entry>
                            </row>
                            <row>
                                <entry>7.</entry>
                                <entry>LIMIT with GROUP BY on leading keys</entry>
                            </row>
                            <row>
                                <entry>8.</entry>
                                <entry>OFFSET with GROUP BY on leading keys</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>Aggregate Scenarios:<table frame="none" rowsep="0" colsep="0"
                    id="table_s5v_cjw_xcb">
                    <tgroup cols="2" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="30*"/>
                        <tbody>
                            <row>
                                <entry>9.</entry>
                                <entry>Aggregate without GROUP BY</entry>
                            </row>
                            <row>
                                <entry>10.</entry>
                                <entry>Expression in Aggregate function</entry>
                            </row>
                            <row>
                                <entry>11.</entry>
                                <entry>SUM, COUNT, MIN, MAX, or AVG Aggregate function</entry>
                            </row>
                            <row>
                                <entry>12.</entry>
                                <entry>HAVING with an aggregate function inside</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>Aggregate on Array Index Scenarios:<table frame="none" rowsep="0" colsep="0"
                    id="table_mvd_pkw_xcb">
                    <tgroup cols="2" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="30*"/>
                        <tbody>
                            <row>
                                <entry>13.</entry>
                                <entry>Aggregate on non-array index field</entry>
                            </row>
                            <row>
                                <entry>14.</entry>
                                <entry>Aggregate on array index field</entry>
                            </row>
                            <row>
                                <entry>15.</entry>
                                <entry>DISTINCT Aggregate on non-array index field</entry>
                            </row>
                            <row>
                                <entry>16.</entry>
                                <entry>DISTINCT Aggregate on array index field</entry>
                            </row>
                            <row>
                                <entry>17.</entry>
                                <entry>Array of arrays</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table></p>
            <p><b>1. GROUP BY on leading keys</b></p>
            <p>One of the common cases is to have both predicates and GROUP BY on leading keys of
                the index. First create the index so that the query is covered by the index. You can
                then think about the order of the keys.</p>
            <p>The query requires a predicate on leading keys to consider an index. The simplest
                predicate is <codeph>IS NOT MISSING</codeph>.
                    <codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>Keyspace_ref</varname>(<b><i>a</i></b>, b, c);

SELECT <b>a, b</b>, <varname>Aggregate_Function</varname>(c)  /* MIN(c), MAX(c), COUNT(c), or SUM(c) */
FROM <varname>Keyspace_ref</varname>
WHERE <b><i>a</i></b> IS NOT MISSING              /* 1st <b><i>index</i></b> field must be in a WHERE clause */
GROUP BY <b>a, b</b>;</codeblock><b>Example
                    1:</b> List the cities with the landmarks with the highest latitude.</p>
            <p>Use the <codeph>MAX()</codeph> aggregate to find the highest landmark latitude in
                each state, group the results by <codeph>country</codeph> and
                <codeph>state</codeph>, and then sort in reverse order by the highest latitudes per
                    <codeph>state</codeph>.<codeblock>CREATE INDEX idx1 ON `travel-sample`(country, state, geo.lat) 
WHERE type="landmark";

SELECT country, state, MAX(ROUND(geo.lat)) AS Max_Latitude
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "landmark"
GROUP BY country, state
ORDER BY Max_Latitude DESC;</codeblock>In
                this query, we need to give the predicate<codeph> country IS NOT MISSING
                </codeph>(or any WHERE clause) to ensure this index is selected for the query.
                Without a matching predicate, the query will use the primary index.</p>
            <p>Results:<codeblock>[
  {
    "Max_Latitude": 60,
    "country": "United Kingdom",
    "state": null
  },
  {
    "Max_Latitude": 51,
    "country": "United Kingdom",
    "state": "England"
  },
  {
    "Max_Latitude": 50,
    "country": "France",
    "state": "Picardie"
  },
...</codeblock>The
                Example 1 EXPLAIN Plan shows that <codeph>GROUP BY</codeph> is executed by the
                indexer and is detailed in the
                <?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?>GROUP BY Query
                Plan
                table<?oxy_custom_end?>:<codeblock>{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
<b>            "#operator": "IndexScan3",</b>
            "covers": [
              "cover ((`travel-sample`.`country`))",
              "cover ((`travel-sample`.`state`))",
              "cover (((`travel-sample`.`geo`).`lat`))",
              "cover ((meta(`travel-sample`).`id`))",
              "cover (count(cover ((`travel-sample`.`country`))))",
              "cover (min(round(cover (((`travel-sample`.`geo`).`lat`)))))"
            ],
            "filter_covers": {
              "cover ((`travel-sample`.`type`))": "landmark"
            },
<b>            "index": "idx1",</b>
            "index_group_aggs": {
              "aggregates": [
                {
                  "aggregate": "MAX",
                  "depends": [
                    2
                  ],
                  "expr": "round(cover (((`travel-sample`.`geo`).`lat`)))",
                  "id": 4,
                  "keypos": -1 
                }
              ],
              "depends": [
                0,
                1,
                2
              ],
              "group": [
                {
                  "depends": [
                    0
                  ],
                  "expr": "cover ((`travel-sample`.`country`))",
                  "id": 0,
                  "keypos": 0
                },
                {
                  "depends": [
                    1
                  ],
                  "expr": "cover ((`travel-sample`.`state`))",
                  "id": 1,
                  "keypos": 1
                }
              ]
            },
...</codeblock></p>
            <p><b id="docs-internal-guid-b944b625-b4b7-85b3-0987-2afeb4f88289">2. GROUP BY on
                    non-leading keys</b></p>
            <p>When using GROUP BY on a non-leading key:<ul id="ul_c1d_5nw_xcb">
                    <li>The indexer will return <i>pre-aggregated</i> results.</li>
                    <li>Results can have duplicate or out-of-order groups. The N1QL indexer will do
                        2nd level of aggregation and compute the final result.</li>
                    <li>The N1QL indexer can pushdown only if the leading key has a predicate.</li>
                </ul>To use Aggregate Pushdown, use the below index and query
                    syntaxes:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>Keyspace_ref</varname>(<i>a, <b>b, c</b></i>);</codeblock><b>Syntax
                    A:</b><codeblock>SELECT <varname>Aggregate_Function</varname>(<varname>a</varname>), <b><i>b</i></b>, A<varname>ggregate_Function</varname>(<b><i>c</i></b>) 
FROM <varname>Keyspace_ref</varname>
WHERE <varname>a</varname> IS NOT MISSING
GROUP BY <i><b>b</b></i>;</codeblock><b>Syntax
                    B:</b><codeblock>SELECT <varname>Aggregate_Function</varname>(a), <varname>Aggregate_Function</varname>(<b><i>b</i></b>), <b><i>c</i></b> 
FROM <varname>Keyspace_ref</varname>
WHERE a IS NOT MISSING
GROUP BY <b><i>c</i></b>;</codeblock><b>Example
                    2 (A):</b> List the states with their total number of landmarks and the lowest
                latitude of any landmark.</p>
            <p>Use the <codeph>COUNT()</codeph> operator to find the total number of landmarks and
                use the <codeph>MIN()</codeph> operator to find the lowest landmark latitude in each
                state, group the results by <codeph>state</codeph>, and then sort in order by the
                lowest latitudes per
                <codeph>state</codeph>.<codeblock>CREATE INDEX idx2 ON `travel-sample`(country, state, ROUND(geo.lat)) 
WHERE type="landmark";

SELECT COUNT(country) AS Total_landmarks, <b>state, MIN(ROUND(geo.lat)) AS Min_Latitude</b>
FROM `travel-sample`
WHERE country IN ["France", "United States", "United Kingdom"]
AND type = "landmark"
GROUP BY state
ORDER BY Min_Latitude;</codeblock>Explain
                Plan:</p>
            <p><image href="images/GBAP_Ex2A_EP.png" id="image_l3d_gvx_xcb"
                    /><codeblock>{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
            "#operator": "IndexScan3",
            "covers": [
              "cover ((`travel-sample`.`country`))",
              "cover ((`travel-sample`.`state`))",
              "cover (((`travel-sample`.`geo`).`lat`))",
              "cover ((meta(`travel-sample`).`id`))",
              "cover (count(cover ((`travel-sample`.`country`))))",
              "cover (min(round(cover (((`travel-sample`.`geo`).`lat`)))))"
            ],
            "filter_covers": {
              "cover ((`travel-sample`.`type`))": "landmark"
            },
            "index": "idx2",
            "index_group_aggs": {
             <b> "aggregates": [
                {
                  "aggregate": "COUNT",
                  "depends": [
                    0
                  ],
                  "expr": "cover ((`travel-sample`.`country`))",
                  "id": 4,
                  "keypos": 0
                },
                {
                  "aggregate": "MIN",
                  "depends": [
                    2
                  ],
                  "expr": "round(cover (((`travel-sample`.`geo`).`lat`)))",
                  "id": 5,
                  "keypos": -1</b>
                }
              ],
              "depends": [
                0,
                1,
                2
              ],
             <b> "group": [
                {
                  "depends": [
                    1
                  ],
                  "expr": "cover ((`travel-sample`.`state`))",
                  "id": 1,
                  "keypos": 1</b>
                }
              ],
             <b> "partial": true</b>
            },
...</codeblock><note>The
                        <codeph>"partial": true</codeph> line means it was
                    pre-aggregated.</note>Results:<codeblock>[
  {
    "Min_Latitude": 33,
    "Total_landmarks": 1900,
    "state": "California"
  },
  {
    "Min_Latitude": 41,
    "Total_landmarks": 8,
    "state": "Corse"
  },
  {
    "Min_Latitude": 43,
    "Total_landmarks": 6,
    "state": "Languedoc-Roussillon"
  },
...</codeblock><b>Example
                    2 (B):</b> List the number of landmarks by latitude and the state it's in.</p>
            <p>Use <codeph>COUNT(country)</codeph> for the total number of landmarks at each
                latitude. At a particular latitude, the <codeph>state</codeph> will be the same; but
                an aggregate function on it is needed, so <codeph>MIN()</codeph> or
                    <codeph>MAX()</codeph> is used to return the original
                    value.<codeblock>SELECT COUNT(country) Num_Landmarks, MIN(state) State_Name, ROUND(geo.lat) Latitude
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "landmark"
GROUP BY ROUND(geo.lat)
ORDER BY ROUND(geo.lat);</codeblock>Results:<codeblock>[
  {
    "Latitude": 33,
    "Num_Landmarks": 227,
    "State_Name": "California"
  },
  {
    "Latitude": 34,
    "Num_Landmarks": 608,
    "State_Name": "California"
  },
  {
    "Latitude": 35,
    "Num_Landmarks": 27,
    "State_Name": "California"
  },
...</codeblock><b
                    id="docs-internal-guid-3e3d5b1a-b5b6-ef35-da76-906170103e59">3. GROUP BY keys in
                    different CREATE INDEX order</b></p>
            <p>When using GROUP BY on keys in a different order than they appear in the CREATE INDEX
                statement, use the following
                    syntax:<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>Keyspace_ref</varname>(<i>a, b, c</i>);

SELECT <varname>Aggregate_Function</varname>(<b><i>c</i></b>) 
FROM <varname>Keyspace_ref</varname>
WHERE a IS NOT MISSING
GROUP BY <i><b>b, a</b></i>;</codeblock><b>Example
                    3:</b> Like Example 1 with the GROUP BY fields swapped, list the landmarks with
                the lowest longitude.</p>
            <p>Use the <codeph>MIN()</codeph> operator to find the lowest landmark longitude in each
                city, group the results by <codeph>activity</codeph> and <codeph>city</codeph>, and
                then sort in reverse order by the lowest longitudes per
                    <codeph>activity</codeph>.<codeblock>CREATE INDEX idx3 ON `travel-sample`(activity, city, geo.lon) 
WHERE type="landmark";

SELECT activity, city, MIN(ROUND(geo.lon)) AS Max_Longitude
FROM `travel-sample`
WHERE country IS NOT MISSING
AND type = "landmark"
GROUP BY activity, city
ORDER BY Min_Longitude;</codeblock>Results:<codeblock>[
  {
    "Min_Longitude": -124,
    "activity": "buy",
    "city": "Eureka"
  },
  {
    "Min_Longitude": -123,
    "activity": "drink",
    "city": "Glen Ellen"
  },
  {
    "Min_Longitude": -123,
    "activity": "do",
    "city": "Santa Rosa"
  },
  {
    "Min_Longitude": -123,
    "activity": "eat",
    "city": "Moss Beach"
  },
...</codeblock><b
                    id="docs-internal-guid-9640b8bb-b679-d376-cf13-9a0dd1211391">4. GROUP BY on
                    expression</b></p>
            <p>When grouping on an expression or operation, the indexer will return pre-aggregated
                results whenever the GROUP BY and leading index keys are not an exact match.</p>
            <p>To use Aggregate Pushdown and avoid pre-aggregated results, use one of the two below
                index and query combinations:</p>
            <p><b>Syntax A: Field with an expression</b> (GROUP BY and Index keys
                    match)<codeblock>CREATE INDEX <varname>idx_expr</varname> ON <varname>Keyspace_ref</varname>(<i><b>a+b</b>, b, c</i>);

SELECT <varname>Aggregate_Function</varname>(<varname>c</varname>) 
FROM <varname>Keyspace_ref</varname>
WHERE a IS NOT MISSING
GROUP BY <i><b>a+b</b></i>;</codeblock><b>Syntax
                    B: Operation on a field </b>(GROUP BY and Index keys
                match)<codeblock>CREATE INDEX <varname>idx_operation</varname> ON <varname>Keyspace_ref</varname> (<i><b>LOWER(a)</b>, b, c</i>);

SELECT <varname>Aggregate_Function</varname>(<i>c</i>) 
FROM <varname>Keyspace_ref</varname>
WHERE a IS NOT MISSING
GROUP BY <i><b>LOWER(a)</b></i>;</codeblock>For
                comparison, the below index and query combination will yield pre-aggregated
                results.</p>
            <p><b>Pre-aggregated Syntax: </b>The GROUP BY and Index keys don't match.</p>
        </section>
    </body>
</topic>
