<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="groupby-aggregate-performance">
    <title>Group By and Aggregate Performance</title>
    <shortdesc>N1QL Pushdowns optimize the performance of N1QL queries by supporting GROUP BY and Aggregate expressions.</shortdesc>
    <body>
        <p><i>(Introduced in Couchbase Server 5.5 - Enterprise Edition)</i></p>
        <section id="section_hj3_vcq_xcb">
            <title>Overview</title>
            <p>This features improves performance of N1QL queries with aggregations and GROUP BY
                execution. </p>
            <p>After the optimizer selects an index for a query block, it attempts the two
                optimizations below:<ul id="ul_pkn_zcq_xcb">
                    <li>Pagination optimization, by pushing the OFFSET and LIMIT parameters to the
                        index scan.</li>
                    <li>Grouping and aggregation pushdown to the indexer (introduced in Couchbase
                        5.5).</li>
                </ul>Prior to Couchbase 5.5, even when a query with aggregate and/or GROUP BY is
                covered by an index, the query fetched all relevant data from the indexer and group
                the data within the query engine. With this enhancement, the query intelligently
                requests the indexer to perform grouping and aggregation in addition to range scan.
                The Indexer has been enhanced to perform grouping, COUNT(), SUM(), MIN(), MAX(),
                AVG(), and related operations.</p>
            <p>This requires no changes to the user query, but a good index design to cover the
                query and order the keys is required. Not every query will benefit from this
                optimization, and not every index can accelerate every grouping and aggregation.
                Understanding the right patterns will help you to design your indexes and queries.
                Aggregate Pushdown to the global secondary index is supported on both storage
                engines: Standard GSI and Memory Optimized GSI (MOI).</p>
            <p>This reduction step of performing the GROUP BY and Aggregation on the indexer reduces
                the amount of data transfer and disk I/O, resulting in:<ul id="ul_cnz_fdq_xcb">
                    <li>Improved query response time</li>
                    <li>Improved resource utilization</li>
                    <li>Low latency</li>
                    <li>High scalability</li>
                    <li>Low TCO</li>
                </ul>For example, let's compare the previous vs. current performance of using GROUP
                BY and examine the EXPLAIN plan of the following query that is defined in the
                Couchbase <codeph>travel-sample</codeph>
                index:<codeblock>CREATE INDEX `def_type` ON `travel-sample`(`type`) </codeblock>Consider
                the
                query:<codeblock>SELECT type, COUNT(type)
FROM `travel-sample`
WHERE type IS NOT MISSING
GROUP BY type;</codeblock>Before
                Couchbase version 5.5, this query engine fetched relevant data from the indexer and
                group the data within the query engine and then aggregate. This simple query takes
                about 250 ms.</p>
            <p><image href="images/GBAP_Ex0_QP_before55.png" id="image_lnh_v4q_xcb"/></p>
            <p>Now, in Couchbase version 5.5, this query use the same <codeph>def_type</codeph>
                index, but executes in under 70 ms. In the explain below, you can see fewer steps
                and the lack of the grouping step after the index scan because the index scan step
                does the grouping and aggregation as well.</p>
            <p><image href="images/GBAP_Ex0_QP_after55.png" id="image_bln_w4q_xcb" scale="70"/></p>
            <p>As the data and query complexity grows, the performance benefit (both latency and
                throughput) will grow as well.</p>
            <p>For example, consider the
                query:<codeblock>SELECT type, COUNT(type)
FROM `travel-sample`
WHERE type IS NOT MISSING
GROUP BY type;</codeblock></p>
            <p>The text explain plan shows the accelerated aggregation details. For details, see the
                <?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?>Query Plan
                Explained<?oxy_custom_end?>
                section.<codeblock>...
        "index_group_aggs": {
          "aggregates": [
            {
              "aggregate": "COUNT",
              "expr": "1",
              "id": 2,
              "keypos": -1
            }
          ],
          "depends": [
            0
          ],
          "group": [
            {
              "depends": [
                0
              ],
              "expr": "cover ((`travel-sample`.`type`))",
              "id": 0,
              "keypos": 0
            }
          ]
        },
        "index_id": "c5bbb792c69c1704",
        "index_projection": {
          "entry_keys": [
            0,
            2
          ]
        },
...</codeblock>Here’s
                is how this query executes when the indexer executes the GROUP BY and aggregation.
                The query engine does not fetch any data from the data service (KV service), as
                shown below:</p>
            <p><image href="images/GBAP_55execution.png" id="image_ngr_kzv_xcb" scale="70"
                    height="700" width="700"/></p>
            <p>For your reference, this is how the same query executed before 5.5.</p>
            <p><image href="images/GBAP_pre55execution.png" id="image_pbg_4zv_xcb" height="700"
                /></p>
        </section>
        <section id="section_fw5_ypq_xcb"><title>Examples for Indexer GROUP BY and
                Aggregation</title><p>Let’s Consider a composite index to explore some
                scenarios:<codeblock>CREATE INDEX idx ON customer(c1, c2, c3, c4, c5)</codeblock>Let’s
                consider sample queries that can benefit from this optimization and the queries that
                cannot.</p><p><b>Positive Case examples of queries that use indexing grouping and
                    aggregation:</b><ul id="ul_fmx_sqq_xcb">
                    <li><codeph>SELECT COUNT(*) FROM customer WHERE c1 > 10;</codeph></li>
                    <li><codeph>SELECT COUNT(c1) FROM customer WHERE c1 between 10 and
                        30;</codeph></li>
                    <li><codeph>SELECT COUNT(c2) FROM customer WHERE c1 between 10 and 30 and c2 =
                            40;</codeph></li>
                    <li><codeph>SELECT c1, AVG(c5), sum(c4), COUNT(c1), MIN (c3), MAX(ABS(c3)) WHERE
                            c1 > 100 GROUP BY c1;</codeph></li>
                    <li><codeph>SELECT c2count , SUM(c4) WHERE c1 > 100 GROUP BY c1 LETTING c2count
                            = COUNT(c2) HAVING c2count > 1;</codeph></li>
                </ul></p><p><b>Negative Case examples:</b><ul id="ul_p3p_drq_xcb">
                    <li><codeph>SELECT COUNT(*) FROM customer WHERE c2 > 20;</codeph><ul
                            id="ul_syp_2rq_xcb">
                            <li>This query has no predicate on the leading key c1. The index
                                    <codeph>idx</codeph> cannot be used.</li>
                        </ul></li>
                    <li><codeph>SELECT COUNT(*) FROM customer;</codeph><ul id="ul_kc1_grq_xcb">
                            <li>This query has no predicate at all.</li>
                        </ul></li>
                    <li><codeph>SELECT COUNT(v1) FROM customer LET v1 = ROUND(c2) WHERE c1 >
                            10;</codeph><ul id="ul_mwm_hrq_xcb">
                            <li>The aggregate depends on <codeph>LET</codeph> variable.</li>
                        </ul></li>
                    <li><codeph>SELECT ARRAY_AGG(c1) FROM customer WHERE c1 > 10;</codeph><ul
                            id="ul_af2_jrq_xcb">
                            <li><codeph>ARRAY_AGG</codeph> is not supported.</li>
                        </ul></li>
                </ul></p><p><b>Positive query examples with GROUP BY on leading index
                keys</b></p><p>Consider the following
                index:<codeblock>CREATE INDEX idx ON customer(a, b, c, d, e)</codeblock>In the
                following query, the GROUP BY keys<codeph> (a, b) </codeph>are the leading keys of
                the index, so the index is naturally ordered and grouped by the order of the index
                key definition. Therefore, the query below is suitable for indexer to handle
                grouping and
                aggregation.<codeblock>SELECT a, b, SUM(c), AVG(e), COUNT(DISTINCT c)
FROM customer
WHERE a BETWEEN “AZ” AND “CA” 
GROUP BY a, b
HAVING SUM(c) > 1000;</codeblock>Here's
                the executed query plan showing that index scan handled grouping and
                aggregation:</p><image href="images/GBAP_PosEx_QP.png" id="image_lqb_41r_xcb"/><p><b
                    id="docs-internal-guid-c3d7738b-b0d1-f78b-9de2-09a4baf058a5">Positive query
                    examples with GROUP BY on non-leading index keys</b></p><p>Consider the
                following index and
                query:<codeblock>CREATE INDEX idx ON customer(a, b, c, d, e)

SELECT b, d, SUM(c), AVG(e)
FROM customer
WHERE a BETWEEN “AZ” AND “CA” 
GROUP BY b, d
HAVING SUM(c) > 1000;</codeblock>The
                following is a bottom-up rendering of the execution plan for easier viewing. In this
                case, the indexer sends partial group aggregation, which the query merges to create
                the final group and aggregation. In this scenario (when the grouping is on
                non-leading keys), any query with aggregation and DISTINCT modifier cannot be
                accelerated by the indexer, such as <codeph>COUNT(DISTINCT e)</codeph>.</p><p><image
                    href="images/GBAP_BottomUp_GB_non-leading.png" id="image_bpw_c1w_xcb"
                    height="700"/></p><p><b
                    id="docs-internal-guid-4376996d-b457-baf4-35a7-55c27622ed76">Positive query
                    examples on array indexes with GROUP BY on leading index keys</b></p><p>Consider
                the following index and
                query:<codeblock>SELECT a,b, SUM(d), AVG(e)
FROM customer
WHERE a BETWEEN “AZ” AND “CA”  
 AND b > 500
 AND ANY v IN array1 SATISFIES  v = “XYZ” END
GROUP BY a,b
HAVING SUM(d) > 1000;</codeblock>In
                this case, the predicates are on the leading keys up to and including the array key.
                Therefore, indexer can efficiently do the grouping as seen by the optimal plan
                below. It’s important to note the array index key is created with a
                    <codeph>DISTINCT</codeph> modifier (not the <codeph>ALL</codeph> modifier) to
                get this optimization and that the <codeph>SATISFIES</codeph> clause in the
                    <codeph>ANY</codeph> predicate must be that of equality (that is, <codeph>v =
                    “XYZ”</codeph>).</p><image href="images/GBAP_leadingkey_arraykey.png"
                id="image_xlp_4cw_xcb"/><p>On the other hand, if there’s a predicate missing on b,
                which is prior to the array key, the grouping is done by the old
                method:<codeblock>CREATE INDEX idx_array ON customer(a, b, DISTINCT array1, d, e)

SELECT a,b, SUM(d), AVG(e)
FROM customer
WHERE a between "AZ" AND "CA"               
 AND ANY v IN array1 SATISFIES  v = "XYZ" END
GROUP BY a,b
HAVING SUM(d) > 1000;</codeblock></p><image
                href="images/GBAP_LeadingKey_OldMethod.png" id="image_ggn_ycw_xcb"/><p>Consider the
                index and
                query:<codeblock>CREATE INDEX idx_all_array ON customer(ALL array2, a, b, d, e)

SELECT p,c.a, SUM(p), AVG(c.a)
FROM customer AS c UNNEST c.array2 AS p
WHERE p > 10             
GROUP BY p, c.a;</codeblock>In
                this case, the <codeph>UNNEST</codeph> operation can use the index because the
                leading <codeph>ALL</codeph> array key is the array being unwound. Note, the unwound
                operation repeats the parent document (<codeph>customer</codeph>) and the
                    <codeph>c.a</codeph> reference would have duplicates compared to the original
                    <codeph>customer</codeph> documents.</p><p><image
                    href="images/GBAP_Unnest_All_ArrayKey.png" id="image_ghz_q2w_xcb"/></p><p><b
                    id="docs-internal-guid-3c74c5b0-b46f-0a48-66b0-058d528fa9c2">Query qualification
                    and pushdown</b></p><p>Not every GROUP BY and aggregate query can be handled by
                the indexer. Following are some simple rules that will help you to write the proper
                queries and design the required indexes to get the most of this feature.</p><p>The
                following are necessary in order for an indexer to execute GROUP BY and
                    aggregates:<ul id="ul_rm2_xdw_xcb">
                    <li>All the query predicates are able to convert into ranges and able to push to
                        indexer.</li>
                    <li>The whole query must be covered by an index.<ul id="ul_epn_ydw_xcb">
                            <li>For a query to be covered by an index, every attribute referenced in
                                the query should be in one index.</li>
                            <li>Query should not have operations such as joins, subquery, or derived
                                table queries.</li>
                        </ul></li>
                    <li>GROUP BY keys and Aggregate expressions must be one of the following:<ul
                            id="ul_mtn_12w_xcb">
                            <li>Index keys or document key</li>
                            <li>An expression based on index keys or document key</li>
                        </ul></li>
                    <li>GROUP BY and aggregate expressions must be simple.</li>
                </ul></p></section>
        <section id="section_khk_52w_xcb">
            <title>Scenarios for Group By and Aggregation</title>
            <p>Like any feature in a query language, there are subtle variations between each query
                and index that affects this optimization. We use the <codeph>travel-sample</codeph>
                dataset to illustrate both positive and negative use cases.</p>
            <p>The following table lists the scenarios and requirements for queries to request the
                indexer to do the grouping and acceleration. When the requirements are unmet, the
                query will fetch the relevant data and then do the grouping and acceleration as
                usual. No application changes are necessary. The query plan generated reflects this
                decision.</p>
            <p>GROUP BY Scenarios:<table frame="none" rowsep="0" colsep="0" id="table_zjq_t3w_xcb">
                    <tgroup cols="2" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="30*"/>
                        <tbody>
                            <row>
                                <entry>1.</entry>
                                <entry>GROUP BY on leading keys</entry>
                            </row>
                            <row>
                                <entry>2.</entry>
                                <entry>GROUP BY on non-leading keys</entry>
                            </row>
                            <row>
                                <entry>3.</entry>
                                <entry>GROUP BY keys in different CREATE INDEX order</entry>
                            </row>
                            <row>
                                <entry>4.</entry>
                                <entry>GROUP BY on expression</entry>
                            </row>
                            <row>
                                <entry>5.</entry>
                                <entry>Heterogeneous data types for GROUP BY key</entry>
                            </row>
                            <row>
                                <entry>6.</entry>
                                <entry>GROUP BY META().id Primary Index</entry>
                            </row>
                            <row>
                                <entry>7.</entry>
                                <entry>LIMIT with GROUP BY on leading keys</entry>
                            </row>
                            <row>
                                <entry>8.</entry>
                                <entry>OFFSET with GROUP BY on leading keys</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>Aggregate Scenarios:<table frame="none" rowsep="0" colsep="0"
                    id="table_s5v_cjw_xcb">
                    <tgroup cols="2" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="30*"/>
                        <tbody>
                            <row>
                                <entry>9.</entry>
                                <entry>Aggregate without GROUP BY</entry>
                            </row>
                            <row>
                                <entry>10.</entry>
                                <entry>Expression in Aggregate function</entry>
                            </row>
                            <row>
                                <entry>11.</entry>
                                <entry>SUM, COUNT, MIN, MAX, or AVG Aggregate function</entry>
                            </row>
                            <row>
                                <entry>12.</entry>
                                <entry>HAVING with an aggregate function inside</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>Aggregate on Array Index Scenarios:<table frame="none" rowsep="0" colsep="0"
                    id="table_mvd_pkw_xcb">
                    <tgroup cols="2" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="30*"/>
                        <tbody>
                            <row>
                                <entry>13.</entry>
                                <entry>Aggregate on non-array index field</entry>
                            </row>
                            <row>
                                <entry>14.</entry>
                                <entry>Aggregate on array index field</entry>
                            </row>
                            <row>
                                <entry>15.</entry>
                                <entry>DISTINCT Aggregate on non-array index field</entry>
                            </row>
                            <row>
                                <entry>16.</entry>
                                <entry>DISTINCT Aggregate on array index field</entry>
                            </row>
                            <row>
                                <entry>17.</entry>
                                <entry>Array of arrays</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table></p>
            <p><b>1. GROUP BY on leading keys</b></p>
            <p>One of the common cases is to have both predicates and GROUP BY on leading keys of
                the index. First create the index so that the query is covered by the index. You can
                then think about the order of the keys.</p>
            <p>The query requires a predicate on leading keys to consider an index. The simplest
                predicate is <codeph>IS NOT MISSING</codeph>.
                <codeblock>CREATE INDEX idx ON Keyspace(a, b, c);

SELECT a, b, Aggregate_Function(c)  /* MIN(c), MAX(c), COUNT(c), or SUM(c) */
FROM Keyspace
WHERE a IS NOT MISSING              /* 1st index field must be in a WHERE clause */
GROUP BY a, b;</codeblock></p>
        </section>
    </body>
</topic>
