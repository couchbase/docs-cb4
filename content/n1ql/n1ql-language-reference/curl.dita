<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="topic_8_8" xml:lang="en-US">
  <title id="title__Toc272567350">CURL Function</title>
  <conbody>
    <p>This function implements a subset of <xref href="https://en.wikipedia.org/wiki/CURL"
        format="html" scope="external">cURL</xref> functionality, and enables N1QL queries to
      interact and integrate with external JSON data sources available over HTTP/REST. This allows
      federated queries against external data sources such as <xref
        href="https://maps.googleapis.com" format="html" scope="external">Google geocoding
        API</xref>, <xref href="https://developer.yahoo.com/yql/guide/yql_url.html" format="html"
        scope="external">Yahoo API</xref>, <xref
        href="../../fts/full-text-intro.dita#topic_kp4_qth_t5">Couchbase Full text service</xref> or
      other Couchbase clusters. The federated queries can leverage full querying capabilities of
      N1QL, including functions, expressions, sub-queries, JOINs, NESTs, UNNESTs etc.</p>
    <p><codeph>CURL()</codeph> function can be used in various N1QL expressions and in various
      clauses of the DML statements such as projection, WHERE predicates, FROM data source etc. For
      example, this function can be used to integrate with Couchbase FTS and run fuzzy text searches
      in N1QL queries, or INSERT-SELECT statement to import external data into Couchbase Server.</p>
      
    <section id="section_vm2_vcw_1z">
      <title>Syntax</title>
      <p><codeph>CURL(request, url, [options])</codeph></p>
      <dl>
        <dlentry>
          <dt>Arguments</dt>
          <dd>
            <ul>
              <li><codeph>request</codeph> - is a string and is one of the supported HTTP request
                GET or POST methods.</li>
              <li><codeph>url</codeph> - is a string representing the URL of the data source.</li>
              <li><codeph>options</codeph> - is an optional JSON object representing various
                supported options. This includes options and parameters to be sent to the URL source
                endpoint.</li>
            </ul>
            <note>Currently all values passed to the arguments must be static values and cannot
              include any other N1QL functions or expressions that may have to be evaluated,
              including any references to documents or attributes.</note>
          </dd>
        </dlentry>
       <dlentry>
         <dt>Limitations</dt>
         <dd>
            <p>Any values passed to the arguments of <codeph>CURL()</codeph> must be static values.
              That means, they cannot include any references to names/aliases of documents or
              attributes in the documents, or any N1QL functions or expressions that may need to be
              evaluated. </p>
            <p>For example, check the following example:</p>
            <p>
              <codeblock>SELECT CURL(TO_UPPER(“POST”), b.url, { “data” : “address=”||b.data }) 
FROM bucket b;</codeblock>
            </p>
            <p>This example is invalid, because:</p>
            <ul id="ul_mjt_z1h_cz">
              <li dir="ltr">
                <p dir="ltr">for the first argument, <codeph>TO_UPPER()</codeph> function cannot be
                  evaluated.</p>
              </li>
              <li dir="ltr">
                <p dir="ltr">for the second argument, <codeph>b.url</codeph> refers to alias b and
                  attribute url in the document.</p>
              </li>
              <li dir="ltr">for the third argument, the string concatenation operator (||) cannot be
                evaluated.</li>
            </ul>
          </dd>
       </dlentry>
       <dlentry>
         
      <dt>Options</dt> 
          <dd>
            <table frame="all" rowsep="1" colsep="1" id="table_security_options">
              <title>Security Options</title>
              <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                <colspec colname="c2" colnum="2" colwidth="3.0*"/>
                <colspec colname="c3" colnum="3" colwidth="2.0*"/>
                <thead>
                  <row>
                    <entry>Option</entry>
                    <entry>Description</entry>
                    <entry>Value</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><codeph>user</codeph></entry>
                    <entry>Server username and password.</entry>
                    <entry>[:PASSWORD]USERNAME</entry>
                  </row>
                  <row>
                    <entry><codeph>basic</codeph></entry>
                    <entry>Use HTTP Basic Authentication.</entry>
                    <entry>Boolean</entry>
                  </row>
                  <row>
                    <entry><codeph>insecure</codeph></entry>
                    <entry>Allow connections to SSL sites without certificates (H).</entry>
                    <entry>Boolean</entry>
                  </row>
                  <row>
                    <entry><codeph>anyauth</codeph></entry>
                    <entry>CURL to figure out authentication method by itself, and use the most
                      secure one (this is basic only for now).</entry>
                    <entry>Boolean</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            <table frame="all" rowsep="1" colsep="1" id="table_transfer_options">
              <title>Transfer-related Options</title>
              <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                <colspec colname="c2" colnum="2" colwidth="3.0*"/>
                <colspec colname="c3" colnum="3" colwidth="2.0*"/>
                <thead>
                  <row>
                    <entry>Option</entry>
                    <entry>Description</entry>
                    <entry>Value</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><codeph>connect-timeout</codeph></entry>
                    <entry>The maximum time allowed for connection in seconds.</entry>
                    <entry>Integer<p>Example: <codeph>{"connect-timeout":30}</codeph></p></entry>
                  </row>
                  <row>
                    <entry><codeph>max-time</codeph></entry>
                    <entry>The maximum time allowed for the transfer in seconds.</entry>
                    <entry>Integer<p>Example: <codeph>{"max-time":30}</codeph></p></entry>
                  </row>
                  <row>
                    <entry><codeph>data</codeph></entry>
                    <entry>POST data to be sent to the HTTP/REST service. The string data should be
                      formatted exactly same as HTTP POST data.</entry>
                    <entry>String<p>Example:
                      <codeph>{"data":"address=Half+Moon+Bay"}</codeph></p></entry>
                  </row>
                  <row>
                    <entry><codeph>header</codeph></entry>
                    <entry>Passes custom header line to the server.</entry>
                    <entry>String<p>Example: <codeph>{"header":"Content-Type: application/json"}</codeph></p></entry>
                  </row>
                  <row>
                    <entry><codeph>show-error</codeph></entry>
                    <entry>Displays error message.</entry>
                    <entry>Boolean<p>Example: <codeph>{"show-error": true}</codeph></p></entry>
                  </row>
                  <row>
                    <entry><codeph>silent</codeph></entry>
                    <entry>The silent mode.</entry>
                    <entry>Boolean<p>Example: <codeph>{"silent": false}</codeph></p></entry>
                  </row>
                  <row>
                    <entry><codeph>keepalive-time</codeph></entry>
                    <entry>The number of seconds to wait between the keepalive probes.</entry>
                    <entry>Integer<p>Example: <codeph>{"keepalive-time":20}</codeph></p></entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </dd>
        </dlentry>
        <dlentry>
          <dt>Return Value</dt>
          <dd>This function returns either a single JSON object or multiple objects in an array.
            Returned by the HTTP/REST service at the URL. Note that, the result is expected to be
            JSON, and the function itself doesn’t do any additional processing. However, if the
            query parameter <codeph>pretty=true</codeph>, then the data received is in pretty
            format. It may result in errors or undefined behavior if the returned data from the URL
            is not well defined JSON.</dd>
        </dlentry>
      </dl>
    </section>
    <section id="section_l3z_kdw_1z">
      <title>Examples</title><p>The following examples are using CURL in the query projection list. </p>
      <p><b>Example 1:</b> The following N1QL query fetches details about the address “Half Moon
        Bay” using the <xref href="https://developers.google.com/maps/" format="html"
          scope="external">Google maps API</xref>. The Geocoding API from Google Maps allows you to
        convert static addresses into coordinates. (For more information refer to <xref
          href="https://developers.google.com/maps/documentation/geocoding/intro" format="html"
          scope="external">https://developers.google.com/maps/documentation/geocoding/intro</xref>)
        The corresponding <codeph>curl</codeph> command is also provided below.</p>
      <p>
        <codeblock>Curl Request:
curl https://maps.googleapis.com/maps/api/geocode/json?address=Half+Moon+Bay

Query:
SELECT CURL("GET","https://maps.googleapis.com/maps/api/geocode/json",
           {"data":"address=Half+Moon+Bay"} );
Results:
[
  {
    "$1": {
      "results": [
        {
          "address_components": [
            {
              "long_name": "Half Moon Bay",
              "short_name": "Half Moon Bay",
              "types": [
                "locality",
                "political"
              ]
            },
            {
              "long_name": "San Mateo County",
              "short_name": "San Mateo County",
              "types": [
                "administrative_area_level_2",
                "political"
              ]
            },
            {
              "long_name": "California",
              "short_name": "CA",
              "types": [
                "administrative_area_level_1",
                "political"
              ]
            },
            {
              "long_name": "United States",
              "short_name": "US",
              "types": [
                "country",
                "political"
              ]
            }
          ],
          "formatted_address": "Half Moon Bay, CA, USA",
          "geometry": {
            "bounds": {
              "northeast": {
                "lat": 37.5226389,
                "lng": -122.4165183
              },
              "southwest": {
                "lat": 37.4249286,
                "lng": -122.4778879
              }
            },
            "location": {
              "lat": 37.4635519,
              "lng": -122.4285862
            },
            "location_type": "APPROXIMATE",
            "viewport": {
              "northeast": {
                "lat": 37.5226389,
                "lng": -122.4165183
              },
              "southwest": {
                "lat": 37.4249286,
                "lng": -122.4774494
              }
            }
          },
          "place_id": "ChIJC8sZCqULj4ARVJvnNcic_V4",
          "types": [
            "locality",
            "political"
          ]
        }
      ],
      "status": "OK"
    }
  }
]</codeblock>
      </p><p><b>Example 2:</b> This is similar to Example 1, but following N1QL query fetches details about
        Santa Cruz in Spain using <xref href="https://developers.google.com/maps/" format="html"
          scope="external">Google geocoding API</xref> and extracts the ‘geometry’ field from the
        result. This query retrieves the address and geographic location bounds of the address,
        Santa Cruz, ES. We use the <codeph>address</codeph> and <codeph>components</codeph>
        parameters from the Geocoding API. The <codeph>data</codeph> option represents the HTTP POST
        data. </p>
      <p>
        <codeblock>Curl Request:
curl https://maps.googleapis.com/maps/api/geocode/json?address=santa+cruz&amp;components=country:ES

Query:
SELECT CURL("GET","https://maps.googleapis.com/maps/api/geocode/json",
           {"data":"address=santa+cruz&amp;components=country:ES"}).results[0].geometry;

Results:
[
  {
    "geometry": {
      "bounds": {
        "northeast": {
          "lat": 28.487616,
          "lng": -16.2356646
        },
        "southwest": {
          "lat": 28.4280248,
          "lng": -16.3370045
        }
      },
      "location": {
        "lat": 28.4636296,
        "lng": -16.2518467
      },
      "location_type": "APPROXIMATE",
      "viewport": {
        "northeast": {
          "lat": 28.487616,
          "lng": -16.2356646
        },
        "southwest": {
          "lat": 28.4280248,
          "lng": -16.3370045
        }
      }
    }
  }
]</codeblock>
      </p><p><b>Example 3:</b> This N1QL query shows how to JOIN two buckets on different Couchbase clusters.
        It is same as explained in the <xref href="selectintro.dita#topic_xwp_r3k_dx">JOIN
          Clause</xref> example, but with the left and right side buckets for the JOIN are in two
        different Couchbase clusters. </p>
      <p><ul id="ul_cvg_fks_bz">
          <li>The left side bucket <codeph>route</codeph> is the <codeph>`travel-sample`</codeph>
            route documents from cluster running on <codeph>hostname</codeph>. If you don’t have a
            second cluster running, you should substitute the <codeph>hostname</codeph> with
            127.0.0.1 or the IP-address of the local cluster. </li>
          <li>The right side bucket <codeph>airline</codeph> is the <codeph>`travel-sample`</codeph>
            airline documents in the local cluster.</li>
        </ul>Note that the results from the <codeph>CURL()</codeph> output are embedded in the
          <codeph>results[]</codeph> array under the bucket alias ‘t’ used in the remote query. So,
        we extract the result documents appropriately with the expression
          <codeph>CURL(...).results[*].t </codeph>and alias it to <codeph>route</codeph> as the left
        side bucket for the <codeph>JOIN</codeph>. </p>
      <p>
        <codeblock>Query:
SELECT DISTINCT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline
FROM CURL("POST", "http://hostname:8093/query/service", 
     {"data" : "statement=SELECT * FROM `travel-sample` t WHERE t.type = 'route'"
      }).results[*].t  route
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid 
WHERE airline.type = "airline" AND route.sourceairport = "SFO";

Results:

[
  {
    "airline": "B6",
    "callsign": "JETBLUE",
    "destinationairport": "AUS",
    "name": "JetBlue Airways",
    "stops": 0
  },
  {
    "airline": "B6",
    "callsign": "JETBLUE",
    "destinationairport": "BOS",
    "name": "JetBlue Airways",
    "stops": 0
  },
  ….
]</codeblock>
      </p><p><b>Example 4:</b> The following example shows how to use fuzzy search from the FTS service in a
        N1QL query. Assuming the FTS index <codeph>fts_travel</codeph> is created on the bucket
          <codeph>`travel-sample`</codeph>, running the following N1QL query finds all documents
        that have “sanfrancisco” anywhere in the document, using the full-text searching
        capabilities of the Couchbase FTS service. </p>
      <codeblock>Query:
SELECT result.hits[*].id
FROM CURL("POST","http://localhost:8094/api/index/fts_travel/query",
     {"header":"Content-Type: application/json",
      "user":"travel-sample:", 
      "data":{"explain":false,"fields": ["*"],"highlight": {},
              "query": {"query": "sanfrancisco"}}}) result;

Results:
[
  {
    "id": [
      "hotel_5843",
      "hotel_8712"
    ]
  }
  ]</codeblock><p><b>Example 5:</b> The following example uses the <codeph>CURL()</codeph> function with a WHERE
        clause. It uses the Yahoo finance API to find the day’s low value (i.e
          <codeph>DaysLow</codeph>) of HDP stock and finds all the documents in the
          <codeph>default</codeph> bucket that have ‘min_threshold’ attribute value greater than the
        DaysLow stock value. </p>
      <p>Insert the following documents into the <codeph>default</codeph> bucket, representing
        customers and their minimum thresholds, and then run the <codeph>SELECT</codeph> query: </p>
      <p>
        <codeblock>INSERT INTO default (KEY, VALUE)
  VALUES
     ("k1", 
         {"custID" : 12345, "min_threshold" : 4}), 
     ("k2", 
             {"custID" : 44444, "min_threshold" : 12});

Query:
SELECT ‘min_threshold’, 
       <b>meta</b>().id, 
       to_number(hdp_low) hdp_low 
FROM default 
USE KEYS [“k1”, “k2”]
LET hdp_low = curl("GET","https://query.yahooapis.com/v1/public/yql", {"data":"q=select%20*%20from%20yahoo.finance.quotes%20where%20symbol%20in%20(%22HDP%22)&amp;format=json&amp;diagnostics=true&amp;env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys&amp;callback="}).query.results.quote.DaysLow
WHERE to_number(hdp_low) &lt; min_threshold;

Results:

[
  {
    "hdp_low": 10.05,
    "id": "k2",
    "min_threshold": 12
  }
]</codeblock>
      </p>
    </section>
  </conbody>
</concept>
