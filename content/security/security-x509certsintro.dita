<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_cfk_mhn_xv">
  <title>
    X.509 for TLS
  </title> 
  
  <shortdesc>
    Couchbase Server uses X.509 certificates to encrypt Cross Data Center Replication
    (XDCR) and other client-server communications.
  </shortdesc>
  
  <body>
  
      <p>
        Couchbase Server Enterprise Edition supports X.509 certificates,
        for Transport Layer
        Security (TLS).
      </p>
    
      <p>
        With X.509 certificates, Couchbase Server can strongly encrypt 
        <xref href="http://developer.couchbase.com/documentation/server/4.1/xdcr/xdcr-intro.html" format="html" scope="external">Cross Data Center Replication</xref>
        and other client-server communications.</p>

      <p>
        Full administrators can manage certificates, using the Couchbase CLI
        tools (as described in <xref href="../cli/cbcli/couchbase-cli-ssl-manage.dita"/>) and REST
        API (as described in <xref href="../rest-api/rest-security.dita#reference_ytt_hdx_hv"/>).
      </p>

      <p>
        <image href="pict/ca_sys_diagram.png" id="image_gnp_5mk_y5" width="570"/>
      </p>
    
      <p>
        CA-based certificates can be managed and rotated without client downtime.
      </p>
    
      <p>
        The following overview of Couchbase certificate-management assumes the reader's
        prior knowledge of TLS/SSL, PKI certificates including X.509
        certificates, and Certificate Authorities (CAs).
      </p>
      
      <p>
        <b>When to Use X.509 Certificates</b>
      </p>
    
      <p>
        An X.509 certificate does more than just
        distribute the public key: it is signed by a trusted (internal or third-party) CA, and
        thereby verifies the identity of the server, assuring clients that their information is not being sent
        to a rogue server.
      </p>
    
      <p>
        Therefore, scenarios potentially requiring the use of X.509 certificates include:
      </p>
    
      <ul id="ul_j3z_b1k_1v">
        <li>
          In production, where clients have to go through the internet.
        </li>
        
        <li>
          When transferring sensitive data on the wire between application and Couchbase Server,
          or between data centers (XDCR).
        </li>
        
        <li>
          When mandated by compliance regulations.
        </li>
        
      </ul>
    
      <p>
        <b>CA Hierarchies Supported by Couchbase</b>
      </p>
    
      <p>
        Couchbase customers can associate Couchbase Server with their CA hierarchies. The 
        CA at the top
        of a hierarchy is called the root authority, or root CA. Two types of CA
        hierarchy are supported by Couchbase: single-tier and n-tier. 
      </p>
      
      <dl>
        <dlentry>
          <dt>Single-Tier Hierarchy</dt>
          <dd>In its simplest form, the single-tier hierarchy starts with a root CA. 
            <p>
              <image
            href="pict/ca_single_tier.png" id="image_my1_wmk_y5" align="left"/>
            </p>
            
            <p>
              In the case represented by the figure immediately above, the root CA is also the issuing CA. All
              certificates immediately below the root certificate inherit its trustworthiness, and
              can be used to secure systems. </p>
            
            <p>
              This is the simplest form of CA
              hierarchy: however, most enterprises use the more complex, N-tier CA hierarchy, as described next.
            </p>
          </dd>
        </dlentry>
      </dl>
      <dl>
        <dlentry>
          <dt>
            N-Tier Hierarchy
          </dt>
          <dd>
            In many production deployments, a hierarchy has multiple
            CAs.
            <p>
              <image href="pict/ca_n_tier.png" id="image_t1g_ymk_y5" align="left" width="570"/>
            </p>
          </dd>
          <dd>In a multi-tier hierarchy, the root CA issues certificates to the 
            intermediate CAs, which
            in turn generate <i>intermediate certificates</i>: these are used to sign client
            certificates, such as a cluster certificate:
            <ul>
              <li>Trusted root CA > Intermediate CA > Cluster certificate</li>
              <li>Trusted root CA > Intermediate CA 1 > Intermediate CA 2.... >
                Intermediate CA <i>n</i> > Cluster certificate </li>
            </ul>
            
            <p>
              When you need to regenerate the intermediate certificate, ensure
              that the chain can be verified up to the root CA. 
            </p>
            
            <p>
              All intermediate certificates should be installed on your server: otherwise, some clients
                will assume that the connection is not secure. This results in
                'untrusted' warnings like the following:</p><p><image
                  href="pict/back-to-safety.png" id="image_ofr_hg1_z5" align="left"
                  width="450"/>
                </p>
            
            <p>
              To avoid such warnings, a server should always provide a complete <i>trust
              chain</i>. The trust chain contains your certificate, concatenated with all
              intermediate certificates.</p>
          </dd>
        </dlentry>
      </dl>
    
   <section id="configuring-x.509">
  <title>Configuring X.509</title> 
  
    <p>
      This section explains how to configure X.509 certificates for TLS in 
      Couchbase Server. Note that choosing a root CA, the CA hierarchy, and obtaining a certificate 
      from that CA chain to set up a Couchbase cluster are not within the scope of this document.
    </p>
   
   <sectiondiv id="x509-bestpractices">
     <p><b>X.509 Certificate Requirements and Best Practices</b></p>
      <p>Here are the basic requirements for using X.509 certificates in Couchbase: </p>
      <ul>
        <li>The certificate must be in available in the <codeph>.pem</codeph> format.</li>
        <li>The certificate must be an RSA key certificate.</li>
        <li>The current system time must fall between the times set in the certificate's 
          properties
            <codeph>valid from</codeph> and <codeph>valid to</codeph>. </li>
        <li>Common name: This can be a certificate with a <codeph>nodename</codeph> 
          (preferable), IP
          address, URI (<codeph>www.example.com</codeph>), or URI with a 
          subject alternative name
          (SAN) certificate (<codeph>example.com</codeph> and <codeph>example.net</codeph>).
        </li>
        
        <li>The node certificate must be designated for server 
          authentication, by setting the optional
          field of the certificate's property <codeph>enhanced key usage</codeph> 
          to <codeph>Server Authentication</codeph>. 
        </li>
      </ul>
      
      <p>
        Recommended, best practices include:</p>
          
          <ul>
            <li>To avoid man-in-the-middle attacks, do not use wildcards with IP 
              addresses in the
          certificate common name.</li>
            <li>Use an RSA key-length of 2048 bits or higher. (As computing
          capabilities increase, longer RSA keys provide increased security.)</li>
          </ul>

      <p>The certificate chain must be valid from the node certificate up to the root 
        certificate: this can be verified using the <xref
          href="https://www.openssl.org/docs/manmaster/man1/verify.html" format="html"
          scope="external">OpenSSL validate certificate test</xref>. </p></sectiondiv>
   <sectiondiv id="validate-server-identity">
    <p>
      <b>Validating Server Identity</b>
    </p> 
      <p>The HTTPS specification mandates that HTTPS clients must be capable of verifying the
        identity of the server. This requirement can potentially affect how you generate your X.509
        certificates. The HTTPS specification defines a generic mechanism for verifying the server
        identity, known as the HTTPS URL integrity check, which is the standard mechanism used by
        Web browsers. 
      </p>
     
      <sectiondiv><b>HTTPS URL integrity check</b>
        <p>The basic idea of the URL integrity check is that the server certificate's identity must
          match the server hostname. This integrity check has an important impact on how you
          generate X.509 certificates for HTTPS: the certificate identity (usually the certificate
          subject DNâ€™s common name) must match the name of the host on which Couchbase Server is
          deployed. </p><p>The URL integrity check is designed to prevent man-in-the-middle attacks.
          </p><p>Specify the certificate identity for the URL integrity check in one of the
          following ways: </p><dl>
          <dlentry>
            <dt>Using the <codeph>commonName</codeph></dt>
            <dd>The usual way to specify the certificate identity (for the purpose of the URL
              integrity check) is through the Common Name (CN) in the subject DN of the certificate.
            </dd>
          </dlentry>
        </dl><dl>
          <dlentry>
            <dt>Using the <codeph>subjectAltName</codeph></dt>
            <dd>If you deploy a certificate on a multi-homed host, however, it may be
              practical to allow the certificate to be used with any of the multi-homed host names.
              In this case, it is necessary to define a certificate with multiple, alternative
              identities, and this is only possible using the <codeph>subjectAltName</codeph>
              certificate-extension. </dd>
          </dlentry>
        </dl><p>The HTTPS protocol also supports, in host names, the wildcard character *. For
          example, you can define the <codeph>subjectAltName</codeph> as follows:
          <codeblock outputclass="language-bash">subjectAltName=DNS:*.couchbase.com </codeblock></p><p>This certificate identity
          matches any three-component host name in the domain <codeph>couchbase.com</codeph>.
          </p><note type="note">As a best practice, try to avoid using the wildcard character in the
          domain name. Be sure never to do this accidentally by forgetting to type the dot (.)
          delimiter in front of the domain name. For example, if you specified *couchbase.com, your
          certificate could be used in any domain that ends with the string
            <codeph>couchbase</codeph>. </note></sectiondiv></sectiondiv>
    <sectiondiv id="cluster-certificate">
    <p><b>Couchbase Cluster Certificate</b></p>
      <p>The Couchbase cluster certificate is the root CA's public key <codeph>ca.pem</codeph>. In
        the configuration steps shown in the following sections, <codeph>ca.pem</codeph> is the CA
        public key that should be configured in Couchbase as the cluster certificate.</p>
      <p>When you load the cluster certificate into Couchbase, it is first checked to make sure it
        is a valid X.509 certificate. Next, if the per-node certificates are not signed by the
        cluster certificate, a warning is shown for each node during configuration. As the per-node
        certificates are updated, such that they are signed by the cluster certificate, the warning
        for each node goes away.</p></sectiondiv>
    <sectiondiv id="pernode-certificate">
     <p><b>Per Node Certificate</b></p>
      <p>The Couchbase cluster certificate is used to sign per-node Couchbase certificates, each
        containing the following:</p>
      <ul>
        <li>The node private key, which is named <codeph>pkey.key</codeph> as shown in the
          configuration steps below.</li>
        <li>The node public key certificate file, which is named <codeph>pkey.pem</codeph> as shown
          in the configuration steps below.</li>
        <li>The certificate chain file based on the supported CA hierarchy, This file is named
            <codeph>chain.pem</codeph> as shown in the configuration steps below.</li>
      </ul>
      <p>
        <table frame="all" rowsep="1" colsep="1" id="table_r1q_1zz_pv">
          <title>Private and public keys you need to have</title>
          <tgroup cols="3">
            <colspec colname="c1" colnum="1" colwidth="1*"/>
            <colspec colname="c2" colnum="2" colwidth="1.43*"/>
            <colspec colname="c3" colnum="3" colwidth="3.34*"/>
            <thead>
              <row>
                <entry/>
                <entry>Key name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry morerows="4">Server-side files</entry>
                <entry><codeph>ca.pem</codeph></entry>
                <entry>Root CA public key or the cluster certificate.</entry>
              </row>
              <row>
                <entry><codeph>int.pem</codeph></entry>
                <entry>Intermediate public key. There can be one or more intermediate public keys in
                  the hierarchy.</entry>
              </row>
              <row>
                <entry><codeph>pkey.key</codeph></entry>
                <entry>Node private key per node (private key of the node). Each node in the cluster
                  must have its private key.</entry>
              </row>
              <row>
                <entry><codeph>pkey.pem</codeph></entry>
                <entry>Node public key (public key of the node). Each node in the cluster must have
                  its public key.</entry>
              </row>
              <row>
                <entry><codeph>chain.pem</codeph></entry>
                <entry>Concatenated chain file (chain file). This file contains the node public key
                  and the intermediate public keys that signed first the node key (pkey.pem) and
                  then each other. This file does not contain the CA public key.
                </entry>
              </row>
              <row>
                <entry morerows="1">Client-side files</entry>
                <entry><codeph>ca.pem </codeph></entry>
                <entry>CA public key, which should be configured on the client</entry>
              </row>
              <row>
                <entry><codeph>chain.pem</codeph></entry>
                <entry>Concatenated chain file (chain file)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </p>
    </sectiondiv>
     <sectiondiv id="prepare-configuration">
   <p><b>Prepare for Configuration</b></p>
      <note type="note">If your CA authority supports automatic generation of certificates, you can
        skip the X.509 configuration steps.</note>
      <p>Before you start configuring X.509 certificates for your nodes, assess your needs. </p>
      <dl>
        <dlentry>
          <dt>Where will you put the configured CA, intermediate, and node keys?</dt>
          <dd>All the keys and certificates are generated in a directory named SSLCA, which can be
            located anywhere on your machine. </dd>
          <dd>The generated private node key (<codeph>pkey.key</codeph>) and chain certificate
              (<codeph>chain.pem</codeph>) must be posted in a specific place that is in the
            certificate trust path (such as <filepath>/Users/&lt;username&gt;/Library/Application\
              Support/Couchbase/var/lib/couchbase/inbox/</filepath> on MacOSX, or
            <filepath>/opt/couchbase/var/lib/couchbase/inbox/</filepath>) on Linux. </dd>
        </dlentry>
      </dl>
      <dl>
        <dlentry>
          <dt>Do you have one or more nodes in the cluster?</dt>
          <dd>
            <ul>
              <li>With one node, you will generate one node directory inside the directory SSLCA
                that will contain the private node key (<codeph>pkey.key</codeph>) and the
                certificate chain file (<codeph>chain.pem</codeph>). The node public key
                  (<codeph>pkey.pem</codeph>) is included in the chain file.</li>
              <li>With multiple nodes, you need to add an appropriate number of node directories
                with distinctive names, such as <codeph>node-sales</codeph>,
                  <codeph>node-hr,</codeph> or whatever your situation requires.</li>
            </ul>
          </dd>
        </dlentry>
      </dl>
      <dl>
        <dlentry>
          <dt>Do you have one or more intermediate CAs in your trust path?</dt>
          <dd>With only one CA, create one directory named <codeph>int</codeph>. If you have
            multiple intermediate CAs, be sure to name them in a way that will allow you to stack
            them properly in the chain file, such as <codeph>int1</codeph>, <codeph>int2</codeph>,
            and so on. </dd>
          <dd>This order will show that the intermediate CA closest to the node (which signed the
            node certificate) has the higher number, or in the sample below
              <codeph>int2</codeph>.<p>For example: </p><p><image href="pict/chain-pem.png"
                id="image_e5g_bcn_sv" align="left" width="500"/>
            </p></dd>
        </dlentry>
      </dl>
     </sectiondiv></section>
     
    <section id="sslconfig">
      <title>
        Configure X.509 Certificates
      </title>
      
      <p>
        The following steps configure X.509 certificates on Ubuntu 16: a root certificate is
        created with a single intermediate certificate and a single node certificate; and a chain certificate
        is created from the intermediate and node certificates. The chain certificate and node private key
        are then made active for the current Couchbase Server-node. 
      </p>
      
      <p>
        Proceed as follows, using
        the <codeph>sudo</codeph> command where appropriate.
      </p>
      
      <ol>
        <li>
            Create environment variables for the naming of a directory-structure, within which
            will reside the certificates you create for root, intermediate, and node.
            
          <codeblock outputclass="language-bash">export TOPDIR=SSLCA
export ROOT_DIR=rootdir
export NODE_DIR=nodedir
export INT_DIR=intdir</codeblock>
          
          <p>
            Note that in cases where multiple intermediate and/or node certificates are to be included in the
            certificate-chain, multiple intermediate and/or directories are required &#8212; one for each 
            intermediate or node certificate.
          </p>
          
        </li>
        
        <li>
          Create environment variables for each of the certificate-files to be created.
          
          <codeblock outputclass="language-bash">export ROOT_CA=ca
export INTERMEDIATE=int
export NODE=pkey
export CHAIN=chain</codeblock>
          
          <p>
            Note that in cases where multiple intermediate and/or node certificates are to be included in the
            certificate-chain, additional environment-variable definitions &#8212; one for each of the
            additional intermediate and/or node certificates &#8212; are required.
          </p>
        </li>
        
        <li>
          Create environment variables for the administrator-credentials to be used for certificate management,
          the IP address at which the Couchbase Server-node is located, and the username required for role-based
          access to a particular resource. 
          
          <codeblock outputclass="language-bash">export ADMINCRED=Administrator:password
export ip=10.143.173.101
export USERNAME=travel-sample</codeblock>     
          <p>
            Note that in this example, the 
            username is specified as <codeph>travel-sample</codeph>,
            which is typically associated with the <b>Bucket Full Access</b> role, on the bucket <i>travel-sample</i>. 
            For access to be fully tested, ensure that the <codeph>travel-sample</codeph> user has indeed been
            defined on the Couchbase Server-node, and is associated with the <b>Bucket Full Access</b> role. (See
            <xref href="./security-authorization.dita" scope="local" format="dita">Authorization</xref> for more 
            information on RBAC.)
            
          </p>
          
          <p>
            
          </p>
        </li>
        
        <li>
          Create a directory-structure in which, within a top-level directory named <codeph>SSLCA</codeph>, three
          subdirectories reside &#8212; <codeph>rootdir</codeph>, <codeph>intdir</codeph>, 
          and <codeph>nodedir</codeph> &#8212;
          respectively to hold the certificates you create for root, intermediate, and node.

        <codeblock outputclass="language-bash">mkdir ${TOPDIR}
cd ${TOPDIR}
mkdir ${ROOT_DIR}
mkdir ${INT_DIR}
mkdir ${NODE_DIR}</codeblock>
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          Generate the root private key file (<codeph>ca.key</codeph>) and the public key file 
          (<codeph>ca.pem</codeph>):
          
          <codeblock outputclass="language-bash">cd ${ROOT_DIR}
openssl genrsa -out ${ROOT_CA}.key 2048
openssl req -new -x509 -days 3650 -sha256 -key ${ROOT_CA}.key \
-out ${ROOT_CA}.pem -subj '/C=UA/O=MyCompany/CN=MyCompanyRootCA'</codeblock>

          <p>
            
          </p>
          
        </li>
        
        <li>
          Generate, first, the intermediate private key (<codeph>int.key</codeph>); and secondly,
          the intermediate certificate signing-request
          (<codeph>int.csr</codeph>):
          
          <codeblock outputclass="language-bash">cd ../${INT_DIR}
openssl genrsa -out ${INTERMEDIATE}.key 2048
openssl req -new -key ${INTERMEDIATE}.key -out ${INTERMEDIATE}.csr \
-subj '/C=UA/O=MyCompany/CN=MyCompanyIntermediateCA'</codeblock>

        <p>
        </p>
          
       </li>
        
        <li>
          Create the extension-file <codeph>v3_ca.ext</codeph>; in order to add extensions to the
          certificate, and to generate the certificate signing-request:
        
          <codeblock outputclass="language-bash">cat &lt;&lt;EOF&gt;&gt; ./v3_ca.ext
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always
basicConstraints = CA:true
EOF</codeblock>
          
          <p>
          
          </p>
          
        </li>
        
       <li>
         <p>
           Generate the intermediate public key (<codeph>int.pem</codeph>), based on the intermediate
           certificate signing-request (<codeph>int.csr</codeph>), and signed by the root public key
           (<codeph>ca.pem</codeph>). 
         </p>
         
         <codeblock outputclass="language-bash">openssl x509 -req -in ${INTERMEDIATE}.csr \
-CA ../${ROOT_DIR}/${ROOT_CA}.pem -CAkey ../${ROOT_DIR}/${ROOT_CA}.key \
-CAcreateserial -CAserial ../${ROOT_DIR}/rootCA.srl -extfile ./v3_ca.ext \
-out ${INTERMEDIATE}.pem -days 365</codeblock>
         <p>
           
         </p>
         
       </li>
        
        <li>
          Generate, first, the node private key (<codeph>pkey.key</codeph>); secondly, the node certificate
          signing-request (<codeph>pkey.csr</codeph>); and thirdly,
          the node public key (<codeph>pkey.pem</codeph>). 
          
          <codeblock outputclass="language-bash">cd ../${NODE_DIR}
openssl genrsa -out ${NODE}.key 2048  
openssl req -new -key ${NODE}.key -out ${NODE}.csr \
-subj "/C=UA/O=MyCompany/CN=${USERNAME}"
openssl x509 -req -in ${NODE}.csr -CA ../${INT_DIR}/${INTERMEDIATE}.pem \
-CAkey ../${INT_DIR}/${INTERMEDIATE}.key -CAcreateserial \
-CAserial ../${INT_DIR}/intermediateCA.srl -out ${NODE}.pem -days 365</codeblock> 

        </li>
        
        <li>
          Generate the certificate chain-file, by concatenating the node and intermediate
          certificates. This allows the client to verify
          the intermediate certificate against the root certificate. 
          
          <codeblock outputclass="language-bash">cd ..
cat ./${NODE_DIR}/${NODE}.pem ./${INT_DIR}/${INTERMEDIATE}.pem > ${CHAIN}.pem</codeblock>
          
          <p>
            Note that if multiple intermediate certificates are specified for concatenation
            in this way, the concatenation-order must correspond to the order of
            signing. Thus, the node certificate, which appears in the first position,
            has been signed by the intermediate certificate, which therefore
            appears in the second position: and in cases where this intermediate certificate has itself 
            been signed by a second intermediate certificate, the second intermediate certificate
            must appear in 
            the third position, and so on. 
          </p>
          
          <p>
            Note also that the root certificate is never included in the chain.
          </p>
          
          <p>
            
          </p>
        </li>
        
        <li>
          Manually copy the node private key (<codeph>pkey.key</codeph>) and the chain file (<codeph>chain.pem</codeph>)
          to the <codeph>inbox</codeph> folder of the Couchbase Server-node:
          
          <codeblock outputclass="language-bash">mkdir /opt/couchbase/var/lib/couchbase/inbox/
cp ./${CHAIN}.pem /opt/couchbase/var/lib/couchbase/inbox/${CHAIN}.pem
chmod a+x /opt/couchbase/var/lib/couchbase/inbox/${CHAIN}.pem
cp ./${NODE_DIR}/${NODE}.key /opt/couchbase/var/lib/couchbase/inbox/${NODE}.key
chmod a+x /opt/couchbase/var/lib/couchbase/inbox/${NODE}.key</codeblock>
        </li>
        
        <li>
          Upload the root certificate, and activate it:
          
          <codeblock outputclass="language-bash">curl -X POST --data-binary "@./${ROOT_DIR}/${ROOT_CA}.pem" \
http://${ADMINCRED}@${ip}:8091/controller/uploadClusterCA
curl -X POST http://${ADMINCRED}@${ip}:8091/node/controller/reloadCertificate</codeblock>
        
        <p>
          Note that alternatively, the following command-line interfaces can be used:
        </p>
          
          <codeblock outputclass="language-bash">couchbase-cli ssl-manage -c ${ip}:8091:8091 -u Administrator -p password \
--upload-cluster-ca=./${ROOT_DIR}/${ROOT_CA}.pem
couchbase-cli ssl-manage -c ${ip}:8091 -u Administrator -p password \
--set-node-certificate</codeblock>
        </li>
        
        <li>
          For the current Couchbase Server-node, enable the client certificate:
          
          <codeblock outputclass="language-bash">curl -X POST --data-binary "state=enable" \
http://${ADMINCRED}@${ip}:8091/settings/clientCertAuth
curl -X POST --data-binary "delimiter=" \
http://${ADMINCRED}@${ip}:8091/settings/clientCertAuth
curl -X POST --data-binary "path=subject.cn" \
http://${ADMINCRED}@${ip}:8091/settings/clientCertAuth
curl -X POST --data-binary "prefix=" \
http://${ADMINCRED}@${ip}:8091/settings/clientCertAuth</codeblock>
          <p>
            For further information on certificate-deployment, see
            <xref href="../cli/cbcli/couchbase-cli-ssl-manage.dita" scope="local" format="dita">ssl-manage</xref> and
            <xref href="../rest-api/rest-encryption.dita" scope="local" format="dita">Encryption On-the-Wire API</xref>.   
          </p>
        </li>
        
      </ol>
      
    </section>
    
    <section id="cert_auth_for_java_client">
      <title>
        Provide Certificate-Based Authentication for a Java Client
      </title>
      
      <p>
        Once the root certificate for a Couchbase Server-node has been deployed, a Java client can
        authenticate by means of an appropriately prepared keystore.
      </p>
      
      <p>
        For an overview, see
        <xref href="./security-certs-auth.dita" scope="local" format="dita">Certificate-Based Authentication</xref>
      </p>
      
      <p>
        Proceed as follows. Note that these instructions assume use of the Ubuntu 16 environment configured in the preceding
        section,
        <i>Configure X.509 Certificates</i>.
      </p>
      
      <ol>
        <li>
          Define environment variables for the name of the keystore to be created, and its password.
          
          <codeblock outputclass="language-bash">export KEYSTORE_FILE=my.keystore
export STOREPASS=storepass</codeblock>
          
          <p>
            
          </p>
        </li>
        
        <li>
          If necessary, install a package containing the <codeph>keytool</codeph> utility:
          
          <codeblock outputclass="language-bash">sudo apt install openjdk-9-jre-headless</codeblock>
          
          <p>
            
          </p>
        </li>
        
        <li>
          Within the top-level, <codeph>SSLCA</codeph> directory that you created, generate the keystore:
          
          <codeblock outputclass="language-bash">keytool -genkey -keyalg RSA -alias selfsigned \
-keystore ${KEYSTORE_FILE} -storepass ${STOREPASS} -validity 360 -keysize 2048 \
-noprompt  -dname "CN=${USERNAME}, OU=None, O=None, L=None, S=None, C=US" -keypass ${STOREPASS}</codeblock>
          
          <p>
            
          </p>
            
        </li>
        
        <li>
          Generate the certificate signing-request:
          
          <codeblock outputclass="language-bash">keytool -certreq -alias selfsigned -keyalg RSA -file my.csr \
-keystore ${KEYSTORE_FILE} -storepass ${STOREPASS} -noprompt</codeblock>
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          Generate the client certificate, signing it with the intermediate private key:
          
          <codeblock outputclass="language-bash">openssl x509 -req -in my.csr -CA ./${INT_DIR}/${INTERMEDIATE}.pem \
-CAkey ./${INT_DIR}/${INTERMEDIATE}.key -CAcreateserial -out clientcert.pem -days 365</codeblock>
          
          <p>
            
          </p>
        </li>
        
        <li>
          Add the root certificate to the keystore:
          
          <codeblock outputclass="language-bash">keytool -import -trustcacerts -file ./${ROOT_DIR}/${ROOT_CA}.pem \
-alias root -keystore ${KEYSTORE_FILE} -storepass ${STOREPASS} -noprompt</codeblock>
          
          <p>
            
          </p>
        </li>
        
        <li>
          Add the intermediate certificate to the keystore:
          
          <codeblock outputclass="language-bash">keytool -import -trustcacerts -file ./${INT_DIR}/${INTERMEDIATE}.pem \
-alias int -keystore ${KEYSTORE_FILE} -storepass ${STOREPASS} -noprompt</codeblock>
          
          <p>
            
          </p>
        </li>
        
        <li>
          Add the client certificate to the keystore:
          
          <codeblock outputclass="language-bash">keytool -import -keystore ${KEYSTORE_FILE} -file clientcert.pem \
-alias selfsigned -storepass ${STOREPASS} -noprompt</codeblock>
        </li>
      </ol>
      
      <p>
        This concludes preparation of the Java client's keystore. Copy the file (in this case, <codeph>my.keystore</codeph>)
        to a location on a local filesystem from which the Java client can access it.
      </p>
    </section>
    
    
    <section id="rotate-x509">
      <title>Rotating X.509</title>
      
       
        <p>
          Certificate rotation is needed when:
        </p>
      
        <ul>
          
          <li>
            A certificate expires.
          </li>
          
          <li>
            You move from an old CA authority to a new.
          </li>
          
          <li>
            There is a change in the policy of the certificates issued by the CA.
          </li>
          
          <li>
            A widespread breach of security has occurred in your system.
          </li>
          
        </ul>
      
      
          <p>
            Certificate-renewal should be planned well before a certificate expires. 
            X.509 certificate-rotation in Couchbase is an online operation that does not require a 
            node or cluster restart: applications maintain continued access to Couchbase Server,
            experiencing no downtime due to the rotation operation.
          </p>
          
          
       
      <sectiondiv><p><b>How to Rotate a Couchbase Server X.509 Certificate </b></p>
          
          
          <ol>
            <li><b>Generate a new certificate.</b>
              <p>Before you rotate a certificate, you need to generate a new certificate.
              </p><p>Typically, your Certificate Authority will give you a self-service option to
                re-issue certificates. If this is not the case, you can manually regenerate a new
                X509 certificate.</p><ol>
                  <li>Renew the root CA certificate<p>The root certificate authority is the topmost
                    CA in a CA hierarchy. Its validity period is typically the longest in
                    the hierarchy: between 10 and 20
                    years. </p><note type="note">When you renew the root CA, you have the option of
                      reusing its existing private key. If you keep the same private key on your root CA,
                      all certificates can continue to validate successfully against the new root; all
                      that is required of you is to trust the new root. </note></li>
                  <li>Generate the root CA for the first time
                    <codeblock outputclass="language-bash">openssl genrsa -out <b>ca.key</b> 2048
openssl req -new -x509  -days 3650 -sha256 -key <b>ca.key</b> -out <b>ca.pem</b> \
-subj '/C=UA/O=My Company/CN=My Company Root CA'</codeblock></li>
                  <li>After ten years, the renewal time for the root CA comes up. <ul>
                    <li>Renew the root CA using the existing <codeph>ca.key</codeph>:
                      <codeblock outputclass="language-bash">openssl req -new -key <b>ca.key</b> -out <b>newcsr.csr</b> 
openssl x509 -req -days 3650 -sha256 -in <b>newcsr.csr</b> \
-signkey <b>newca.key</b> -out <b>newca.pem</b></codeblock></li>
                    <li>Generate a completely new root CA:
                      <codeblock outputclass="language-bash">openssl genrsa -out <b>newca.key</b> 2048
openssl req -new -x509  -days 3650 -sha256 -key <b>newca.key</b> \
-out <b>newca.pem</b> -subj '/C=UA/O=My Company/CN=My Company Root CA' </codeblock></li>
                  </ul></li>
                  <li>Renew the intermediate certificates.<p>For the intermediate CAs, a possible strategy
                    might be to renew them for a year to six months before they expire, and reuse the
                    existing key. </p><p>By replacing the old chain file with the new chain file (which
                      contains the updated intermediate certificates), rotation of the intermediate
                      certificates can be performed:
                      <codeblock outputclass="language-bash">cat <b>pkey.pem</b> ../int/<b>newint.pem</b> \
&lt;possibly other intermediate CAs&gt; > <b>chain.pem</b> </codeblock></p></li>
                </ol></li>
            <li><b>Deploy the CA public key and intermediate certificates</b>
              <p>Before modifying anything on the server-side, deploy the CA public key and intermediate
                certificates in the certificate-stores used by your client browser and the SDK
                language.</p><p>For example, here are steps to do that for <xref
                  href="http://www.cyberciti.biz/faq/firefox-adding-trusted-ca/" format="html"
                  scope="external">Firefox</xref> and <xref
                    href="http://blogmines.com/blog/how-to-import-a-certificate-in-google-chrome/"
                    format="html" scope="external">Chrome</xref>.</p></li>
            <li><b>Rotate certificates on the server</b>
              
              
              <ol>
                <li>Configure the new root CA certificate (<codeph>newca.pem</codeph> is the new root CA certificate). 
                  <ul>
                    <li>Using CLI:
                      <codeblock outputclass="language-bash">couchbase-cli ssl-manage -c &lt;node-name>:8091 -u Administrator \
-p password --upload-cluster-ca=<b>newca.pem</b>  </codeblock></li>
                    <li>Using REST:
                      <codeblock outputclass="language-bash">curl -X POST \
--data-binary "@newca.pem" http://Administrator:password@127.0.0.1:8091/controller/uploadClusterCA</codeblock></li>
                  </ul>
                </li>
                <li>Configure the new intermediate and node certificate. <p>For each node, copy over new
                  <codeph>chain.pem</codeph> file, and per node private key (new
                  <codeph>pkey.pem</codeph> file, if the node certificate is rotated) to the
                  <codeph>inbox</codeph> folder.</p><ul>
                    <li>Using CLI:
                      <codeblock outputclass="language-bash">couchbase-cli ssl-manage -c &lt;node-name>:8091 -u Administrator \
-p password --set-node-certificate</codeblock></li>
                    <li>Using REST:
                      <codeblock outputclass="language-bash">curl -X \
POST http://Administrator:password@[node-name]:8091/node/controller/reloadCertificate </codeblock></li>
                  </ul></li>
                
              </ol>
            </li>  
            <li><b>Test the server CA certificate</b>
              <p>You can also use OpenSSL's <codeph>s_client</codeph> by trying to connect to a server
                that you know is using a certificate signed by the CA that you just installed:
                <codeblock outputclass="language-bash">openssl s_client \
-connect https://&lt;hostname&gt;:8091 -CApath &lt;root ca public key&gt; </codeblock></p></li>
            <li><b>Troubleshoot X.509 certificates</b>
              <p>During the development process these external tools might come in handy for verifying
                and debugging SSL traffic: <ul>
                  <li><cmdname>openssl</cmdname>: OpenSSL command line tool</li>
                  <li>wireshark: Network traffic analyzer</li>
                  <li>nmap: Sophisticated security scanner </li>
                </ul></p></li>
            <li><b>Revert from the X.509 to the self-signed certificate</b>
              <p>If you configured Couchbase to use X.509 certificates, and you want to go back to the
                self-signed certificates, you can do this by regenerating the self-signed cluster
                certificate, using CLI or REST.  </p><note type="warning">Moving from CA certificates to
                  self-signed certificates causes application-downtime, 
                  because you need to reconfigure
                  the self-signed cluster-certificate on the client-machines 
                  after self-signed certificate's
                  regeneration.</note><ul>
                    <li>Using CLI:
                      <codeblock outputclass="language-bash">couchbase-cli ssl-manage -c &lt;hostname&gt;:8091 -u Administrator -p password \
--regenerate-cert=/tmp/test.pem</codeblock></li>
                    <li>Using REST:
                      <codeblock outputclass="language-bash">curl -X POST  http://Administrator:password@remoteHost:8091/controller/regenerateCertificate</codeblock></li>
                  </ul>
            </li>
            
          </ol></sectiondiv>
        </section>
      
      
 
    <section id="trbl-x509">
      <title>Troubleshooting X.509</title>
      
   <p>This section lists the error messages connected to the configuration of cluster and node
        certificates in Couchbase.</p>
  <sectiondiv>
    <p><b>Cluster CA Certificates</b></p>
          
          
          <p>Here are error messages you might encounter when configuring the cluster CA
          certificate, and suggested corrective actions:</p>
          <p>
            <table frame="all" rowsep="1" colsep="1" id="table_fsj_r3d_5v">
              <title>Error messages when configuring cluster CA certificates</title>
              <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="1*"/>
                <colspec colname="c2" colnum="2" colwidth="1*"/>
                <colspec colname="c3" colnum="3" colwidth="1*"/>
                <thead>
                  <row>
                    <entry>Couchbase Error Message</entry>
                    <entry>Description</entry>
                    <entry>Suggested User Action</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><codeph>Certificate should not be empty</codeph></entry>
                    <entry>This error message can occur if the request body of the certificate is
                      empty.</entry>
                    <entry>Open the certificate file, and verify whether it is empty or not. The
                      certificate file should be readable using openssl or via online SSL tools such as
                      <xref href="https://www.sslchecker.com/certdecoder" format="html"
                        scope="external">sslchecker </xref>. </entry>
                  </row>
                  <row>
                    <entry><codeph>Certificate is not valid at this time</codeph></entry>
                    <entry>This error message can occur if the certificate has expired, or is not yet
                      valid.</entry>
                    <entry>Verify whether the certificate validity-dates (begins on, and expires on) are
                      currently valid corresponding to the server clock time.</entry>
                  </row>
                  <row>
                    <entry><codeph>Malformed certificate</codeph></entry>
                    <entry>This error message can occur due to many reasons - an extra space in the
                      certificate digest body, incorrect certificate format, and so on. </entry>
                    <entry>Use a properly configured certificate, and make sure itâ€™s readable, using
                      <codeph>openssl</codeph>. It should look as follows: Certificate begins with
                      <p><codeph>-----BEGIN CERTIFICATE-----</codeph></p><p>and ends with</p><p><codeph>
                        -----END CERTIFICATE-----</codeph></p><p>on a new line with no spaces before or after.</p></entry>
                  </row>
                  <row>
                    <entry><codeph>Only one certificate per request is allowed</codeph></entry>
                    <entry>Appears when the file contains more than one key or certificate.</entry>
                    <entry>Open the <codeph>.pem</codeph> file, and make sure that it has only a single
                      certificate digest (such as single <codeph>BEGIN CERTIFICATE,</codeph>
                      <codeph>END CERTIFICATE</codeph> pragmas).</entry>
                  </row>
                  <row>
                    <entry><codeph>Encrypted certificates are not supported </codeph></entry>
                    <entry>This error message can occur if you are trying to load a certificate that is
                      encrypted. Verify by opening the certificate file. If you see something 
                      similar to the line shown
                      below, you will know your certificate is encrypted.: <p><codeph>-----BEGIN RSA
                        PRIVATE KEY-----</codeph></p></entry>
                    <entry>Couchbase does not support encrypted certificates. Decrypt the certificate
                      with <codeph>openssl</codeph> before loading the certificate in Couchbase.
                      <codeblock outputclass="language-bash">openssl rsa -in privateKey.pem -out newPrivateKey.pem </codeblock></entry>
                  </row>
                  <row>
                    <entry><codeph>Invalid certificate type: ~s </codeph></entry>
                    <entry>Appears when a header other than <codeph>BEGIN CERTIFICATE</codeph> has been
                      found.</entry>
                    <entry>Open the certificate file, and verify whether it is a valid certificate. The
                      certificate file should be readable using <codeph>openssl</codeph> or via online
                      SSL tools such as <xref href="https://www.sslchecker.com/certdecoder"
                        format="html" scope="external">sslchecker</xref>.</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </p>
  </sectiondiv>
      <sectiondiv>
<p><b>Node Certificates</b></p>
          
          <p>Here are some error messages you might encounter when configuring the node certificate
          and the suggested corrective actions:</p>
          <p>
            <table frame="all" rowsep="1" colsep="1" id="table_u3d_bkd_5v">
              <title>Error messages when configuring node certificates</title>
              <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="1*"/>
                <colspec colname="c2" colnum="2" colwidth="1*"/>
                <colspec colname="c3" colnum="3" colwidth="1*"/>
                <thead>
                  <row>
                    <entry>Couchbase Error Message</entry>
                    <entry>Description</entry>
                    <entry>Suggested User Action</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><codeph>Cluster CA needs to be set before setting node
                      certificate</codeph></entry>
                    <entry>This error can occur when your cluster is still using the self-generated
                      certificate, and you are attempting to configure a node certificate.</entry>
                    <entry>Set up the cluster CA certificate before configuring the per node
                      certificate.</entry>
                  </row>
                  <row>
                    <entry><codeph>Incorrectly configured certificate chain. &lt;Error></codeph></entry>
                    <entry>Denotes an invalid certificate in the chain file when configuring Couchbase. </entry>
                    <entry>Chain file should contain a sequence of PEM (base64) encoded X.509
                      certificates ordered from leaf to and including the intermediate certificate
                      authorities.</entry>
                  </row>
                  <row>
                    <entry><codeph>Unable to read private key file &lt;Path>. &lt;Error></codeph>
                    </entry>
                    <entry><codeph>&lt;Error></codeph> is one of the file read errors. </entry>
                    <entry>Make sure that you have copied an unencrypted version of the private key
                      file to the inbox folder on the Couchbase node.</entry>
                  </row>
                  <row>
                    <entry><codeph>Unable to read certificate chain file &lt;Path>. &lt;Error>
                    </codeph></entry>
                    <entry><codeph>&lt;Error></codeph> is one of the file read errors.</entry>
                    <entry>Make sure that you have copied an unencrypted version of the chain file to
                      the inbox folder on the Couchbase node.</entry>
                  </row>
                  <row>
                    <entry><codeph>Invalid private key type: &lt;Type></codeph></entry>
                    <entry>The private key has an unsupported header.</entry>
                    <entry>Make sure that you use a valid private key file.</entry>
                  </row>
                  <row>
                    <entry><codeph>Provided certificate doesn't match provided private
                      key</codeph></entry>
                    <entry>The certificate doesn't recognize the message signed with a private
                      key.</entry>
                    <entry>Be sure that you use a complete key pair</entry>
                  </row>
                  <row>
                    <entry><codeph>Encrypted keys are not supported</codeph></entry>
                    <entry>The private key is encrypted.</entry>
                    <entry>Couchbase does not support encrypted keys. You should decrypt the private key
                      with OpenSSL before loading the certificate in Couchbase. </entry>
                  </row>
                  <row>
                    <entry><codeph>Provided private key contains incorrect number of
                      entries</codeph></entry>
                    <entry>The private key is a chain of entries.</entry>
                    <entry>The private key file should contain a single key digest.</entry>
                  </row>
                  <row>
                    <entry><codeph>Malformed or unsupported private key format</codeph></entry>
                    <entry>The private key cannot be used.</entry>
                    <entry>Open the key file, and verify whether it is a valid private key. The
                      certificate file should be readable using <codeph>openssl</codeph>.</entry>
                  </row>
                  <row>
                    <entry><codeph>File does not exist</codeph></entry>
                    <entry>The file is missing, does not exist.</entry>
                    <entry>Add the missing file.</entry>
                  </row>
                  <row>
                    <entry><codeph>Missing permission for reading the file, or for searching one of the
                      parent directories</codeph></entry>
                    <entry>You don't have the proper permissions to read the file or to search its
                      parent directories.</entry>
                    <entry>Change the permissions to allow you to read the file.</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </p>
          
      </sectiondiv>     
      
      
    </section>
  
      
  </body>
</topic>
