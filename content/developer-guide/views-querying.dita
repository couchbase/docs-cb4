<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic xml:lang="en-us" id="query-views">
   <title>Querying views</title>
   <shortdesc>The content of the key that is generated by the <codeph>emit()</codeph> function provides information on
      how the data is selected from your view.</shortdesc>
   <body>
      <p>In order to query a view, the view definition must include a suitable map function that
         uses the <codeph>emit()</codeph> function to generate each row of information. </p>
      <p>The key can be used when querying a view as the selection mechanism, either by using
         an:</p>
      <ul>
         <li><p><i>explicit key</i> — show all the records matching the exact structure of the
               supplied key.</p></li>
         <li><p><i>list of keys</i> — show all the records matching the exact structure of each of
               the supplied keys (effectively showing keya or keyb or keyc).</p></li>
         <li><p><i>range of keys</i> — show all the records starting with keyA and stopping on the last instance
               of keyB.</p></li>
      </ul>
      <p>When querying the view results, a number of parameters can be used to select, limit, order
         and otherwise control the execution of the view and the information that is returned.</p>
      <p>When a view is accessed without specifying any parameters, the view will produce results
         matching the following:</p>
      <ul>
         <li><p>Full view specification, i.e. all documents are potentially output according to the
               view definition.</p></li>
         <li><p>Limited to 10 items within the Admin Console, unlimited through the REST
            API.</p></li>
         <li><p>Reduce function used if defined in the view.</p></li>
         <li><p>Items sorted in ascending order (using UTF-8 comparison for strings, natural number
               order)</p></li>
      </ul>
      <p>View results and the parameters operate and interact in a specific order. The interaction
         directly affects how queries are written and data is selected.</p>
      
      <fig>
         <image href="images/views-query-flow.png" width="450"/>
      </fig>
      
      <p>The core arguments and selection systems are the same through both the REST API interface,
         and the client libraries. The setting of these values differs between different client
         libraries, but the argument names and expected and supported values are the same across all
         environments.</p>
      
      
      
      <section><title>Querying</title><p>Querying can be performed through the REST API endpoint.
            The REST API supports and operates using the core HTTP protocol, and this is the same
            system used by the client libraries to obtain the view data.</p> To retrieve views
         information, access any server node in a cluster on port 8092. <p>The following is the HTTP
            method and URI used to query
            views:</p><codeblock>GET /[bucket-name]/_design/[ddoc-name]/_view/[view-name]</codeblock><p>Where:</p><ul>
            <li>bucket-name is the name of the bucket.</li>
            <li>ddoc-name is the name of the design document that contains the view.</li>
            <li>view-name is the name of the corresponding view within the design document.</li>
         </ul><p>Development view, the <codeph>ddoc-name</codeph> is prefixed with
               <codeph>dev_</codeph>. For example, the design document <codeph>beer</codeph> is
            accessible as a development view using <codeph>dev_beer</codeph>.</p><p>Production views
            are accessible using their name only.</p><p>Parameters (optional):</p><table>
            <title>Views parameters</title>
            <tgroup cols="3">
               <colspec colname="col1" colwidth="1*"/>
               <colspec colname="col2" colwidth="1*"/>
               <colspec colname="col3" colwidth="2*"/>
               <thead>
                  <row>
                     <entry>Parameters</entry>
                     <entry>Type</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry><codeph>descending</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Return the documents in descending by key order.</entry>
                  </row>
                  <row>
                     <entry><codeph>endkey</codeph></entry>
                     <entry>string</entry>
                     <entry>Stop returning records when the specified key is reached. Key must be
                        specified as a JSON value.</entry>
                  </row>
                  <row>
                     <entry><codeph>endkey_docid</codeph></entry>
                     <entry>string</entry>
                     <entry>Stop returning records when the specified document ID is
                        reached.</entry>
                  </row>
                  <row>
                     <entry><codeph>full_set</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Use the full cluster data set (development views only).</entry>
                  </row>
                  <row>
                     <entry><codeph>group</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Group the results using the reduce function to a group or single row.
                        Note: Do not use <codeph>group</codeph> with <codeph>group_level</codeph>
                        because they are not compatible.</entry>
                  </row>
                  <row>
                     <entry><codeph>group_level</codeph></entry>
                     <entry>numeric</entry>
                     <entry>Specify the group level to be used. Note: Do not use
                           <codeph>group_level</codeph> with <codeph>group</codeph> because they are
                        not compatible.</entry>
                  </row>
                  <row>
                     <entry><codeph>inclusive_end</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Specifies whether the specified end key is included in the result. Note:
                        Do not use <codeph>inclusive_end</codeph> with <codeph>key</codeph> or
                           <codeph>keys</codeph>.</entry>
                  </row>
                  <row>
                     <entry><codeph>key</codeph></entry>
                     <entry>string</entry>
                     <entry>Return only documents that match the specified key. Key must be
                        specified as a JSON value.</entry>
                  </row>
                  <row>
                     <entry><codeph>keys</codeph></entry>
                     <entry>array</entry>
                     <entry>Return only documents that match each of keys specified within the given
                        array. Key must be specified as a JSON value. Sorting is not applied when
                        using this option.</entry>
                  </row>
                  <row>
                     <entry><codeph>limit</codeph></entry>
                     <entry>numeric</entry>
                     <entry>Limit the number of the returned documents to the specified
                        number.</entry>
                  </row>
                  <row>
                     <entry><codeph>on_error</codeph></entry>
                     <entry>string</entry>
                     <entry>Sets the response in the event of an error. <p>Supported values: <ul>
                              <li><codeph>continue</codeph> : Continue to generate view information
                                 in the event of an error, including the error information in the
                                 view response stream.</li>
                              <li><codeph>stop</codeph> : Stop immediately when an error condition
                                 occurs. No further view information is returned.</li>
                           </ul></p>
                     </entry>
                  </row>
                  <row>
                     <entry><codeph>reduce</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Use the reduction function.</entry>
                  </row>
                  <row>
                     <entry><codeph>skip</codeph></entry>
                     <entry>numeric</entry>
                     <entry>Skip this number of records before starting to return the
                        results.</entry>
                  </row>
                  <row>
                     <entry><codeph>stale</codeph></entry>
                     <entry>string</entry>
                     <entry>Allow the results from a stale view to be used. <p>Supported values: <ul>
                              <li><codeph>false</codeph> : The server waits for the indexer to
                                 finish the changes that correspond to the current key-value
                                 document set and then returns the latest entries from the view
                                 index.</li>
                              <li><codeph>ok</codeph> : The server returns the current entries from
                                 the index file including the stale views.</li>
                              <li><codeph>update_after</codeph> : The server returns the current
                                 entries from the index, and then initiates an index update.</li>
                           </ul></p></entry>
                  </row>
                  <row>
                     <entry><codeph>startkey</codeph></entry>
                     <entry>string</entry>
                     <entry>Return records with a value equal to or greater than the specified key.
                        Key must be specified as a JSON value.</entry>
                  </row>
                  <row>
                     <entry><codeph>startkey_docid</codeph></entry>
                     <entry>string</entry>
                     <entry>Return records starting with the specified document ID.</entry>
                  </row>
               </tbody>
            </tgroup>
         </table><p>Curl request syntax:</p><codeblock>GET http://[localhost]:8092/[bucket-name]/_design/[ddoc-name]/_view/[view-name]</codeblock>
         <p>To access a view stored within an SASL password-protected bucket, include the bucket
            name and bucket password within the URL of the
            request:</p><codeblock>GET http://[bucket-name]:[password]@[localhost]:8092/[bucket-name]/_design/[ddoc-name]/_view/[view-name]
</codeblock><note
            type="note">Additional arguments to the URL request can be used to select information
            from the view, and provide limit, sorting and other options.</note><p>To output only ten
            items:</p><codeblock>GET http://[localhost]:8092/[bucket-name]/_design/[ddoc-name]/_view/[view-name]?limit=10
</codeblock><note
            type="important">The formatting of the URL follows the HTTP specification. The first
            argument is separated from the base URL using a question mark ( <codeph>?</codeph> ).
            Additional arguments are separated using an ampersand ( <codeph>&amp;</codeph> ).
            Special characters are quoted or escaped according to the HTTP standard rules.
         </note></section>
      
      
      
      <section><title>Selecting information</title><p>Couchbase Server supports a number of
            mechanisms for selecting information returned by the view. Key selection is made after
            the view results (including the reduction function) are executed, and after the items in
            the view output have been sorted.</p><p>When specifying keys to the selection mechanism,
            the key must be expressed in the form of a JSON value. For example, when specifying a
            single key, a string must be quoted (“string”).</p><p>When specifying the key selection
            through a parameter, the keys must match the format of the keys emitted by the view.
            Compound keys, for example where an array or hash has been used in the emitted key
            structure, the supplied selection value should also be an array or a hash.</p><p>The
            following selection types are supported:</p><ul>
            <li><b>Explicit Key</b></li>
         </ul><p>An explicit key can be specified using the parameter <codeph>key</codeph>. The view
            query will only return results where the key in the view output, and the value supplied
            to the <codeph>key</codeph> parameter match identically.</p><p>For example, if you
            supply the value “tomato” only records matching <i>exactly</i> “tomato” will be selected
            and returned. Keys with values such as “tomatoes” will not be returned.</p><ul>
            <li><b>Key List</b></li>
         </ul><p>A list of keys to be output can be specified by supplying an array of values using
            the <codeph>keys</codeph> parameter. In this instance, each item in the specified array
            will be used as explicit match to the view result key, with each array value being
            combined with a logical <codeph>or</codeph>.</p><p>For example, if the value specified
            to the <codeph>keys</codeph> parameter was <codeph>["tomato","avocado"]</codeph>, then
            all results with a key of ‘tomato’ <i>or</i> ‘avocado’ will be returned.</p><p>When
            using this query option, the output results are not sorted by key. This is because key
            sorting of these values would require collating and sorting all the rows before
            returning the requested information.</p><p>In the event of using a compound key, each
            compound key must be specified in the query. For example:</p><codeblock><codeph>```
keys=[["tomato",20],["avocado",20]]
```
</codeph></codeblock><ul>
            <li><b>Key Range</b></li>
         </ul><p>A key range, consisting of a <codeph>startkey</codeph> and <codeph>endkey</codeph>.
            These options can be used individually, or together, as
            follows: <ul>
               <li><codeph>startkey</codeph> only <p>Output does not start until the first
                     occurrence of <codeph>startkey</codeph>, or a value greater than the specified value, is seen.
                     Output will then continue until the end of the view.</p></li>
               <li><codeph>endkey</codeph> only <p>Output starts with the first view result, and continues until the last occurrence of <codeph>endkey</codeph>, or until the emitted value is greater than the computed lexical value of <codeph>endkey</codeph>.</p></li>
               <li><codeph>startkey</codeph> and <codeph>endkey</codeph> <p>Output of values does not start until <codeph>startkey</codeph> is seen, and stops when the last occurrence of <codeph>endkey</codeph> is identified.</p></li>
            </ul></p>
<p>When using <codeph>endkey</codeph>, the <codeph>inclusive_end</codeph> option specifies
            whether output stops after the last occurrence of the specified <codeph>endkey</codeph>
            (the default). If set to false, output stops on the last result before the specified
               <codeph>endkey</codeph> is seen.</p><p>The matching algorithm works on partial
            values, which can be used to an advantage when searching for ranges of keys.</p>
         
         <note type="note">Do not use the <codeph>inclusive_end</codeph> parameter with <codeph>key</codeph> 
            or <codeph>keys</codeph> parameters. 
            The <codeph>inclusive_end</codeph> parameter is not designed to work with <codeph>key</codeph> 
            or <codeph>keys</codeph> because it is an attribute of range operations.</note>
      
      
      </section>
      
      
      
      <section><title>Selecting compound information by key or keys</title><p>If you are generating
            a compound key within your view, for example when outputting a date split into
            individually year, month, day elements, then the selection value must exactly match the
            format and size of your compound key. The value of <codeph>key</codeph> or
               <codeph>keys</codeph> must exactly match the output key structure.</p>
         
         
         <p>For example,
            with the view
            data:</p><codeblock><codeph>{"total_rows":5693,"rows":[
{"id":"1310653019.12667","key":[2011,7,14,14,16,59],"value":null},
{"id":"1310662045.29534","key":[2011,7,14,16,47,25],"value":null},
{"id":"1310668923.16667","key":[2011,7,14,18,42,3],"value":null},
{"id":"1310675373.9877","key":[2011,7,14,20,29,33],"value":null},
{"id":"1310684917.60772","key":[2011,7,14,23,8,37],"value":null},
{"id":"1310693478.30841","key":[2011,7,15,1,31,18],"value":null},
{"id":"1310694625.02857","key":[2011,7,15,1,50,25],"value":null},
{"id":"1310705375.53361","key":[2011,7,15,4,49,35],"value":null},
{"id":"1310715999.09958","key":[2011,7,15,7,46,39],"value":null},
{"id":"1310716023.73212","key":[2011,7,15,7,47,3],"value":null}
]
}
</codeph></codeblock><p>Using
            the <codeph>key</codeph> selection mechanism you must specify the entire key value,
            i.e.:</p><codeblock><codeph>?key=[2011,7,15,7,47,3]
</codeph></codeblock><p>If you
            specify a value, such as only the
            date:</p><codeblock><codeph>?key=[2011,7,15]
</codeph></codeblock><p>The view will
            return no records, since there is no exact key match. Instead, you must use a range that
            encompasses the information range you want to
            output:</p><codeblock><codeph>?startkey=[2011,7,15,0,0,0]&amp;endkey=[2011,7,15,99,99,99]
</codeph></codeblock><p>This
            will output all records within the specified range for the specified date. </p></section>
      
      
      
      <section><title>Partial selection and key ranges</title><p>Matching of the key value has a
            precedence from right to left for the key value and the supplied
               <codeph>startkey</codeph> and/or <codeph>endkey</codeph>. Partial strings may
            therefore be specified and return specific information.</p><p>For example, given the
            view
            data:</p><codeblock><codeph>"a",
 "aa",
 "bb",
 "bbb",
 "c",
 "cc",
 "ccc"
 "dddd"
</codeph></codeblock><p>Specifying
            a <codeph>startkey</codeph> parameter with the value “aa” will return the last seven
            records, including
            “aa”:</p><codeblock><codeph>"aa",
 "bb",
 "bbb",
 "c",
 "cc",
 "ccc",
 "dddd"
</codeph></codeblock><p>Specifying
            a partial string to <codeph>startkey</codeph> will trigger output of the selected values
            as soon as the first value or value greater than the specified value is identified. For
            strings, this partial match (from left to right) is identified. For example, specifying
            a <codeph>startkey</codeph> of “d” will
            return:</p><codeblock><codeph>"dddd"
</codeph></codeblock><p>This is because the first
            match is identified as soon as the a key from a view row matches the supplied
               <codeph>startkey</codeph> value <i>from left to right</i>. The supplied single
            character matches the first character of the view output.</p><p>When comparing larger
            strings and compound values the same matching algorithm is used. For example, searching
            a database of ingredients and specifying a <codeph>startkey</codeph> of “almond” will
            return all the ingredients, including “almond”, “almonds”, and “almond
            essence”.</p><p>To match all of the records for a given word or value across the entire
            range, you can use the null value in the <codeph>endkey</codeph> parameter. For example,
            to search for all records that start only with the word “almond”, you specify a
               <codeph>startkey</codeph> of “almond”, and an endkey of “almond\u02ad” (i.e. with the
            last Latin character at the end). If you are using Unicode strings, you may want to use
            “\uefff”.</p><codeblock><codeph>startkey="almond"&amp;endkey="almond\u02ad"
</codeph></codeblock><p>The
            precedence in this example is that output starts when ‘almond’ is seen, and stops when
            the emitted data is lexically greater than the supplied <codeph>endkey</codeph>.
            Although a record with the value “almond\02ad” will never be seen, the emitted data will
            eventually be lexically greater than “almond\02ad” and output will stop.</p><p>In
            effect, a range specified in this way acts as a prefix with all the data being output
            that match the specified
            prefix.</p></section>
      
      
      
      <section><title>Partial selection with compound keys</title><p>Compound keys, such as arrays
            or hashes, can also be specified in the view output, and the matching precedence can be
            used to provide complex selection ranges. For example, if time data is emitted in the
            following
            format:</p><codeblock><codeph>[year,month,day,hour,minute]
</codeph></codeblock><p>Then
            precise date (and time) ranges can be selected by specifying the date and time in the
            generated data. For example, to get information between 1st April 2011, 00:00 and 30th
            September 2011,
            23:59:</p><codeblock><codeph>?startkey=[2011,4,1,0,0]&amp;endkey=[2011,9,30,23,59]
</codeph></codeblock><p>The
            flexible structure and nature of the <codeph>startkey</codeph> and
               <codeph>endkey</codeph> values enable selection through a variety of range
            specifications. For example, you can obtain all of the data from the beginning of the
            year until the 5th March
            using:</p><codeblock><codeph>?startkey=[2011]&amp;endkey=[2011,3,5,23,59]
</codeph></codeblock><p>You
            can also examine data from a specific date through to the end of the
            month:</p><codeblock><codeph>?startkey=[2011,3,16]&amp;endkey=[2011,3,99]
</codeph></codeblock><p>In
            the above example, the value for the <codeph>day</codeph> element of the array is an
            impossible value, but the matching algorithm will identify when the emitted value is
            lexically greater than the supplied <codeph>endkey</codeph> value, and information
            selected for output will be stopped.</p><p>A limitation of this structure is that it is
            not possible to ignore the earlier array values. For example, to select information from
            10am to 2pm each day, you cannot use this parameter
            set:</p><codeblock><codeph>?startkey=[null,null,null,10,0]&amp;endkey=[null,null,null,14,0]
</codeph></codeblock><p>In
            addition, because selection is made by a outputting a range of values based on the start
            and end key, you cannot specify range values for the date portion of the
            query:</p><codeblock><codeph>?startkey=[0,0,0,10,0]&amp;endkey=[9999,99,99,14,0]
</codeph></codeblock><p>This
            will instead output all the values from the first day at 10am to the last day at
            2pm.</p></section>
      
      
      
      <section><title>Pagination</title><p>Pagination over results can be achieved by using the
               <codeph>skip</codeph> and <codeph>limit</codeph> parameters. For example, to get the
            first 10 records from the
            view:</p><codeblock><codeph>?limit=10
</codeph></codeblock><p>The next ten records can
            obtained by
            specifying:</p><codeblock><codeph>?skip=10&amp;limit=10
</codeph></codeblock><p>On the
            server, the <codeph>skip</codeph> option works by executing the query and literally
            iterating over the specified number of output records specified by
            <codeph>skip</codeph>, then returning the remainder of the data up until the specified
               <codeph>limit</codeph> records are reached, if the <codeph>limit</codeph> parameter
            is specified.</p><p>When paginating with larger values for <codeph>skip</codeph>, the
            overhead for iterating over the records can be significant. A better solution is to
            track the document id output by the first query (with the <codeph>limit</codeph>
            parameter). You can then use <codeph>startkey_docid</codeph> to specify the last
            document ID seen, skip over that record, and output the next ten
            records.</p><p>Therefore, the paging sequence is, for the first
            query:</p><codeblock><codeph>?startkey="carrots"&amp;limit=10
</codeph></codeblock><p>Record
            the last document ID in the generated output, then
            use:</p><codeblock><codeph>?startkey="carrots"&amp;startkey_docid=DOCID&amp;skip=1&amp;limit=10
</codeph></codeblock><p>When
            using <codeph>startkey_docid</codeph> you must specify the <codeph>startkey</codeph>
            parameter to specify the information being searched for. By using the
               <codeph>startkey_docid</codeph> parameter, Couchbase Server skips through the B-Tree
            index to the specified document ID. This is much faster than the skip/limit example
            shown
            above.</p></section>
      
      
      
      <section><title>Grouping in queries</title><p>If you have specified an array as your compound
            key within your view, then you can specify the group level to be applied to the query
            output when using a <codeph>reduce()</codeph>.</p><p>When grouping is enabled, the view
            output is grouped according to the key array, and you can specify the level within the
            defined array that the information is grouped by. You do this by specifying the index
            within the array by which you want the output grouped using the
               <codeph>group_level</codeph> parameter.</p>
         
         <fig>
            <image href="images/views-grouping.png" width="450">
               </image>
            </fig>
         
         <p>The <codeph>group_level</codeph> parameter specifies the
            array index (starting at 1) at which you want the grouping occur, and generate a unique
            value based on this value that is used to identify all the items in the view output that
            include this unique value:</p><ul>
            <li><p>A group level of <codeph>0</codeph> groups by the entire data set (as if no array exists).</p></li>
            <li><p>A group level of <codeph>1</codeph> groups the content by the unique value of the
                  first element in the view key array. For example, when outputting a date split by
                  year, month, day, hour, minute, each unique year will be output.</p></li>
            <li><p>A group level of <codeph>2</codeph> groups the content by the unique value of the
                  first and second elements in the array. With a date, this outputs each unique year
                  and month, including all records with that year and month into each
               group.</p></li>
            <li><p>A group level of <codeph>3</codeph> groups the content by the unique value of the
                  first three elements of the view key array. In a date this outputs each unique
                  date (year, month, day) grouping all items according to these first three
                  elements.</p></li>
         </ul><p>The grouping will work for any output structure where you have output an compound
            key using an array as the output value for the
            key.</p></section>
      
      
      
      <section><title>Selection when grouping</title><p>When using grouping and selection using the
               <codeph>key</codeph>, <codeph>keys</codeph>, or <codeph>startkey</codeph> /
               <codeph>endkey</codeph> parameters, the query value should match at least the format
            (and element count) of the group level that is being queried.</p><p>For example, using
            the following <codeph>map()</codeph> function to output information by date as an
            array:</p><codeblock><codeph>function(doc, meta)
{
  emit([doc.year, doc.mon, doc.day], doc.logtype);
}
</codeph></codeblock>
         
         <p>If you specify a <codeph>group_level</codeph> of <codeph>2</codeph> then you must
            specify a key using at least the year and month information. For example, you can
            specify an explicit key, such as <codeph>[2012,8]</codeph> :</p>
         <codeblock><codeph>?group_level=2&amp;key=[2012,8]</codeph></codeblock>
         <p>You can query it for a range:</p>
         <codeblock><codeph>?group_level=2&amp;startkey=[2012,2]&amp;endkey=[2012,8]
</codeph></codeblock>
         <p>You can also specify a year, month and day, while still grouping at a higher level. For
            example, to group by year/month while selecting by specific dates:</p>
         <codeblock><codeph>?group_level=2&amp;startkey=[2012,2,15]&amp;endkey=[2012,8,10]
</codeph></codeblock>
         <p>Specifying compound keys that are shorter than the specified group level may output
            unexpected results due to the selection mechanism and the way <codeph>startkey</codeph>
            and <codeph>endkey</codeph> are used to start and stop the selection of output rows.</p>
      
      </section>
      
      <section id="ordering"><title>Ordering</title><p>All view results are automatically output sorted, with the
            sorting based on the content of the key in the output view. Views are sorted using a
            specific sorting format, with the basic order for all basic and compound follows as
            follows:</p><ul>
            <li><p><codeph>null</codeph></p></li>
            <li><p><codeph>false</codeph></p></li>
            <li><p><codeph>true</codeph></p></li>
            <li><p>Numbers</p></li>
            <li><p>Text (case sensitive, lowercase first, UTF-8 order)</p></li>
            <li><p>Arrays (according to the values of each element, in order)</p></li>
            <li><p>Objects (according to the values of keys, in key order)</p></li>
         </ul><p>The natural sorting is therefore by default close to natural sorting order both
            alphabetically (A-Z) and numerically (0-9).</p><p>There is no collation or foreign
            language support. Sorting is always according to the above rules based on UTF-8
            values.</p><p>You can alter the direction of the sorting (reverse, highest to lowest
            numerically, Z-A alphabetically) by using the <codeph>descending</codeph> option. When
            set to true, this reverses the order of the view results, ordered by their
            key.</p><p>Because selection is made after sorting the view results, if you configure
            the results to be sorted in descending order and you are selecting information using a
            key range, then you must also reverse the <codeph>startkey</codeph> and
               <codeph>endkey</codeph> parameters. For example, if you query ingredients where the
            start key is ‘tomato’ and the end key is ‘zucchini’, for
            example:</p><codeblock><codeph>?startkey="tomato"&amp;endkey="zucchini"
</codeph></codeblock><p>The
            selection will operate, returning information when the first key matches ‘tomato’ and
            stopping on the last key that matches ‘zucchini’.</p><p>If the return order is
            reversed:</p><codeblock><codeph>?descending=true&amp;startkey="tomato"&amp;endkey="zucchini"
</codeph></codeblock><p>The
            query will return only entries matching ‘tomato’. This is because the order will be
            reversed, ‘zucchini’ will appear first, and it is only when the results contain ‘tomato’
            that any information is returned.</p><p>To get all the entries that match, the
               <codeph>startkey</codeph> and <codeph>endkey</codeph> values must also be
            reversed:</p><codeblock><codeph>?descending=true&amp;startkey="zucchini"&amp;endkey="tomato"
</codeph></codeblock><p>The
            above selection will start generating results when ‘zucchini’ is identified in the key,
            and stop returning results when ‘tomato’ is identified in the key.</p><p>View output and
            selection are case sensitive. Specifying the key ‘Apple’ will not return ‘apple’ or
            ‘APPLE’ or other case differences. Normalizing the view output and query input to all
            lowercase or upper case will simplify the process by eliminating the case
            differences.</p></section>
      
      
      
      <section><title>Understanding letter ordering in views</title><p>Couchbase Server uses a
            Unicode collation algorithm to order letters, so you should be aware of how this
            functions. Most developers are typically used to Byte order, such as that found in ASCII
            and which is used in most programming languages for ordering strings during string
            comparisons.</p><p>The following shows the order of precedence used in Byte order, such
            as ASCII:</p><codeblock><codeph>123456890 &lt; A-Z &lt; a-z
</codeph></codeblock><p>This
            means any items that start with integers will appear before any items with letters; any
            items that beginning with capital letters will appear before items in lower case
            letters. This means the item named “Apple” will appear before “apple” and the item
            “Zebra” will appear before “apple”. Compare this with the order of precedence used in
            Unicode collation, which is used in Couchbase
            Server:</p><codeblock><codeph>123456790 &lt; aAbBcCdDeEfFgGhH...
</codeph></codeblock><p>Notice
            again that items that start with integers will appear before any items with letters.
            However, in this case, the lowercase and then uppercase of the same letter are grouped
            together. This means that that if “apple” will appear before “Apple” and would also
            appear before “Zebra.” In addition, be aware that with accented characters will follow
            this
            ordering:</p><codeblock><codeph>a &lt; á &lt; A &lt; Á &lt; b
</codeph></codeblock><p>This
            means that all items starting with “a” <i>and accented variants of the letter</i> will
            occur before “A” and any accented variants of “A.”</p><p><b>Ordering
            Example</b></p><p>In Byte order, keys in an index would appear as
            follows:</p><codeblock><codeph>"ABC123" &lt; "ABC223" &lt; "abc123" &lt; "abc223" &lt; "abcd23" &lt; "bbc123" &lt; "bbcd23"
</codeph></codeblock><p>The
            same items will be ordered this way by Couchbase Server under Unicode
            collation:</p><codeblock><codeph>"abc123" &lt; "ABC123" &lt; "abc223" &lt; "ABC223" &lt; "abcd23" &lt; "bbc123" &lt; "bbcd23"
</codeph></codeblock><p>This
            is particularly important for you to understand if you query Couchbase Server with a
               <codeph>startkey</codeph> and <codeph>endkey</codeph> to get back a range of results.
            The items you would retrieve under Byte order are different compared to Unicode
            collation. </p>
         
         <p><b>Ordering and Query Example</b></p><p>This
            following example demonstrates Unicode collation in Couchbase Server and the impact on
            query results returned with a <codeph>startkey</codeph> and <codeph>endkey</codeph>. It
            is based on the <codeph>beer-sample</codeph> database provided with Couchbase Server.
            </p><p>Imagine you want to retrieve all breweries with names starting
            with uppercase Y. Your query parameters would appear as
            follows:</p><codeblock><codeph>startkey="Y"&amp;endkey="z"
</codeph></codeblock><p>If
            you want breweries starting with lowercase y <i>or</i> uppercase Y, you would provides a
            query as
            follows:</p><codeblock><codeph>startkey="y"&amp;endkey="z"
</codeph></codeblock><p>This
            will return all names with lower case Y and items up to, but not including lowercase z,
            thereby including uppercase Y as well. To retrieve the names of breweries starting with
            lowercase y only, you would terminate your range with capital
            Y:</p><codeblock><codeph>startkey="y"&amp;endkey="Y"
</codeph></codeblock><p>As it
            happens, the sample database does not contain any results because there are no beers in
            it which start with lowercase <codeph>y</codeph>.</p></section>
      
      
      
      <section><title>Error control</title><p>There are a number of parameters that can be used to
            help control errors and responses during a view query.</p><ul>
            <li><codeph>on_error</codeph></li>
         </ul><p>The <codeph>on_error</codeph> parameter specifies whether the view results will be
            terminated on the first error from a node, or whether individual nodes can fail and
            other nodes return information.</p><p>When returning the information generated by a view
            request, the default response is for any raised error to be included as part of the JSON
            response, but for the view process to continue. This permits for individual nodes within
            the Couchbase cluster to timeout or fail, while still generating the requested view
            information.</p><p>In this instance, the error is included as part of the JSON
            returned:</p>
         
         <codeblock>{
   "errors" : [
      {
         "from" : "http://192.168.1.80:9503/_view_merge/?stale=false",
         "reason" : "req_timedout"
      },
      {
         "from" : "http://192.168.1.80:9502/_view_merge/?stale=false",
         "reason" : "req_timedout"
      },
      {
         "from" : "http://192.168.1.80:9501/_view_merge/?stale=false",
         "reason" : "req_timedout"
      }
   ],
   "rows" : [
      {
         "value" : 333280,
         "key" : null
      }
   ]
}</codeblock>
         <p>You
            can alter this behavior by using the <codeph>on_error</codeph> argument. The default
            value is <codeph>continue</codeph>. If you set this value to <codeph>stop</codeph> then
            the view response will cease the moment an error occurs. The returned JSON will contain
            the error information for the node that returned the first error. For
         example:</p><codeblock><codeph>{
   "errors" : [
      {
         "from" : "http://192.168.1.80:9501/_view_merge/?stale=false",
         "reason" : "req_timedout"
      }
   ],
   "rows" : [
      {
         "value" : 333280,
         "key" : null
      }
   ]
}</codeph></codeblock></section>
      <section><title>Querying using spatial views</title>
         <p>Spatial views support a variety of different use cases including multidimensional analysis, geographical data, and a combination of both. </p> 
         <p>For details see <xref
               href="../indexes/querying-using-spatial-views.dita#concept_hlq_bhb_ys"/>.</p>
      </section>
      
      
      
   </body>
  
</topic>
