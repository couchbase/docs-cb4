<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xml:lang="en-us" id="concept227">
	<title>Getting started</title>
	<shortdesc>To follow the tradition of programming tutorials, here's a Hello Couchbase example to
		help you get started with the C SDK. Running this example will verify that the C SDK is
		installed properly on your machine and show you how to perform some simple operations on
		Couchbase Server.</shortdesc>
	<conbody>
		
		<section>
			<title>Building and running Hello Couchbase</title>
			
			<p>Here's the Hello Couchbase code:</p>
			<codeblock outputclass="language-c" spectitle="hello.c">#include &lt;libcouchbase/couchbase.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h>

static void storage_callback(lcb_t instance, const void *cookie, lcb_storage_t op, 
   lcb_error_t err, const lcb_store_resp_t *resp)
{
  printf("Stored %.*s\n", (int)resp->v.v0.nkey, resp->v.v0.key);
}

static void get_callback(lcb_t instance, const void *cookie, lcb_error_t err, 
   const lcb_get_resp_t *resp)
{
  printf("Retrieved key %.*s\n", (int)resp->v.v0.nkey, resp->v.v0.key);
  printf("Value is %.*s\n", (int)resp->v.v0.nbytes, resp->v.v0.bytes);
}

int main(void)
{

  // initializing
  
  struct lcb_create_st cropts = { 0 };
  cropts.version = 3;
  cropts.v.v3.connstr = "couchbase://localhost/default";
  lcb_error_t err;
  lcb_t instance;
  err = lcb_create(&amp;instance, &amp;cropts);
  if (err != LCB_SUCCESS) {
    printf("Couldn't create instance!\n");
    exit(1);
  }
  
  // connecting
  
  lcb_connect(instance);
  lcb_wait(instance);
  if ( (err = lcb_get_bootstrap_status(instance)) != LCB_SUCCESS ) {
    printf("Couldn't bootstrap!\n");
    exit(1);
  }
  
  // installing callbacks
  
  lcb_set_store_callback(instance, storage_callback);
  lcb_set_get_callback(instance, get_callback);
  
  
  // scheduling operations
  
  lcb_store_cmd_t scmd = { 0 };
  const lcb_store_cmd_t *scmdlist = &amp;scmd;
  scmd.v.v0.key = "Hello";
  scmd.v.v0.nkey = 5;
  scmd.v.v0.bytes = "Couchbase";
  scmd.v.v0.nbytes = 9;
  scmd.v.v0.operation = LCB_SET;
  err = lcb_store(instance, NULL, 1, &amp;scmdlist);
  if (err != LCB_SUCCESS) {
    printf("Couldn't schedule storage operation!\n");
    exit(1);
  }
  lcb_wait(instance); //storage_callback is invoked here
  
  lcb_get_cmd_t gcmd = { 0 };
  const lcb_get_cmd_t *gcmdlist = &amp;gcmd;
  gcmd.v.v0.key = "Hello";
  gcmd.v.v0.nkey = 5;
  err = lcb_get(instance, NULL, 1, &amp;gcmdlist);
  if (err != LCB_SUCCESS) {
    printf("Couldn't schedule get operation!\n");
    exit(1);
  }
  lcb_wait(instance); // get_callback is invoked here
  lcb_destroy(instance);
  return 0;
}</codeblock>
		    <p> Compile and run Hello Couchbase by using the following commands:
		        <codeblock outputclass="language-bash">$ gcc hello.c -o hello -lcouchbase
$ ./hello</codeblock></p>
		    <p>The program output, which is generated by the callback functions, looks like this:</p>
		    <codeblock>Stored Hello
Retrieved key Hello
Value is Couchbase</codeblock>
		    <note>For brevity, examples in this manual are written using the C99 standard. Some compilers
        (notably, Visual Studio versions earlier than 2013) do not support the C99 standard
        (supporting only C89). A minimal example, somewhat equivalent to the one above, you can find
        in the <xref
          href="https://github.com/couchbase/libcouchbase/blob/master/example/minimal/minimal.c"
          format="html" scope="external">repository</xref>.</note>
		</section>
	    <section>
	        <title> Code description</title>
	        <p>The following points explain each step in the Hello Couchbase code example:</p>
				<ul>
					<li>Initializing <p>A connection to a bucket within the cluster is represented by the
              <apiname>lcb_t</apiname> handle that is a library-allocated handle. The handle is
            first initialized with a <i>Connection String</i> containing the server's address
              (<i>localhost</i>) and the bucket name (<i>default</i>). The connection string is
            placed into the creation options structure (<apiname>lcb_create_st</apiname>), and that
            is passed to the <apiname>lcb_create()</apiname> function that creates the new instance.
          </p></li>
					<li>Connecting <p>After the instance has been initialized, it is ready to be connected. Use the
              <apiname>lcb_connect</apiname><i>()</i> function, which schedules a connection to the
            network. After the connection has been scheduled, you must wait for the connection to
            complete. Waiting for operations to complete is done by the
              <apiname>lcb_wait()</apiname> call, which blocks the application. (The library can
            also be used in non-blocking models, but that is not shown in this example.) After the
            wait is complete, the <apiname>lcb_get_bootstrap_status()</apiname> function is called
            to determine whether the initial connection was successful.</p></li>
					
					<li>Installing callbacks <p>The library delivers most operation status codes and responses via
							specially installed callbacks that are invoked for each operation of a given
							type. This example installs callbacks for storage operations and retrieval
							operations. The contents of the arguments for each callback consists of the
							response data for a given operation (the <codeph>resp</codeph> argument) and
							user-associated context information for the operation (the
								<codeph>cookie</codeph> argument). It also contains success/failure
							information in the <codeph>err</codeph> argument. </p></li>
					<li>Scheduling operations <p>After the callbacks have been installed, operations to store and
							retrieve an item from the cluster are initialized. The operations are expressed
							in terms of <term>command structures</term>. The command structure for storing
							an item is <apiname>lcb_store_cmd_t</apiname> and is initialized with the key
							and value and item to be stored. The command structure for retrieving an item
							is <apiname>lcb_get_cmd_t</apiname> and is initialized with the key to
							retrieve. </p></li>
				</ul>
			
		</section>
	</conbody>
</concept>
