<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic xml:lang="en-us" id="topic21758">
   <title>Querying MapReduce Views</title>
   <shortdesc>The content of the key that is generated by the <codeph>emit()</codeph> function
      provides information on how the data is selected from your view.</shortdesc>
   <body>
      <p>In order to query a view, the view definition must include a suitable map function that
         uses the <codeph>emit()</codeph> function to generate each row of information. </p>
      <p>The key can be used when querying a view as the selection mechanism, either by using
         an:</p>
      <ul>
         <li>
            <p><i>explicit key</i> — show all the records matching the exact structure of the
               supplied key.</p>
         </li>
         <li>
            <p><i>list of keys</i> — show all the records matching the exact structure of each of
               the supplied keys (effectively showing keya or keyb or keyc).</p>
         </li>
         <li>
            <p><i>range of keys</i> — show all the records starting with keyA and stopping on the
               last instance of keyB.</p>
         </li>
      </ul>
      <p>When querying the view results, a number of parameters can be used to select, limit, order
         and otherwise control the execution of the view and the information that is returned.</p>
      <p>When a view is accessed without specifying any parameters, the view produces results
         matching the following:</p>
      <ul>
         <li>
            <p>Full view specification, i.e. all documents are potentially output according to the
               view definition.</p>
         </li>
         <li>
            <p>Limited to 10 items within the web console, unlimited through the REST API.</p>
         </li>
         <li>
            <p>Reduce function used if defined in the view.</p>
         </li>
         <li>
            <p>Items sorted in ascending order (using UTF-8 comparison for strings, natural number
               order)</p>
         </li>
      </ul>
      <p>View results and the parameters operate and interact in a specific order. The interaction
         directly affects how queries are written and data is selected.</p>
      <fig>
         <image href="images/views-query-flow.png" width="480">
            <alt/>
         </image>
      </fig>
      <p>The core arguments and selection systems are the same through both the REST API interface,
         and the client libraries. The setting of these values differs between different client
         libraries, but the argument names and expected and supported values are the same across all
         environments.</p>
      <section><title>Querying</title><p>Querying can be performed through the REST API endpoint.
            The REST API supports and operates using the core HTTP protocol, and this is the same
            system used by the client libraries to obtain the view data.</p> To retrieve views
         information, access any server node in a cluster on port 8092. <p>The following is the HTTP
            method and URI used to query
            views:</p><codeblock>GET /[bucket-name]/_design/[ddoc-name]/_view/[view-name]</codeblock><p>Where:</p><ul>
            <li>bucket-name is the name of the bucket.</li>
            <li>ddoc-name is the name of the design document that contains the view.</li>
            <li>view-name is the name of the corresponding view within the design document.</li>
         </ul><p>Development view, the <codeph>ddoc-name</codeph> is prefixed with
               <codeph>dev_</codeph>. For example, the design document <codeph>beer</codeph> is
            accessible as a development view using <codeph>dev_beer</codeph>.</p><p>Production views
            are accessible using their name only.</p>
         <p>Parameters (optional):</p>
         <table>
            <title>Views parameters</title>
            <tgroup cols="3">
               <colspec colname="col1" colwidth="1*"/>
               <colspec colname="col2" colwidth="1*"/>
               <colspec colname="col3" colwidth="3.96*"/>
               <thead>
                  <row>
                     <entry>Parameters</entry>
                     <entry>Type</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry><codeph>descending</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Return the documents in descending by key order.</entry>
                  </row>
                  <row>
                     <entry><codeph>endkey</codeph></entry>
                     <entry>string</entry>
                     <entry>Stop returning records when the specified key is reached. Key must be
                        specified as a JSON value.</entry>
                  </row>
                  <row>
                     <entry><codeph>endkey_docid</codeph></entry>
                     <entry>string</entry>
                     <entry>Stop returning records when the specified document ID is
                        reached.</entry>
                  </row>
                  <row>
                     <entry><codeph>full_set</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Use the full cluster data set (development views only).</entry>
                  </row>
                  <row>
                     <entry><codeph>group</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Group the results using the reduce function to a group or single row.
                        Note: Do not use <codeph>group</codeph> with <codeph>group_level</codeph>
                        because they are not compatible.</entry>
                  </row>
                  <row>
                     <entry><codeph>group_level</codeph></entry>
                     <entry>numeric</entry>
                     <entry>Specify the group level to be used. Note: Do not use
                           <codeph>group_level</codeph> with <codeph>group</codeph> because they are
                        not compatible.</entry>
                  </row>
                  <row>
                     <entry><codeph>inclusive_end</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Specifies whether the specified end key is included in the result. Note:
                        Do not use <codeph>inclusive_end</codeph> with <codeph>key</codeph> or
                           <codeph>keys</codeph>.</entry>
                  </row>
                  <row>
                     <entry><codeph>key</codeph></entry>
                     <entry>string</entry>
                     <entry>Return only documents that match the specified key. Key must be
                        specified as a JSON value.</entry>
                  </row>
                  <row>
                     <entry><codeph>keys</codeph></entry>
                     <entry>array</entry>
                     <entry>Return only documents that match each of keys specified within the given
                        array. Key must be specified as a JSON value. Sorting is not applied when
                        using this option.</entry>
                  </row>
                  <row>
                     <entry><codeph>limit</codeph></entry>
                     <entry>numeric</entry>
                     <entry>Limit the number of the returned documents to the specified
                        number.</entry>
                  </row>
                  <row>
                     <entry><codeph>on_error</codeph></entry>
                     <entry>string</entry>
                     <entry>Sets the response in the event of an error. <p>Supported values: <ul>
                              <li><codeph>continue</codeph> : Continue to generate view information
                                 in the event of an error, including the error information in the
                                 view response stream.</li>
                              <li><codeph>stop</codeph> : Stop immediately when an error condition
                                 occurs. No further view information is returned.</li>
                           </ul></p>
                     </entry>
                  </row>
                  <row>
                     <entry><codeph>reduce</codeph></entry>
                     <entry>boolean</entry>
                     <entry>Use the reduction function.</entry>
                  </row>
                  <row>
                     <entry><codeph>skip</codeph></entry>
                     <entry>numeric</entry>
                     <entry>Skip this number of records before starting to return the
                        results.</entry>
                  </row>
                  <row>
                     <entry><codeph>stale</codeph></entry>
                     <entry>string</entry>
                     <entry>Allow the results from a stale view to be used. <p>Supported values: <ul>
                              <li><codeph>false</codeph> : The server waits for the indexer to
                                 finish the changes that correspond to the current key-value
                                 document set and then returns the latest entries from the view
                                 index.</li>
                              <li><codeph>ok</codeph> : The server returns the current entries from
                                 the index file including the stale views.</li>
                              <li><codeph>update_after</codeph> : The server returns the current
                                 entries from the index, and then initiates an index update.</li>
                           </ul></p></entry>
                  </row>
                  <row>
                     <entry><codeph>startkey</codeph></entry>
                     <entry>string</entry>
                     <entry>Return records with a value equal to or greater than the specified key.
                        Key must be specified as a JSON value.</entry>
                  </row>
                  <row>
                     <entry><codeph>startkey_docid</codeph></entry>
                     <entry>string</entry>
                     <entry>Return records starting with the specified document ID.</entry>
                  </row>
               </tbody>
            </tgroup>
         </table>
         <p>Curl request syntax:</p>
         <codeblock>GET http://[localhost]:8092/[bucket-name]/_design/[ddoc-name]/_view/[view-name]</codeblock>
         <p>To access a view stored within an SASL password-protected bucket, include the bucket
            name and bucket password within the URL of the request:</p>
         <codeblock>GET http://[bucket-name]:[password]@[localhost]:8092/[bucket-name]/_design/[ddoc-name]/_view/[view-name]
</codeblock>
         <note type="note">Additional arguments to the URL request can be used to select information
            from the view, and provide limit, sorting and other options.</note>
         <p>To output only ten items:</p>
         <codeblock>GET http://[localhost]:8092/[bucket-name]/_design/[ddoc-name]/_view/[view-name]?limit=10
</codeblock>
         <note type="important">The formatting of the URL follows the HTTP specification. The first
            argument is separated from the base URL using a question mark ( <codeph>?</codeph> ).
            Additional arguments are separated using an ampersand ( <codeph>&amp;</codeph> ).
            Special characters are quoted or escaped according to the HTTP standard rules.</note>
      </section>
      <section>
         <title>Selecting information</title>
         <p>Couchbase Server supports a number of mechanisms for selecting information returned by
            the view. Key selection is made after the view results (including the reduction
            function) are executed, and after the items in the view output have been sorted.</p>
         <p>When specifying keys to the selection mechanism, the key must be expressed in the form
            of a JSON value. For example, when specifying a single key, a string must be quoted
            ("string").</p>
         <p>When specifying the key selection through a parameter, the keys must match the format of
            the keys emitted by the view. Compound keys, for example where an array or hash has been
            used in the emitted key structure, the supplied selection value should also be an array
            or a hash.</p>
         <p>The following selection types are supported:</p>
         <ul>
            <li><b>Explicit Key</b></li>
         </ul>
         <p>An explicit key can be specified using the parameter <codeph>key</codeph>. The view
            query will only return results where the key in the view output, and the value supplied
            to the <codeph>key</codeph> parameter match identically.</p>
         <p>For example, if you supply the value "tomato" only records matching <i>exactly</i>
            "tomato" will be selected and returned. Keys with values such as "tomatoes" will not be
            returned.</p>
         <ul>
            <li><b>Key List</b></li>
         </ul>
         <p>A list of keys to be output can be specified by supplying an array of values using the
               <codeph>keys</codeph> parameter. In this instance, each item in the specified array
            will be used as explicit match to the view result key, with each array value being
            combined with a logical <codeph>or</codeph>.</p>
         <p>For example, if the value specified to the <codeph>keys</codeph> parameter was
               <codeph>["tomato","avocado"]</codeph>, then all results with a key of ‘tomato’
               <i>or</i> ‘avocado’ will be returned.</p>
         <p>When using this query option, the output results are not sorted by key. This is because
            key sorting of these values would require collating and sorting all the rows before
            returning the requested information.</p>
         <p>In the event of using a compound key, each compound key must be specified in the query.
            For example:</p>
         <codeblock>```
keys=[["tomato",20],["avocado",20]]
```
</codeblock>
         <ul>
            <li><b>Key Range</b></li>
         </ul>
         <p>A key range, consisting of a <codeph>startkey</codeph> and <codeph>endkey</codeph>.
            These options can be used individually, or together, as follows:</p>
         <codeblock>* `startkey` only

  Output does not start until the first occurrence of `startkey`, or a value
  greater than the specified value, is seen. Output will then continue until the
  end of the view.

* `endkey` only

  Output starts with the first view result, and continues until the last
  occurrence of `endkey`, or until the emitted value is greater than the computed
  lexical value of `endkey`.

* `startkey` and `endkey`

  Output of values does not start until `startkey` is seen, and stops when the
  last occurrence of `endkey` is identified.
</codeblock>
         <p>When using <codeph>endkey</codeph>, the <codeph>inclusive_end</codeph> option specifies
            whether output stops after the last occurrence of the specified <codeph>endkey</codeph>
            (the default). If set to false, output stops on the last result before the specified
               <codeph>endkey</codeph> is seen.</p>
         <p>The matching algorithm works on partial values, which can be used to an advantage when
            searching for ranges of keys.</p>
         <note type="note">Do not use the <codeph>inclusive_end</codeph> parameter with
               <codeph>key</codeph> or <codeph>keys</codeph> parameters. The
               <codeph>inclusive_end</codeph> parameter is not designed to work with
               <codeph>key</codeph> or <codeph>keys</codeph> because it is an attribute of range
            operations.</note>
      </section>
      <section>
         <title>Selecting compound information by key or keys</title>
         <p>If you are generating a compound key within your view, for example when outputting a
            date split into individually year, month, day elements, then the selection value must
            exactly match the format and size of your compound key. The value of
               <codeph>key</codeph> or <codeph>keys</codeph> must exactly match the output key
            structure.</p>
         <p>For example, with the view data:</p>
         <codeblock>{"total_rows":5693,"rows":[
{"id":"1310653019.12667","key":[2011,7,14,14,16,59],"value":null},
{"id":"1310662045.29534","key":[2011,7,14,16,47,25],"value":null},
{"id":"1310668923.16667","key":[2011,7,14,18,42,3],"value":null},
{"id":"1310675373.9877","key":[2011,7,14,20,29,33],"value":null},
{"id":"1310684917.60772","key":[2011,7,14,23,8,37],"value":null},
{"id":"1310693478.30841","key":[2011,7,15,1,31,18],"value":null},
{"id":"1310694625.02857","key":[2011,7,15,1,50,25],"value":null},
{"id":"1310705375.53361","key":[2011,7,15,4,49,35],"value":null},
{"id":"1310715999.09958","key":[2011,7,15,7,46,39],"value":null},
{"id":"1310716023.73212","key":[2011,7,15,7,47,3],"value":null}
]
}
</codeblock>
         <p>Using the <codeph>key</codeph> selection mechanism you must specify the entire key
            value, i.e.:</p>
         <codeblock>?key=[2011,7,15,7,47,3]
</codeblock>
         <p>If you specify a value, such as only the date:</p>
         <codeblock>?key=[2011,7,15]
</codeblock>
         <p>The view will return no records, since there is no exact key match. Instead, you must
            use a range that encompasses the information range you want to output:</p>
         <codeblock>?startkey=[2011,7,15,0,0,0]&amp;endkey=[2011,7,15,99,99,99]
</codeblock>
         <p>This will output all records within the specified range for the specified date. </p>
      </section>
      <section>
         <title>Partial selection and key ranges</title>
         <p>Matching of the key value has a precedence from right to left for the key value and the
            supplied <codeph>startkey</codeph> and/or <codeph>endkey</codeph>. Partial strings may
            therefore be specified and return specific information.</p>
         <p>For example, given the view data:</p>
         <codeblock>"a",
 "aa",
 "bb",
 "bbb",
 "c",
 "cc",
 "ccc"
 "dddd"
</codeblock>
         <p>Specifying a <codeph>startkey</codeph> parameter with the value "aa" will return the
            last seven records, including "aa":</p>
         <codeblock>"aa",
 "bb",
 "bbb",
 "c",
 "cc",
 "ccc",
 "dddd"
</codeblock>
         <p>Specifying a partial string to <codeph>startkey</codeph> will trigger output of the
            selected values as soon as the first value or value greater than the specified value is
            identified. For strings, this partial match (from left to right) is identified. For
            example, specifying a <codeph>startkey</codeph> of "d" will return:</p>
         <codeblock>"dddd"
</codeblock>
         <p>This is because the first match is identified as soon as the a key from a view row
            matches the supplied <codeph>startkey</codeph> value <i>from left to right</i>. The
            supplied single character matches the first character of the view output.</p>
         <p>When comparing larger strings and compound values the same matching algorithm is used.
            For example, searching a database of ingredients and specifying a
               <codeph>startkey</codeph> of "almond" will return all the ingredients, including
            "almond", "almonds", and "almond essence".</p>
         <p>To match all of the records for a given word or value across the entire range, you can
            use the null value in the <codeph>endkey</codeph> parameter. For example, to search for
            all records that start only with the word "almond", you specify a
               <codeph>startkey</codeph> of "almond", and an endkey of "almond\u02ad" (i.e. with the
            last Latin character at the end). If you are using Unicode strings, you may want to use
            "\uefff".</p>
         <codeblock>startkey="almond"&amp;endkey="almond\u02ad"
</codeblock>
         <p>The precedence in this example is that output starts when ‘almond’ is seen, and stops
            when the emitted data is lexically greater than the supplied <codeph>endkey</codeph>.
            Although a record with the value "almond\02ad" will never be seen, the emitted data will
            eventually be lexically greater than "almond\02ad" and output will stop.</p>
         <p>In effect, a range specified in this way acts as a prefix with all the data being output
            that match the specified prefix.</p>
      </section>
      <section>
         <title>Partial selection with compound keys</title>
         <p>Compound keys, such as arrays or hashes, can also be specified in the view output, and
            the matching precedence can be used to provide complex selection ranges. For example, if
            time data is emitted in the following format:</p>
         <codeblock>[year,month,day,hour,minute]
</codeblock>
         <p>Then precise date (and time) ranges can be selected by specifying the date and time in
            the generated data. For example, to get information between 1st April 2011, 00:00 and
            30th September 2011, 23:59:</p>
         <codeblock>?startkey=[2011,4,1,0,0]&amp;endkey=[2011,9,30,23,59]
</codeblock>
         <p>The flexible structure and nature of the <codeph>startkey</codeph> and
               <codeph>endkey</codeph> values enable selection through a variety of range
            specifications. For example, you can obtain all of the data from the beginning of the
            year until the 5th March using:</p>
         <codeblock>?startkey=[2011]&amp;endkey=[2011,3,5,23,59]
</codeblock>
         <p>You can also examine data from a specific date through to the end of the month:</p>
         <codeblock>?startkey=[2011,3,16]&amp;endkey=[2011,3,99]
</codeblock>
         <p>In the above example, the value for the <codeph>day</codeph> element of the array is an
            impossible value, but the matching algorithm will identify when the emitted value is
            lexically greater than the supplied <codeph>endkey</codeph> value, and information
            selected for output will be stopped.</p>
         <p>A limitation of this structure is that it is not possible to ignore the earlier array
            values. For example, to select information from 10am to 2pm each day, you cannot use
            this parameter set:</p>
         <codeblock>?startkey=[null,null,null,10,0]&amp;endkey=[null,null,null,14,0]
</codeblock>
         <p>In addition, because selection is made by a outputting a range of values based on the
            start and end key, you cannot specify range values for the date portion of the
            query:</p>
         <codeblock>?startkey=[0,0,0,10,0]&amp;endkey=[9999,99,99,14,0]
</codeblock>
         <p>This will instead output all the values from the first day at 10am to the last day at
            2pm.</p>
      </section>
      <section>
         <title>Pagination</title>
         <p>Pagination over results can be achieved by using the <codeph>skip</codeph> and
               <codeph>limit</codeph> parameters. For example, to get the first 10 records from the
            view:</p>
         <codeblock>?limit=10
</codeblock>
         <p>The next ten records can obtained by specifying:</p>
         <codeblock>?skip=10&amp;limit=10
</codeblock>
         <p>On the server, the <codeph>skip</codeph> option works by executing the query and
            literally iterating over the specified number of output records specified by
               <codeph>skip</codeph>, then returning the remainder of the data up until the
            specified <codeph>limit</codeph> records are reached, if the <codeph>limit</codeph>
            parameter is specified.</p>
         <p>When paginating with larger values for <codeph>skip</codeph>, the overhead for iterating
            over the records can be significant. A better solution is to track the document id
            output by the first query (with the <codeph>limit</codeph> parameter). You can then use
               <codeph>startkey_docid</codeph> to specify the last document ID seen, skip over that
            record, and output the next ten records.</p>
         <p>Therefore, the paging sequence is, for the first query:</p>
         <codeblock>?startkey="carrots"&amp;limit=10
</codeblock>
         <p>Record the last document ID in the generated output, then use:</p>
         <codeblock>?startkey="carrots"&amp;startkey_docid=DOCID&amp;skip=1&amp;limit=10
</codeblock>
         <p>When using <codeph>startkey_docid</codeph> you must specify the
               <codeph>startkey</codeph> parameter to specify the information being searched for. By
            using the <codeph>startkey_docid</codeph> parameter, Couchbase Server skips through the
            B-Tree index to the specified document ID. This is much faster than the skip/limit
            example shown above.</p>
      </section>
      <section>
         <title>Grouping in queries</title>
         <p>If you have specified an array as your compound key within your view, then you can
            specify the group level to be applied to the query output when using a
               <codeph>reduce()</codeph>.</p>
         <p>When grouping is enabled, the view output is grouped according to the key array, and you
            can specify the level within the defined array that the information is grouped by. You
            do this by specifying the index within the array by which you want the output grouped
            using the <codeph>group_level</codeph> parameter.</p>
         <fig>
            <image href="images/views-grouping.png" width="480">
               <alt/>
            </image>
         </fig>
         <p>The <codeph>group_level</codeph> parameter specifies the array index (starting at 1) at
            which you want the grouping occur, and generate a unique value based on this value that
            is used to identify all the items in the view output that include this unique value:</p>
         <ul>
            <li>
               <p>A group level of <codeph>0</codeph> groups by the entire dataset (as if no array
                  exists).</p>
            </li>
            <li>
               <p>A group level of <codeph>1</codeph> groups the content by the unique value of the
                  first element in the view key array. For example, when outputting a date split by
                  year, month, day, hour, minute, each unique year will be output.</p>
            </li>
            <li>
               <p>A group level of <codeph>2</codeph> groups the content by the unique value of the
                  first and second elements in the array. With a date, this outputs each unique year
                  and month, including all records with that year and month into each group.</p>
            </li>
            <li>
               <p>A group level of <codeph>3</codeph> groups the content by the unique value of the
                  first three elements of the view key array. In a date this outputs each unique
                  date (year, month, day) grouping all items according to these first three
                  elements.</p>
            </li>
         </ul>
         <p>The grouping will work for any output structure where you have output an compound key
            using an array as the output value for the key.</p>
      </section>
      <section>
         <title>Selection when grouping</title>
         <p>When using grouping and selection using the <codeph>key</codeph>, <codeph>keys</codeph>,
            or <codeph>startkey</codeph> / <codeph>endkey</codeph> parameters, the query value
            should match at least the format (and element count) of the group level that is being
            queried.</p>
         <p>For example, using the following <codeph>map()</codeph> function to output information
            by date as an array:</p>
         <codeblock>function(doc, meta)
{
  emit([doc.year, doc.mon, doc.day], doc.logtype);
}
</codeblock>
         <p>If you specify a <codeph>group_level</codeph> of <codeph>2</codeph> then you must
            specify a key using at least the year and month information. For example, you can
            specify an explicit key, such as <codeph>[2012,8]</codeph> :</p>
         <codeblock>?group_level=2&amp;key=[2012,8]</codeblock>
         <p>You can query it for a range:</p>
         <codeblock>?group_level=2&amp;startkey=[2012,2]&amp;endkey=[2012,8]
</codeblock>
         <p>You can also specify a year, month and day, while still grouping at a higher level. For
            example, to group by year/month while selecting by specific dates:</p>
         <codeblock>?group_level=2&amp;startkey=[2012,2,15]&amp;endkey=[2012,8,10]
</codeblock>
         <p>Specifying compound keys that are shorter than the specified group level may output
            unexpected results due to the selection mechanism and the way <codeph>startkey</codeph>
            and <codeph>endkey</codeph> are used to start and stop the selection of output rows.</p>
      </section>
      <section id="ordering">
         <title>Ordering</title>
         <p>All view results are automatically output sorted, with the sorting based on the content
            of the key in the output view. Views are sorted using a specific sorting format, with
            the basic order for all basic and compound follows as follows:</p>
         <ul>
            <li>
               <p><codeph>null</codeph></p>
            </li>
            <li>
               <p><codeph>false</codeph></p>
            </li>
            <li>
               <p><codeph>true</codeph></p>
            </li>
            <li>
               <p>Numbers</p>
            </li>
            <li>
               <p>Text (case sensitive, lowercase first, UTF-8 order)</p>
            </li>
            <li>
               <p>Arrays (according to the values of each element, in order)</p>
            </li>
            <li>
               <p>Objects (according to the values of keys, in key order)</p>
            </li>
         </ul>
         <p>The natural sorting is therefore by default close to natural sorting order both
            alphabetically (A-Z) and numerically (0-9).</p>
         <p>There is no collation or foreign language support. Sorting is always according to the
            above rules based on UTF-8 values.</p>
         <p>You can alter the direction of the sorting (reverse, highest to lowest numerically, Z-A
            alphabetically) by using the <codeph>descending</codeph> option. When set to true, this
            reverses the order of the view results, ordered by their key.</p>
         <p>Because selection is made after sorting the view results, if you configure the results
            to be sorted in descending order and you are selecting information using a key range,
            then you must also reverse the <codeph>startkey</codeph> and <codeph>endkey</codeph>
            parameters. For example, if you query ingredients where the start key is ‘tomato’ and
            the end key is ‘zucchini’, for example:</p>
         <codeblock>?startkey="tomato"&amp;endkey="zucchini"
</codeblock>
         <p>The selection will operate, returning information when the first key matches ‘tomato’
            and stopping on the last key that matches ‘zucchini’.</p>
         <p>If the return order is reversed:</p>
         <codeblock>?descending=true&amp;startkey="tomato"&amp;endkey="zucchini"
</codeblock>
         <p>The query will return only entries matching ‘tomato’. This is because the order will be
            reversed, ‘zucchini’ will appear first, and it is only when the results contain ‘tomato’
            that any information is returned.</p>
         <p>To get all the entries that match, the <codeph>startkey</codeph> and
               <codeph>endkey</codeph> values must also be reversed:</p>
         <codeblock>?descending=true&amp;startkey="zucchini"&amp;endkey="tomato"
</codeblock>
         <p>The above selection will start generating results when ‘zucchini’ is identified in the
            key, and stop returning results when ‘tomato’ is identified in the key.</p>
         <p>View output and selection are case sensitive. Specifying the key ‘Apple’ will not return
            ‘apple’ or ‘APPLE’ or other case differences. Normalizing the view output and query
            input to all lowercase or upper case will simplify the process by eliminating the case
            differences.</p>
      </section>
      <section>
         <title>Understanding letter ordering in views</title>
         <p>Couchbase Server uses a Unicode collation algorithm to order letters, so you should be
            aware of how this functions. Most developers are typically used to Byte order, such as
            that found in ASCII and which is used in most programming languages for ordering strings
            during string comparisons.</p>
         <p>The following shows the order of precedence used in Byte order, such as ASCII:</p>
         <codeblock>123456890 &lt; A-Z &lt; a-z
</codeblock>
         <p>This means any items that start with integers will appear before any items with letters;
            any items that beginning with capital letters will appear before items in lower case
            letters. This means the item named "Apple" will appear before "apple" and the item
            "Zebra" will appear before "apple". Compare this with the order of precedence used in
            Unicode collation, which is used in Couchbase Server:</p>
         <codeblock>123456790 &lt; aAbBcCdDeEfFgGhH...
</codeblock>
         <p>Notice again that items that start with integers will appear before any items with
            letters. However, in this case, the lowercase and then uppercase of the same letter are
            grouped together. This means that that if "apple" will appear before "Apple" and would
            also appear before "Zebra." In addition, be aware that with accented characters will
            follow this ordering:</p>
         <codeblock>a &lt; á &lt; A &lt; Á &lt; b
</codeblock>
         <p>This means that all items starting with "a" <i>and accented variants of the letter</i>
            will occur before "A" and any accented variants of "A."</p>
         <p><b>Ordering Example</b></p>
         <p>In Byte order, keys in an index would appear as follows:</p>
         <codeblock>"ABC123" &lt; "ABC223" &lt; "abc123" &lt; "abc223" &lt; "abcd23" &lt; "bbc123" &lt; "bbcd23"
</codeblock>
         <p>The same items will be ordered this way by Couchbase Server under Unicode collation:</p>
         <codeblock>"abc123" &lt; "ABC123" &lt; "abc223" &lt; "ABC223" &lt; "abcd23" &lt; "bbc123" &lt; "bbcd23"
</codeblock>
         <p>This is particularly important for you to understand if you query Couchbase Server with
            a <codeph>startkey</codeph> and <codeph>endkey</codeph> to get back a range of results.
            The items you would retrieve under Byte order are different compared to Unicode
            collation. </p>
         <p><b>Ordering and Query Example</b></p>
         <p>This following example demonstrates Unicode collation in Couchbase Server and the impact
            on query results returned with a <codeph>startkey</codeph> and <codeph>endkey</codeph>.
            It is based on the <codeph>beer-sample</codeph> database provided with Couchbase Server. </p>
         <p>Imagine you want to retrieve all breweries with names starting with uppercase Y. Your
            query parameters would appear as follows:</p>
         <codeblock>startkey="Y"&amp;endkey="z"
</codeblock>
         <p>If you want breweries starting with lowercase y <i>or</i> uppercase Y, you would
            provides a query as follows:</p>
         <codeblock>startkey="y"&amp;endkey="z"
</codeblock>
         <p>This will return all names with lower case Y and items up to, but not including
            lowercase z, thereby including uppercase Y as well. To retrieve the names of breweries
            starting with lowercase y only, you would terminate your range with capital Y:</p>
         <codeblock>startkey="y"&amp;endkey="Y"
</codeblock>
         <p>As it happens, the sample database does not contain any results because there are no
            beers in it which start with lowercase <codeph>y</codeph>.</p>
      </section>
      <section>
         <title>Error control</title>
         <p>There are a number of parameters that can be used to help control errors and responses
            during a view query.</p>
         <ul>
            <li><codeph>on_error</codeph></li>
         </ul>
         <p>The <codeph>on_error</codeph> parameter specifies whether the view results will be
            terminated on the first error from a node, or whether individual nodes can fail and
            other nodes return information.</p>
         <p>When returning the information generated by a view request, the default response is for
            any raised error to be included as part of the JSON response, but for the view process
            to continue. This permits for individual nodes within the Couchbase cluster to timeout
            or fail, while still generating the requested view information.</p>
         <p>In this instance, the error is included as part of the JSON returned:</p>
         <codeblock>
{
   "errors" : [
      {
         "from" : "http://192.168.1.80:9503/_view_merge/?stale=false",
         "reason" : "req_timedout"
      },
      {
         "from" : "http://192.168.1.80:9502/_view_merge/?stale=false",
         "reason" : "req_timedout"
      },
      {
         "from" : "http://192.168.1.80:9501/_view_merge/?stale=false",
         "reason" : "req_timedout"
      }
   ],
   "rows" : [
      {
         "value" : 333280,
         "key" : null
      }
   ]
}
</codeblock>
         <p>You can alter this behavior by using the <codeph>on_error</codeph> argument. The default
            value is <codeph>continue</codeph>. If you set this value to <codeph>stop</codeph> then
            the view response will cease the moment an error occurs. The returned JSON will contain
            the error information for the node that returned the first error. For example:</p>
         <codeblock>```
{
   "errors" : [
      {
         "from" : "http://192.168.1.80:9501/_view_merge/?stale=false",
         "reason" : "req_timedout"
      }
   ],
   "rows" : [
      {
         "value" : 333280,
         "key" : null
      }
   ]
}
```
</codeblock>
      </section>
   </body>
   <related-links>
      <linklist>       
         <link href="http://www.unicode.org/reports/tr10/" scope="external" format="html">
            <linktext>Unicode Technical Standard #10</linktext>
         </link>
         <link href="http://userguide.icu-project.org/collation/customization#TOC-Default-Options/"
            scope="external" format="html">
            <linktext>ICU User Guide, Customization, Default Options</linktext>
         </link>
      </linklist>
   </related-links>
</topic>
