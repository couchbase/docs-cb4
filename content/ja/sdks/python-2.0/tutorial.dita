<?xml version='1.0' ?><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.1 Topic//EN" "http://docs.oasis-open.org/dita/v1.1/OS/dtd/topic.dtd">
<topic id="tutorial">
	<title>Tutorial</title>
	<body>
		<p>In this chapter we build on the foundations of the 
			<i>Getting Started</i> guide and
			build a simple web application. Make sure you have the 
			<codeph>beer-sample</codeph> bucket
			installed, because we’ll be using it. The sample application will allow you to
			edit and manage various beers and breweries.
		</p>
		<p>The sample application is not entirely complete, and there are some features
			that remain to be implemented. Implementing them is an exercise for the reader.</p>
		<p>The full source code for the sample application is available through
			couchbaselabs on 
			<xref format="html" scope="external" href="https://github.com/couchbaselabs/beersample-python">GitHub</xref>.
		</p>
		<p>Note that the sample application provides more content than described in this
			tutorial, but it should be simple to navigate while reading this tutorial.</p>
	</body>
	<topic id="quickstart">
		<title>Quickstart</title>
		<body>
			<ul>
				<li>Ensure you have Flask installed. You can either install it via your distribution   or use 
					<codeph>pip install Flask</codeph>.
				</li>
				<li>
					<xref format="html" scope="external" href="http://www.couchbase.com/download">Download Couchbase Server</xref> and install it.   Make sure to install the 
					<codeph>beer-sample</codeph> dataset when you run the wizard because   this tutorial application works with it.
				</li>
				<li>Clone the repository and 
					<codeph>cd</codeph> into the directory:
					<codeph>`</codeph>
				</li>
			</ul>
			<p>shell&gt; git clone git://github.com/couchbaselabs/beersample-python
				Cloning into 'beersample-python''
#...
				shell&gt; cd beersample-python

				<codeph>`</codeph>
			</p>
			<ul>
				<li>Some views need to be set up. You can set up the views manually via the Web UI,   or invoke the 
					<codeph>design_setup.py</codeph> script located in the 
					<codeph>beersample-python</codeph>   directory.
					<p></p>   In the 
					<codeph>beer</codeph> design document, create a view called 
					<codeph>by_name</codeph> :
					<codeblock>
    function (doc, meta) {
        if (doc.type &amp;&amp; doc.type == "beer") {
            emit(doc.name, null);
        }
    }
    ```

   Create a design document called `brewery` and add a view called `by_name` :

    ```javascript
    function (doc, meta) {
        if (doc.type &amp;&amp; doc.type == "brewery") {
            emit(doc.name, null);
        }
    }
    ```

 * Invoke the `beer.py` script:&amp;nbsp;
    ```
shell&gt; python beer.py
\* Running on http://0.0.0.0:5000/
\* Restarting with reloader</codeblock>
				</li>
			</ul>
			<codeblock>

 * Navigate to `localhost:5000` and enjoy the application!

&lt;a id="_preparations"&gt;&lt;/a&gt;

## Preparations

In this section we’ll talk a bit about setting up your directory layout and
adding some views in the server before we start dealing with the Python SDK and
Flask itself.

&lt;a id="_project_setup"&gt;&lt;/a&gt;

### Project Setup

Create a project directory named `beer` :
</codeblock>
			<p>shell&gt; mkdir beer
				shell&gt; cd beer
				shell&gt; mkdir templates
				shell&gt; mkdir templates/beer
				shell&gt; mkdir templates/brewery
				shell&gt; mkdir static
				shell&gt; mkdir static/js
				shell&gt; mkdir static/css

				<codeph>`</codeph>
			</p>
			<p>Showing your directory contents displays something like this:</p>
			<codeblock>
shell&gt; find. -type d
./static
./static/js
./static/css
./templates
./templates/brewery
./templates/beer</codeblock>
			<p>To make the application look pretty, we’re incorporating jQuery and Twitter
				Bootstrap. You can either download the libraries and put them in their
				appropriate 
				<codeph>css</codeph> and 
				<codeph>js</codeph> directories (under 
				<codeph>static</codeph> ), or clone the project
				repository and use it from there. If you followed the Quickstart steps, you
				already have the files in your 
				<codeph>beersample-python</codeph> directory. Either way, make
				sure you have the following files in place:
			</p>
			<ul>
				<li>
					<codeph>static/css/beersample.css</codeph>
				</li>
				<li>
					<codeph>static/css/bootstrap.min.css</codeph> (the minified twitter bootstrap library)
				</li>
				<li>
					<codeph>static/css/bootstrap-responsive.min.css</codeph> (the minified responsive layout   classes from bootstrap)
				</li>
				<li>
					<codeph>static/js/beersample.js</codeph>
				</li>
				<li>
					<codeph>static/js/jquery.min.js</codeph> (the jQuery javascript library)
				</li>
			</ul>
			<p>From here on, you should have a bare bones web application configured that has
				all the dependencies included. We’ll now move on and configure the 
				<codeph>beer-sample</codeph>
				bucket the way we need it.
			</p>
		</body>
		<topic id="preparing-the-views">
			<title>Preparing the Views</title>
			<body>
				<p>The 
					<codeph>beer-sample</codeph> bucket comes with a small set of predefined views, but to make
					our application function correctly we need some more. This is also a good chance
					to explore the view management possibilities inside the Web-UI.
				</p>
				<p>Because we want to list beers and breweries by name, we need to define one view
					for each. Head over to the Web-UI and click on the 
					<i>Views</i> menu. Select

					<codeph>beer-sample</codeph> from the drop-down list to switch to the correct bucket. Now click
					on 
					<i>Development Views</i> and then 
					<i>Create Development View</i> to define your first
					view. You need to give it the name of both the design document and the actual
					view. Insert the following names:
				</p>
				<ul>
					<li>Design Document Name: 
						<codeph>_design/dev_beer</codeph>
					</li>
					<li>View Name: 
						<codeph>by_name</codeph>
					</li>
				</ul>
				<p>The next step is to define the 
					<codeph>map</codeph> and (optional) 
					<codeph>reduce</codeph> functions. In our
					examples, we won’t use the reduce functions at all but you can play around and
					see what happens. Insert the following map function (that’s JavaScript) and
					click 
					<codeph>Save</codeph>.
				</p>
				<codeblock>
function (doc, meta) {
  if(doc.type &amp;&amp; doc.type == "beer") {
    emit(doc.name, null);
  }
}</codeblock>
				<p>Every map function takes the full document ( 
					<codeph>doc</codeph> ) and its associated metadata
					( 
					<codeph>meta</codeph> ) as the arguments. You are then free to inspect this data and emit a
					result when you want to have it in your index. In our case, we emit the name of
					the beer ( 
					<codeph>doc.name</codeph> ) when the document both has a 
					<codeph>type</codeph> field and the 
					<codeph>type</codeph>
					is 
					<codeph>beer</codeph>. We don’t need to emit a value — that’s why we are using 
					<codeph>null</codeph> here.
					It’s always advisable to keep the index as small as possible. Resist the urge to
					include the full document through 
					<codeph>emit(meta.id, doc)</codeph>, because it will increase
					the size of your view indexes. If you need to access the full document (or large
					parts), then use 
					<codeph>include_docs</codeph> in the 
					<codeph>query</codeph> method, which returns 
					<codeph>ViewRow</codeph>
					objects together with their documents. You can also call 
					<codeph>cb.get(row.docid)</codeph> to
					get the individual doc for a single row. The resulting retrieval of the document
					might be slightly out of sync with your view, but it will be fast and efficient.
				</p>
				<p>Now we need to define a view for our breweries. You already know how to do this
					— here is all the information you need to create a brewery view:</p>
				<ul>
					<li>Design Document Name: 
						<codeph>_design/dev_brewery</codeph>
					</li>
					<li>View Name: 
						<codeph>by_name</codeph>
					</li>
					<li>Map Function:
						<codeblock>
    function (doc, meta) {
      if(doc.type &amp;&amp; doc.type == "brewery") {
        emit(doc.name, null);
      }
    }
    ```

The final step is to push the design documents in production. While the design
documents are in development, the index is applied only on the local node.
Because we want to have the index on the whole dataset, click the *Publish*
button on both design documents (and accept any pop-up windows that warn you
about overriding the old design documents).

For more information about using views for indexing and querying from Couchbase
Server, see the following helpful resources in the [Couchbase Server
Manual](http://www.couchbase.com/docs/couchbase-manual-2.1.0/index.html) :

 * General information: [Views and
   Indexes](http://www.couchbase.com/docs/couchbase-manual-2.1.0/couchbase-views.html).

 * Sample patterns: [View and Query Pattern
   Samples](http://www.couchbase.com/docs/couchbase-manual-2.1.0/couchbase-views-sample-patterns.html).

 * Time stamp patterns: Many developers ask about extracting information based on
   date or time. To find out more, see [Date and Time
   Selection](http://www.couchbase.com/docs/couchbase-manual-2.1.0/couchbase-views-sample-patterns-timestamp.html).

&lt;a id="_structure_of_the_Flask_application"&gt;&lt;/a&gt;

### Structure of the Flask Application

We’ll be showing bits and pieces of the web app as it pertains to specific
sections. The entire file is less than 300 lines long, and you can inspect it by
looking into the `beer.py` file in the repository.

First, our imports. We need some extra imports to be able to handle exceptions
properly and let us build better view queries.

### beer.py (imports)


```python
from collections import namedtuple
import json

from Flask import Flask, request, redirect, abort, render_template

from couchbase import Couchbase
from couchbase.exceptions import KeyExistsError, NotFoundError
from couchbase.views.iterator import RowProcessor
from couchbase.views.params import UNSPEC, Query</codeblock>
					</li>
				</ul>
				<codeblock>

Then, we want to set some constants for our application:

### beer.py (configuration)

`DATABASE = 'beer-sample' HOST = 'localhost' ENTRIES_PER_PAGE = 30`

The `ENTRIES_PER_PAGE` variable is used later on to configure how many beers and
breweries to show in the search results.

Now, we’re ready to create our Flask application instance:

### beer.py (creating the application)

```python
app = Flask(__name__, static_url_path='')
app.config.from_object(__name__)</codeblock>
				<p>The first line creates a new Flask application. The first argument is the module
					in which the application is defined. Because we’re using only a single file as
					our application, we can use 
					<codeph>__name__</codeph>, which expands to the name of the current
					file being executed (minus the 
					<codeph>.py</codeph> suffix).
				</p>
				<p>The second argument instructs Flask to treat unrouted URLs as being requests for
					files located in the 
					<codeph>static</codeph> directory we created earlier. This allows our
					templates to load the required 
					<codeph>.js</codeph> and 
					<codeph>.css</codeph> files.
				</p>
				<p>The second line creates a configuration object for our 
					<codeph>app</codeph>. The argument is
					the name of the module to scan for configuration directives. Flask scans this
					module for variable names in 
					<codeph>UPPER_CASE</codeph> and places them in the 
					<codeph>app.config</codeph>
					dictionary.
				</p>
				<p>Then, define a function to give us a database connection:</p>
			</body>
		</topic>
		<topic id="beer-py-generating-a-connection-object">
			<title>beer.py (generating a Connection object)</title>
			<body>
				<codeblock>
def connect_db():
    return Couchbase.connect(
        bucket=app.config['DATABASE'],
        host=app.config['HOST'])

db = connect_db()</codeblock>
				<p>You already know how to connect to a Couchbase cluster, so we’ll skip the
					explanation here.</p>
				<p>The module-level 
					<codeph>db</codeph> variable is set to be the 
					<codeph>Connection</codeph> object. In larger
					applications this is not a good idea, but we can get away with it here because
					this is a simple app.
				</p>
			</body>
		</topic>
	</topic>
	<topic id="the-welcome-page">
		<title>The Welcome Page</title>
		<body>
			<p>The first route we will implement is that of the 
				<codeph>welcome</codeph> page, that is, the
				page that is displayed when someone goes to the root of your site. Because there
				is no Couchbase interaction involved, we just tell Flask to render the template.
			</p>
		</body>
		<topic id="beer-py-welcome-page">
			<title>beer.py (welcome page)</title>
			<body>
				<codeblock>
@app.route('/')
def welcome():
    return render_template('welcome.html')

app.add_url_rule('/welcome', view_func=welcome)</codeblock>
				<p>The 
					<codeph>welcome.html</codeph> template is actually a 
					<i>Jinja</i> template inside the

					<codeph>templates</codeph> directory. It looks like this:
				</p>
			</body>
		</topic>
		<topic id="templates-welcome-html">
			<title>templates/welcome.html</title>
			<body>
				<codeblock>
{% extends "layout.html" %}
{% block body %}
&lt;div class="span6"&gt;
  &lt;div class="span12"&gt;
    &lt;h4&gt;Browse all Beers&lt;/h4&gt;
    &lt;a href="/beers" class="btn btn-warning"&gt;Show me all beers&lt;/a&gt;
    &lt;hr /&gt;
  &lt;/div&gt;
  &lt;div class="span12"&gt;
    &lt;h4&gt;Browse all Breweries&lt;/h4&gt;
    &lt;a href="/breweries" class="btn btn-info"&gt;Take me to the breweries&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="span6"&gt;
&lt;div class="span6"&gt;
  &lt;div class="span12"&gt;
    &lt;h4&gt;About this App&lt;/h4&gt;
    &lt;p&gt;Welcome to Couchbase!&lt;/p&gt;
    &lt;p&gt;This application helps you to get started on application
        development with Couchbase. It shows how to create, update and
        delete documents and how to work with JSON documents.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;

{% endblock %}</codeblock>
				<p>The template simply provides some links to the brewery and beer pages (which are
					shown later).</p>
				<p>An interesting thing about this template is that it "inherits" from the common

					<codeph>layout.html</codeph> template. All pages in the beer app have a common header and
					footer to them — with only their 
					<codeph>body</codeph> differing. This is the 
					<codeph>layout.html</codeph>
					template.
				</p>
			</body>
		</topic>
		<topic id="templates-layout-html">
			<title>templates/layout.html</title>
			<body>
				<codeblock>
&lt;!DOCTYPE HTML&gt;

&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Couchbase Python Beer Sample&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta name="description" content="The Couchbase Java Beer-Sample App"&gt;
    &lt;meta name="author" content="Couchbase, Inc. 2013"&gt;

    &lt;link href="/css/bootstrap.min.css" rel="stylesheet"&gt;
    &lt;link href="/css/beersample.css" rel="stylesheet"&gt;
    &lt;link href="/css/bootstrap-responsive.min.css" rel="stylesheet"&gt;

    &lt;!-- HTML5 shim, for IE6-8 support of HTML5 elements --&gt;
    &lt;!--[if lt IE 9]&gt;
      &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
    &lt;![endif]--&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div class="container-narrow"&gt;
      &lt;div class="masthead"&gt;
        &lt;ul class="nav nav-pills pull-right"&gt;
          &lt;li&gt;&lt;a href="/welcome"&gt;Home&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href="/beers"&gt;Beers&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href="/breweries"&gt;Breweries&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h2 class="muted"&gt;Couchbase Beer Sample&lt;/h2&gt;
      &lt;/div&gt;
      &lt;hr&gt;
      &lt;div class="row-fluid"&gt;
        &lt;div class="span12"&gt;
            {% block body %}{% endblock %}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;hr&gt;
      &lt;div class="footer"&gt;
        &lt;p&gt;&amp;copy; Couchbase, Inc. 2013&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="/js/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="/js/bootstrap.min.js"&gt;&lt;/script&gt;
    &lt;script src="/js/beersample.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</codeblock>
				<p>If you start your app now, you should be able to navigate to 
					<codeph>localhost:5000</codeph>
					and see the welcome page. You’ll get a 404 error if you try to visit any links
					though - this is because we haven’t implemented them yet. Let’s do that now!
				</p>
			</body>
		</topic>
	</topic>
	<topic id="managing-beers">
		<title>Managing Beers</title>
		<body>
			<p>In this section we’ll show the construction of the web app with respect to
				managing beers. We’ll be able to list, inspect, edit, create, search, and delete
				beers.</p>
		</body>
		<topic id="showing-beers">
			<title>Showing Beers</title>
			<body>
				<p>Now we’re finally getting into the cooler stuff of this tutorial. First, we’ll
					implement several classes for our pages to use.</p>
			</body>
		</topic>
		<topic id="beer-py-custom-beer-row-class-and-processing">
			<title>beer.py (custom Beer row class and processing)</title>
			<body>
				<codeblock>
class Beer(object):
    def __init__(self, id, name, doc=None):
        self.id = id
        self.name = name
        self.brewery = None
        self.doc = doc

    def __getattr__(self, name):
        if not self.doc:
            return ""
        return self.doc.get(name, "")


class BeerListRowProcessor(object):
    """
    This is the row processor for listing all beers (with their brewery IDs).
    """
    def handle_rows(self, rows, connection, include_docs):
        ret = []
        by_docids = {}

        for r in rows:
            b = Beer(r['id'], r['key'])
            ret.append(b)
            by_docids[b.id] = b

        keys_to_fetch = [ x.id for x in ret ]
        docs = connection.get_multi(keys_to_fetch, quiet=True)

        for beer_id, doc in docs.items():
            if not doc.success:
                ret.remove(beer)
                continue

            beer = by_docids[beer_id]
            beer.brewery_id = doc.value['brewery_id']

        return ret</codeblock>
				<p>First, we declare a simple 
					<codeph>Beer</codeph> object. This app isn’t too fancy and we
					could’ve just used a simple 
					<codeph>dict</codeph>. However, it allows us to demonstrate the use
					of the 
					<codeph>RowProcessor</codeph> interface.
				</p>
				<p>In the beer listing page, we want to display each beer along with a link to the
					brewery that produces it. However, we’ve defined the 
					<codeph>beer/by_name</codeph> view to
					return only the name of the beer. To obtain the brewery, we need to fetch each
					beer document and examine it. The document contains the Brewery ID that we need
					later.
				</p>
				<p>The 
					<codeph>BeerListRowProcessor</codeph> is an implementation of the 
					<codeph>RowProcessor</codeph> interface
					that operates on the returned view rows.
				</p>
				<p>For each raw JSON row, it creates a new 
					<codeph>Beer</codeph> object. The first argument is the
					document ID, which is used to provide a link to display more information about
					the beer. The second argument is the name of the beer itself, which we use in
					the beer list on the webpage.
				</p>
				<p>We also create a local variable called 
					<codeph>by_docids</codeph> that allows us to get a

					<codeph>Beer</codeph> object by its document ID.
				</p>
				<p>After we’ve created all the beers, we create a list of document IDs to fetch by
					using list comprehension. We pass this list to 
					<codeph>get_multi</codeph> (passing

					<codeph>quiet=True</codeph>, because there might be some inconsistencies between the view
					indexes and the actual documents).
				</p>
				<p>While we could have made this simpler by performing an individual 
					<codeph>get</codeph> on each

					<codeph>beer.id</codeph>, that would be less efficient in terms of network usage.
				</p>
				<p>Now that we have the beer documents, it’s time to set each beer’s 
					<codeph>brewery_id</codeph>
					to its relevant value.
				</p>
				<p>We first check to see that each document was successful in being retrieved; then
					we look up the corresponding 
					<codeph>Beer</codeph> object by getting it from the 
					<codeph>by_docids</codeph>
					dictionary using the 
					<codeph>beer_id</codeph> as the key.
				</p>
				<p>Then, we extract the 
					<codeph>brewery_id</codeph> field from the document and place it into the

					<codeph>Beer</codeph> object.
				</p>
				<p>Finally, we return the list of populated beers. The 
					<codeph>View</codeph> object (returned by
					the 
					<codeph>query</codeph> function) now yields results as we iterate over it.
				</p>
				<p>Before we forget, let’s put this all together:</p>
			</body>
		</topic>
		<topic id="beer-py-showing-beer-listings">
			<title>beer.py (showing beer listings)</title>
			<body>
				<codeblock>
@app.route('/beers')
def beers():
    rp = BeerListRowProcessor()
    rows = db.query("beer", "by_name",
                    limit=ENTRIES_PER_PAGE,
                    row_processor=rp)

    return render_template('beer/index.html', results=rows)</codeblock>
				<p>We tell Flask to route requests to 
					<codeph>/beers</codeph> to this function. We create an
					instance of the 
					<codeph>BeerListRowProcessor</codeph> function we just defined.
				</p>
				<p>We then execute a view query using the 
					<codeph>query</codeph> method, passing it the name of
					the design and view ( 
					<codeph>beer</codeph> and 
					<codeph>by_name</codeph>, respsectively).
				</p>
				<p>We set the 
					<codeph>limit</codeph> directive to the aforementioned 
					<codeph>ENTRIES_PER_PAGE</codeph> directive,
					to avoid flooding a single webpage with many results.
				</p>
				<p>We finally tell the 
					<codeph>query</codeph> method to use our own 
					<codeph>BeerListRowProcessor</codeph> for
					processing the results.
				</p>
				<p>We then direct the template engine to render the 
					<codeph>beer/index.html</codeph> template,
					setting the template variable 
					<codeph>rows</codeph> to the iterable returned by the 
					<codeph>query</codeph>
					function.
				</p>
				<p>Here is the 
					<codeph>beer/index.html</codeph> template:
				</p>
			</body>
		</topic>
		<topic id="templates-beer-index-html">
			<title>templates/beer/index.html</title>
			<body>
				<codeblock>
{% extends "layout.html" %}
{% block body %}

&lt;h3&gt;Browse Beers&lt;/h3&gt;
&lt;form class="navbar-search pull-left"&gt;
    &lt;input id="beer-search" type="text" class="search-query" placeholder="Search for Beers"&gt;
&lt;/form&gt;


&lt;table id="beer-table" class="table table-striped"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Brewery&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {% for beer in results %}
        &lt;tr&gt;
            &lt;td&gt;&lt;a href="/beers/show/{{beer.id}}"&gt;{{beer.name}}&lt;/a&gt;&lt;/td&gt;
            &lt;td&gt;&lt;a href="/breweries/show/{{beer.brewery_id}}"&gt;To Brewery&lt;/a&gt;&lt;/td&gt;
            &lt;td&gt;
                &lt;a class="btn btn-small btn-warning" href="/beers/edit/{{beer.id}}"&gt;Edit&lt;/a&gt;
                &lt;a class="btn btn-small btn-danger" href="/beers/delete/{{beer.id}}"&gt;Delete&lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        {% endfor %}
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;div&gt;
    &lt;a class="btn btn-small btn-success" href="/beers/create"&gt;Add Beer&lt;/a&gt;
&lt;/div&gt;

{% endblock %}</codeblock>
				<p>We’re using 
					<i>Jinja</i>
					<codeph>{% for %}</codeph> blocks to iterate and emit a fragment of HTML
					for each 
					<codeph>Beer</codeph> object returned by the query.
				</p>
				<p>Navigate to 
					<codeph>localhost:5000/beers</codeph>, to see a listing of beers. Each beer has `To
					Brewery
					<codeph>,</codeph>Edit
					<codeph>, and</codeph>Delete` buttons.
				</p>
				<p>On the bottom of the page, you can also see an 
					<codeph>Add Beer</codeph> button, which allows
					you to define new beers.
				</p>
				<p>Let’s implement the 
					<codeph>Delete</codeph> button next!
				</p>
			</body>
		</topic>
		<topic id="deleting-beers">
			<title>Deleting Beers</title>
			<body>
				<p>Due to the simplicity of Couchbase and Flask, we can implement a single method
					to delete both beers and breweries.</p>
			</body>
		</topic>
		<topic id="beer-py-deleting-a-beer">
			<title>beer.py (deleting a beer)</title>
			<body>
				<codeblock>
@app.route('&lt;otype&gt;/delete/&lt;id&gt;')
def delete_object(otype, id):
    try:
        db.delete(id)
        return redirect('/welcome')

    except NotFoundError:
        return "No such {0} '{1}'".format(otype, id), 404</codeblock>
				<p>Here we tell Flask to route any URL that has as its second component the string

					<codeph>delete</codeph> to this method. The paths in 
					<codeph>&lt;angle brackets&gt;</codeph> are routing tokens that
					Flask passes to the handler as arguments. This means that URLs such as

					<codeph>/beers/delete/foobar</codeph> and 
					<codeph>/foo/delete/whatever</codeph> are all routed here.
				</p>
				<p>When we get an ID, we try to delete it by using the 
					<codeph>delete</codeph> method in a 
					<codeph>try</codeph>
					block. If successful, we redirect to the welcome page, but if the key does not
					exist, we return with an error message and a 
					<codeph>404</codeph> status code.
				</p>
				<p>You can now access this page by going to

					<codeph>localhost:5000/beers/delete/nonexistent</codeph> and get a 404 error. Or you can delete
					a beer by clicking on one of the 
					<codeph>Delete</codeph> buttons in the 
					<codeph>/beers</codeph> page!
				</p>
				<p>If you find that a beer is still displayed after you click the delete button,
					you can refresh the browser page to verify that the beer has been deleted.</p>
				<p>Another way to verify that a beer has been deleted is by clicking the delete
					button again and getting a 404 error.</p>
			</body>
		</topic>
		<topic id="displaying-beers">
			<title>Displaying Beers</title>
			<body>
				<p>Here we demonstrate how you can display the beers. In this case, we display a
					page showing all the fields and values of a given beer.</p>
			</body>
		</topic>
		<topic id="beer-py-showing-a-single-beer">
			<title>beer.py (showing a single beer)</title>
			<body>
				<codeblock>
@app.route('/beers/show/&lt;beer_id&gt;')
def show_beer(beer_id):
    doc = db.get(beer_id, quiet=True)
    if not doc.success:
        return "No such beer {0}".format(beer_id), 404


    return render_template(
        'beer/show.html',
        beer=Beer(beer_id, doc.value['name'], doc.value))</codeblock>
				<p>Like for the 
					<codeph>delete</codeph> action, we first check to see that the beer exists. We are
					passed the beer ID as the last part of the URL - this is passed to us as the

					<codeph>beer_id</codeph>.
				</p>
				<p>In order to display the information for the given beer ID, we simply call the
					connection’s 
					<codeph>get</codeph> method with the 
					<codeph>beer_id</codeph> argument. We also pass the 
					<codeph>quiet</codeph>
					parameter so that we don’t receive an exception if the beer does not exist.
				</p>
				<p>We then check to see that the 
					<codeph>success</codeph> property of the returned 
					<codeph>Result</codeph> object
					is true. If it isn’t we return an HTTP 
					<codeph>404</codeph> error.
				</p>
				<p>If the beer exists, we construct a new 
					<codeph>Beer</codeph> object; passing it the ID and the

					<codeph>name</codeph> field within the value dictionary.
				</p>
				<p>We then pass this beer to the 
					<codeph>templates/beer/show.html</codeph> template which we’ll
					show here:
				</p>
			</body>
		</topic>
		<topic id="templates-beer-show-html">
			<title>templates/beer/show.html</title>
			<body>
				<codeblock>
{% extends "layout.html" %}
{% block body %}

{% set display = beer.doc %}
{% set brewery_id = display['brewery_id'] %}

&lt;h3&gt;Show Details for Beer "{{beer.name}}"&lt;/h3&gt;
&lt;table class="table table-striped"&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;strong&gt;brewery_id&lt;/strong&gt;&lt;/td&gt;
            &lt;td&gt;&lt;a href="/breweries/show/{{brewery_id}}"&gt;{{brewery_id}}&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
        {% for k, v in display.items() if not k == "brewery_id" %}
        &lt;tr&gt;
            &lt;td&gt;&lt;strong&gt;{{k}}&lt;/strong&gt;&lt;/td&gt;
            &lt;td&gt;{{v}}&lt;/td&gt;
        &lt;/tr&gt;
        {% endfor %}
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;a class="btn btn-medium btn-warning"
    href="/beers/edit/{{beer.id}}"&gt;Edit&lt;/a&gt;
&lt;a class="btn btn-medium btn-danger"
    href="/beers/delete/{{beer.id}}"&gt;Delete&lt;/a&gt;

{% endblock %}</codeblock>
				<p>Here we make the 
					<codeph>display</codeph> variable in a special 
					<codeph>{% set %}</codeph> directive. This
					makes dealing with the rest of the code simpler.
				</p>
				<p>The next thing we do is extract the 
					<codeph>brewery_id</codeph>, and create a special entry
					with a link pointing to the page to display the actual brewery.
				</p>
				<p>Then we is iterate over the rest of the fields (omitting the brewery ID),
					printing out the key and value of each.</p>
				<p>Finally, we provide links at the bottom to 
					<codeph>Edit</codeph> and 
					<codeph>Delete</codeph> the beer.
				</p>
			</body>
		</topic>
		<topic id="editing-beers">
			<title>Editing Beers</title>
			<body></body>
		</topic>
		<topic id="beer-py-beer-edit-page">
			<title>beer.py (beer edit page)</title>
			<body>
				<codeblock>
def normalize_beer_fields(form):
    doc = {}
    for k, v in form.items():
        name_base, fieldname = k.split('_', 1)
        if name_base != 'beer':
            continue

        doc[fieldname] = v

    if not 'name' in doc or not doc['name']:
        return (None, ("Must have name", 400))

    if not 'brewery_id' in doc or not doc['brewery_id']:
        return (None, ("Must have brewery ID", 400))

    if not db.get(doc['brewery_id'], quiet=True).success:
        return (None,
                ("Brewery ID {0} not found".format(doc['brewery_id']), 400))

    return doc, None

@app.route('/beers/edit/&lt;beer&gt;', methods=['GET'])
def edit_beer_display(beer):
    bdoc = db.get(beer, quiet=True)
    if not bdoc.success:
        return "No Such Beer", 404

    return render_template('beer/edit.html',
                           beer=Beer(beer, bdoc.value['name'], bdoc.value),
                           is_create=False)


@app.route('/beers/edit/&lt;beer&gt;', methods=['POST'])
def edit_beer_submit(beer):
    doc, err = normalize_beer_fields(request.form)

    if not doc:
        return err

    db.set(beer, doc)
    return redirect('/beers/show/' + beer)</codeblock>
				<p>We define two handlers for editing. The first handler is the 
					<codeph>GET</codeph> method for

					<codeph>/beers/edit/&lt;beer&gt;</codeph>, which displays a nice HTML form that we can use to edit
					the beer. It passes the following parameters to the template: the 
					<codeph>Beer</codeph> object
					and a Boolean that indicates this is 
					<i>not</i> a new beer (because the same template
					is also used for the 
					<codeph>Create Beer</codeph> form).
				</p>
				<p>The second handler is the 
					<codeph>POST</codeph> method, which validates the input. The post
					handler calls the 
					<codeph>normalize_beer_fields</codeph> function, which converts the form
					fields into properly formed names for the beer document, checks to see that the
					beer has a valid 
					<codeph>name</codeph>, and checks to see that a 
					<codeph>brewery_id</codeph> is specified and
					that it indeed exists. If all the checks pass, the function returns a tuple of (

					<codeph>doc</codeph>, 
					<codeph>None</codeph> ). The 
					<codeph>POST</codeph> handler checks whether the second element of the
					returned tuple is false. If it is not false, then it’s an error code, and the
					first element is the error message. Otherwise, the first element is the
					document. It then sets the document in Couchbase by using the 
					<codeph>set</codeph> method.
				</p>
				<p>The template is rather wordy because we enumerate all the possible fields with a
					nice description.</p>
			</body>
		</topic>
		<topic id="templates-beer-edit-html">
			<title>templates/beer/edit.html</title>
			<body>
				<codeblock>
{% extends "layout.html" %}
{% block body %}

{% if is_create %}
&lt;h3&gt;Create Beer&lt;/h3&gt;
{% else %}
&lt;h3&gt;Editing {{beer.name}}&lt;/h3&gt;
{% endif %}

&lt;form method="post" action=""&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;General Info&lt;/legend&gt;
    &lt;div class="span12"&gt;
      &lt;div class="span6"&gt;
        &lt;label&gt;Name&lt;/label&gt;
        &lt;input type="text" name="beer_name" placeholder="The name of the beer." value="{{beer.name}}"&gt;

        &lt;label&gt;Description&lt;/label&gt;
        &lt;input type="text" name="beer_description" placeholder="A short description." value="{{beer.description}}"&gt;
      &lt;/div&gt;
      &lt;div class="span6"&gt;
        &lt;label&gt;Style&lt;/label&gt;
        &lt;input type="text" name="beer_style" placeholder="Bitter? Sweet? Hoppy?" value="{{beer.style}}"&gt;

        &lt;label&gt;Category&lt;/label&gt;
        &lt;input type="text" name="beer_category" placeholder="Ale? Stout? Lager?" value="{{beer.category}}"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Details&lt;/legend&gt;
    &lt;div class="span12"&gt;
      &lt;div class="span6"&gt;
        &lt;label&gt;Alcohol (ABV)&lt;/label&gt;
        &lt;input type="text" name="beer_abv" placeholder="The beer's ABV" value="{{beer.abv}}"&gt;

        &lt;label&gt;Biterness (IBU)&lt;/label&gt;
        &lt;input type="text" name="beer_ibu" placeholder="The beer's IBU" value="{{beer.ibu}}"&gt;
      &lt;/div&gt;
      &lt;div class="span6"&gt;
        &lt;label&gt;Beer Color (SRM)&lt;/label&gt;
        &lt;input type="text" name="beer_srm" placeholder="The beer's SRM" value="{{beer.srm}}"&gt;

        &lt;label&gt;Universal Product Code (UPC)&lt;/label&gt;
        &lt;input type="text" name="beer_upc" placeholder="The beer's UPC" value="{{beer.upc}}"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Brewery&lt;/legend&gt;
    &lt;div class="span12"&gt;
      &lt;div class="span6"&gt;
        &lt;label&gt;Brewery&lt;/label&gt;
        &lt;input type="text" name="beer_brewery_id" placeholder="The brewery" value="{{beer.brewery_id}}"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/fieldset&gt;
  &lt;div class="form-actions"&gt;
      &lt;button type="submit" class="btn btn-primary"&gt;Save changes&lt;/button&gt;
  &lt;/div&gt;
&lt;/form&gt;

{% endblock %}</codeblock>
				<p>The template first checks the 
					<codeph>is_create</codeph> variable. If it’s 
					<codeph>False</codeph>, then we’re
					editing an existing beer, and the caption is filled with that name. Otherwise,
					it’s titled as 
					<codeph>Create Beer</codeph>.
				</p>
			</body>
		</topic>
		<topic id="creating-beers">
			<title>Creating Beers</title>
			<body>
				<p>Creating beers is largely the same as editing beers:</p>
			</body>
		</topic>
		<topic id="beer-py-create-beer-page">
			<title>beer.py (create beer page)</title>
			<body>
				<codeblock>
@app.route('/beers/create')
def create_beer_display():
    return render_template('beer/edit.html', beer=Beer('', ''), is_create=True)


@app.route('/beers/create', methods=['POST'])
def create_beer_submit():
    doc, err = normalize_beer_fields(request.form)

    if not doc:
        return err

    id = '{0}-{1}'.format(doc['brewery_id'],
                          doc['name'].replace(' ', '_').lower())

    try:
        db.add(id, doc)
        return redirect('/beers/show/' + id)

    except KeyExistsError:
        return "Beer already exists!", 400</codeblock>
				<p>Here we display the same form as the one for editing beers, except we set the

					<codeph>is_create</codeph> parameter to True, and pass an empty 
					<codeph>Beer</codeph> object. This is
					necessary because the template still tries to populate the form fields with

					<i>existing</i> values.
				</p>
				<p>In the 
					<codeph>POST</codeph> handler, we call 
					<codeph>normalize_beer_field</codeph> as above when editing
					beers.
				</p>
				<p>Because we’re creating a 
					<i>new</i> beer, we use the 
					<codeph>add</codeph> method instead. This
					raisew an exception if the beer already exists. We catch this and display it to
					the user.
				</p>
				<p>If everything went well, the user is redirected to the beer display page for the
					newly created beer.</p>
			</body>
		</topic>
		<topic id="searching-beers">
			<title>Searching Beers</title>
			<body>
				<p>In the beer listing page above, you might have noticed a search box at the top.
					We can use it to dynamically filter our table based on user input. We’ll use
					Javascript at the client layer to perform the querying and filtering, and views
					with range queries at the server (Flask) layer to return the results.</p>
				<p>Before we implement the Python-level search method, we need to put the following
					in the 
					<codeph>static/js/beersample.js</codeph> file (if it’s not there already) to listen on
					search box changes and update the table with the resulting JSON (which is
					returned from the search method):
				</p>
			</body>
		</topic>
		<topic id="static-js-beersample-js-snippet">
			<title>static/js/beersample.js (snippet)</title>
			<body>
				<codeblock>
$(document).ready(function() {

    /**
     * AJAX Beer Search Filter
     */
    $("#beer-search").keyup(function() {
       var content = $("#beer-search").val();
       if(content.length &gt;= 0) {
           $.getJSON("/beers/search", {"value": content}, function(data) {
               $("#beer-table tbody tr").remove();
               for(var i=0;i&lt;data.length;i++) {
                   var html = "&lt;tr&gt;";
                   html += "&lt;td&gt;&lt;a href=\"/beers/show/"+data[i].id+"\"&gt;"+data[i].name+"&lt;/a&gt;&lt;/td&gt;";
                   html += "&lt;td&gt;&lt;a href=\"/breweries/show/"+data[i].brewery+"\"&gt;To Brewery&lt;/a&gt;&lt;/td&gt;";
                   html += "&lt;td&gt;";
                   html += "&lt;a class=\"btn btn-small btn-warning\" href=\"/beers/edit/"+data[i].id+"\"&gt;Edit&lt;/a&gt;\n";
                   html += "&lt;a class=\"btn btn-small btn-danger\" href=\"/beers/delete/"+data[i].id+"\"&gt;Delete&lt;/a&gt;";
                   html += "&lt;/td&gt;";
                   html += "&lt;/tr&gt;";
                   $("#beer-table tbody").append(html);
               }
           });
       }
    });
});</codeblock>
				<p>The code waits for keyup events on the search field, and if they happen, it
					issues an AJAX query on the search function within the app. The search handler
					computes the result (using views) and returns it as JSON. The JavaScript then
					clears the table, iterates over the results, and creates new rows.</p>
				<p>The search handler looks like this:</p>
			</body>
		</topic>
		<topic id="beer-py-ajax-search-response">
			<title>beer.py (ajax search response)</title>
			<body>
				<codeblock>
def return_search_json(ret):
    response = app.make_response(json.dumps(ret))
    response.headers['Content-Type'] = 'application/json'
    return response

@app.route('/beers/search')
def beer_search():
    value = request.args.get('value')
    q = Query()
    q.mapkey_range = [value, value + Query.STRING_RANGE_END]
    q.limit = ENTRIES_PER_PAGE

    ret = []

    rp = BeerListRowProcessor()
    res = db.query("beer", "by_name",
                   row_processor=rp,
                   query=q,
                   include_docs=True)

    for beer in res:
        ret.append({'id' : beer.id,
                    'name' : beer.name,
                    'brewery' : beer.brewery_id})

    return return_search_json(ret)</codeblock>
				<p>The 
					<codeph>beer_search</codeph> function first extracts the user input by examining the query
					string from the request.
				</p>
				<p>It then creates a 
					<codeph>Query</codeph> object. The 
					<codeph>Query</codeph> object's 
					<codeph>mapkey_range</codeph> property
					is set to a list of two elements; the first is the user input, and the second is
					the user input with the magic 
					<codeph>STRING_RANGE_END</codeph> string appended to it. This
					form of range indicates that all keys that start with the user input ( 
					<codeph>value</codeph> )
					are returned. If we just provided a single element, the results would also
					contain matches that are lexically greater than the user input; if we just
					provided the same value for the second and first elements, only items that match
					the string exactly are returned.
				</p>
				<p>The special 
					<codeph>STRING_RANGE_END</codeph> is actually a 
					<codeph>u"\u0FFF"</codeph> UTF-8 character, which
					for the view engine means "end here." You need to get used to it a bit, but it’s
					actually very neat and efficient.
				</p>
				<p>We re-use our 
					<codeph>BeerListRowProcessor</codeph> class to filter the results here (because
					the data required is the same as that of the beer listing ( 
					<codeph>beer/index.html</codeph> )
					page.
				</p>
				<p>However we need to return a JSON array of</p>
				<codeblock>
{ "id" : "beer_id", "name" : "beer_name", "brewery" : "the_brewery_id" }</codeblock>
				<p>so we need to convert the rows into JSON first. This is done by the

					<codeph>return_search_json</codeph> function.
				</p>
				<p>Now your search box should work nicely.</p>
			</body>
		</topic>
	</topic>
	<topic id="managing-breweries">
		<title>Managing Breweries</title>
		<body>
			<p>While this is implemented in the repository above, it is left as an exercise to
				the reader to work out some more details.</p>
		</body>
	</topic>
	<topic id="wrapping-up">
		<title>Wrapping Up</title>
		<body>
			<p>The tutorial presents an easy approach to start a web application with Couchbase
				Server as the underlying data source. If you want to dig a little bit deeper,
				[the full source code in the couchbaselabs repository on
				GitHub](https://github.com/couchbaselabs/beersample-python) has more code to
				learn from. This code might be extended and updated from time to time.</p>
			<p>Of course, this is only the starting point for Couchbase, but together with the
				Getting Started Guide, you should now be well equipped to start exploring
				Couchbase Server on your own. Have fun working with Couchbase!</p>
		</body>
		<topic id="food-for-thought">
			<title>Food For Thought</title>
			<body>
				<p>Some things are not implemented in the example. Here's some ideas for features
					you might add while learning to use the SDK:</p>
				<ul>
					<li>When deleting a brewery, ensure it has no beers dependent on it.</li>
					<li>Provide a search where one can query beers belonging to a given brewery.</li>
					<li>Handle concurrent updates to a beer and/or brewery.</li>
					<li>Implement a 
						<i>like</i> feature, where one can like a beer or a brewery; likewise,   they can unlike one as well!
					</li>
				</ul>
			</body>
		</topic>
	</topic>
</topic>
