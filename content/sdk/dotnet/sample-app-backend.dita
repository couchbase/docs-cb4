<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="java-sample-app-backend">
  <title>.NET Sample App backend tutorial</title>
  <titlealts><navtitle>Sample App backend in .NET</navtitle></titlealts>
  <shortdesc>The .NET SDK tutorial bridges the gap between simple and advanced concepts by walking
        through a complete web application.</shortdesc>
    <body>

        <section>
            <p>The full source code for the tutorial is available <xref
                    href="https://github.com/couchbaselabs/try-cb-dotnet/" scope="external"
                    format="html"> on GitHub couchbaselabs/try-cb-dotnet</xref>. The primary focus of
                the tutorial is to explain the function and theory behind the Couchbase .NET client
                and how it works together with Couchbase Server, and especially new features in
                versions 4.0/4.5 like <codeph>N1QL</codeph>, <codeph>FTS</codeph> and
                    <codeph>sub-document</codeph>. It makes use of the
                    <codeph>travel-sample</codeph> data set. The code that generates the web
                application is provided with the source code, but is not discussed in this tutorial. </p>
        </section>

        <section>
            <title>Specific .NET prerequisites and set up</title>
            <p> In addition to the prerequisites mentioned in <xref
                    href="../sample-application.dita"/>, you'll need: <ul>
                    <li>Visual Studio 2015 (Community is fine)</li>
                </ul></p>
            <p> To get set up for the tutorial proper, follow these steps: <ul>
                    <li><codeph>git clone
                            https://github.com/couchbaselabs/try-cb-dotnet.git</codeph> or <xref
                            href="https://github.com/couchbaselabs/try-cb-dotnet/releases/tag/v2.0.0"
                            format="zip" scope="external">download the source</xref>
                    </li>
                    <li>if you don't want to connect to localhost, change the couchbaseServer entry
                        in <codeph>src/try-cb-dotnet/Web.config</codeph></li>
                    <li>open the project in Visual Studio and build the project, nuget references
                        will be restored automatically</li>
                </ul></p>
            <note type="note"> If you want to code it yourself, the real work is done in the
                following classes: <ul>
                    <li><codeph>src/try-cb-dotnet/Controllers/AirportController.cs</codeph></li>
                    <li><codeph>src/try-cb-dotnet/Controllers/FlightPathsController.cs</codeph></li>
                    <li><codeph>src/try-cb-dotnet/Controllers/HotelController.cs</codeph></li>
                    <li><codeph>src/try-cb-dotnet/Controllers/UserController.cs</codeph></li>
                    <li><codeph>src/try-cb-dotnet/App_Start/CouchbaseConfig.cs</codeph></li>
                </ul><p>There's currently no "fill-in-the-blanks" branch so you'll have to delete
                    method bodies and try to take it from there.</p></note>

            <note type="tip"> This tutorial focuses on querying through N1QL and FTS rather than
                views. If you want information about using views, see the following resources: <ul>
                    <li>General Information about views: <xref
                            href="../../architecture/incremental-map-reduce-views.dita"/>
                    </li>
                    <li>Querying views:<xref
                            href="../../indexes/querying-using-map-reduce-views.dita"/></li>
                </ul></note>
        </section>

        <section>
            <title>Configure and Bootstrap the SDK</title>
        </section>

        <section>
            <title>Key/Value: Users</title>
            <b>Where</b>: <codeph>src/try-cb-dotnet/Controllers/UserController.cs</codeph>
            <p><b>Goals</b>: Use <codeph>Bucket</codeph>'s Key/Value operations and discover the
                    <codeph>Document</codeph> API.</p>
            <b>Relevant Documentation Topics</b>: <xref href="document-operations.dita"/>, <xref
                href="async-programming.dita"/>
            <p>Couchbase is a document oriented database which provides access to your data both
                through its document ID (for high performance access), as well as through map/reduce
                views and N1QL (SQL like query language).</p> This is noticeable in the API, where
            the methods reflect Key/Value operations (<codeph>get</codeph>, <codeph>create</codeph>,
            etc...) and work with a <codeph>Document&lt;T></codeph> interface that has an
                <codeph>Id</codeph> and a <codeph>Content</codeph>. <p>Typically, in this type of
                scenario we would implement the Repository pattern to separte functional logic from
                business logic. However, to make this sample as easy to get up to speed with we're
                just using controllers.</p>
            <b>Creating new users</b>
            <p>For the purposes of this sample application we require users to register before they
                can book flights. All the user related operations are going to exist in the
                UserController.</p><p>The SignUp method is where new users are registered. The
                method takes a LoginModel (src/Models/LoginModel.cs) as the only method parameter.
                ASP.NET has an automatic model binder where it can map a POST request's properties
                to a custom class, like the LoginModel. The property types and names have to match
                for it to assign the
                value.<codeblock outputclass="language-csharp">public async Task&lt;IHttpActionResult> SignUp(LoginModel model)</codeblock></p><p>We
                do the normal things first and validate the model to ensure we have a non-empty
                username and password fields and then check if the username already exists. For the
                purposes of this sample app, our user document keys are in the format
                    <codeph>user::&lt;username></codeph>. We use the <codeph>ExistsAsync</codeph>
                method to do a non-blocking check to see if the document already exists in our
                bucket.</p><codeblock outputclass="language-csharp">var userKey = CreateUserKey(model.Username);
if (await _bucket.ExistsAsync(userKey))
{
    return Content(HttpStatusCode.Conflict, new Error($"Username '{model.Username}' already exists"));
}</codeblock><p>Next
                we create a document with the user details and store it in Couchbase. We are using
                the <codeph>userKey</codeph> we created earlier and are also including a document
                expiry time if one was set on the model. Because we don't want to store plain text
                passwords, we're MD5 hashing the passwords before storing it on the user document.
                <codeblock outputclass="language-csharp">var userDoc = new Document&lt;User>
{
    Id = userKey,
    Content = new User
    {
        Username = model.Username,
        Password = CalcuateMd5Hash(model.Password)
    },
    Expiry = model.Expiry
};

var result = await _bucket.InsertAsync(userDoc);</codeblock></p><p>We're
                using the non-blocking <codeph>InsertAsync</codeph> to ensure we are using not
                blocking a thread waiting for the response from Couchbase. Once our code receives
                the response, it continues where it left off.</p><p>The last thing we do is create a
                security token for the browser so we know additional requests are for a valid user.
                For this we use a JWT (JSON Web Token) which includes the username in a list of
                claims and is then encrypted with a secret key. Our secret is stored in the
                    <codeph>Web.Config</codeph>.<codeblock outputclass="language-csharp">var data = new
{
    token = BuildToken(model.Username)
};
var context = $"Created user with ID '{userKey}' in bucket '{_bucket.Name}' that expires in {userDoc.Expiry}ms";
return Content(HttpStatusCode.Accepted, new Result(data, context));</codeblock></p><p>The
                response content has two parts, the first is the JWT and the second part is a
                narration string which is something our frontend app understands and will display in
                a sort of console. The narration enables the users of the application to get an idea
                of what is going on on the server side while browsing the app. It is kind of like a
                log, but transmitted to the frontend.</p>
            <b>Loging in signed up Users</b>
            <p>The <codeph>Login</codeph> method enables users who have already signed up to sign in
                and use our application. The Login method signatre looks like
                this:<codeblock outputclass="language-csharp">public async Task&lt;IHttpActionResult> Login(LoginModel model)</codeblock>The
                    <codeph>LoginModel</codeph> includes <codeph>Username</codeph> and
                    <codeph>Password</codeph> properties that we can use to find the user document
                and verify the passwords.</p><p>First we need to retrieve the user document and then
                check the password matches with our model. We need to build the user document key
                using the model's username property then we try to get the document from
                Couchbase.<codeblock outputclass="language-csharp">var userKey = CreateUserKey(model.Username);
var userDocument = await _bucket.GetDocumentAsync&lt;User>(userKey);</codeblock></p><p>And
                now we have a user document, we can check the passwords match but remember we hashed
                the password in our document for added security so we'll need to do the same with
                the model's password to compare
                them.<codeblock outputclass="language-csharp">var user = userDocument.Content;
if (user.Password != CalcuateMd5Hash(model.Password))
{
    return Content(HttpStatusCode.Unauthorized, new Error("Invalid username and/or password"));
}</codeblock></p><p>Now
                all that is left to do is create the security token like we did for the
                    <codeph>SignUp</codeph> method and return it. We also create a narration to go
                in the response content for the frontend app to report
                on.<codeblock outputclass="language-csharp">var data = new
{
    token = BuildToken(user.Username)
};
var context = $"User {model.Username} logged in successfully";
return Content(HttpStatusCode.OK, new Result(data, context));</codeblock></p><p><b>Getting
                    a user's stored flights</b></p><p>We need a way to retrieve the flights that a
                user has booked. The <codeph>GetFlightsForUser</codeph> method does this in our
                app.<codeblock outputclass="language-csharp">public async Task&lt;IHttpActionResult> GetFlightsForUser(string username)</codeblock></p><p>This
                is going to be the first time we check for a valid security token that we have only
                created so far. Our security token is fairly simple and only includes the username
                of our user but that is enough for our sample application. To verify the token we
                need to get the <codeph>authentication</codeph> header and then decrypt it. If we
                have any problems, we return either an 401 (Unauthorized) or a 403 (Forbidden)
                response.
                <codeblock outputclass="language-csharp">var authHeaderValue = GetAuthHeaderValue(Request.Headers);
if (string.IsNullOrEmpty(authHeaderValue))
{
    return Content(HttpStatusCode.Unauthorized, string.Empty);
}
if (!VerifyToken(authHeaderValue, username))
{
    return Content(HttpStatusCode.Forbidden, string.Empty);
}</codeblock></p><p>The
                username is passed in as one of the method parameters, so we can use that to create
                the user document key and get the document from
                Couchbase.<codeblock outputclass="language-csharp">var userKey = CreateUserKey(username);
var userDocument = await _bucket.GetDocumentAsync&lt;User>(userKey);</codeblock></p><p>The
                final thing to do is return the list of flights for the user with some narration for
                the frontend application to
                record.<codeblock outputclass="language-csharp">var data = userDocument.Content.Flights;
var context = $"Retrieved flights for user {username}.";
return Content(HttpStatusCode.OK, new Result(data, context));</codeblock></p></section>
        <section id="section_tpl_lcd_gy">
            <title>LINQ: Airports</title>
            <p><b>Where</b>: <codeph>src/try-cb-dotnet/Controllers/AirportController.cs</codeph></p>
            <p><b>Goals</b>: Use the LINQ provider to build N1QL queries to retrieve Aiport
                details.</p>
            <p>LINQ is a standardised way of constructing queries over a data storage engine, such
                as in-memory collections, SQL and even NoSQL like Couchbase. It's a very simple yet
                powerful tool that enables developers to write complicated queries
                programatically.</p>
            <p>In this Controller we are trying to find the Aiport name given some additional
                information about the Airport and we're going to use the LINQ provider to build our
                queries. </p>
            <p>The first query looks for an airport name using it's FAA code.</p>
            <codeblock outputclass="language-sql">airports = _context.Query&lt;Airport>()
    .Where(x => x.Faa == search.ToUpper())
    .Select(x => x.Airportname);
"SELECT airportname FROM `travel-sample` WHERE type = 'airport' AND faa = '{search.ToUpper()}'"</codeblock>
            <p>The second query looks for an airport name using it's ICAO
                code.<codeblock outputclass="language-csharp">airports = _context.Query&lt;Airport>()
    .Where(x => x.Icao == search.ToUpper())
    .Select(x => x.Airportname);
"SELECT airportname FROM `travel-sample` WHERE type = 'airport' AND icao = '{search.ToUpper()}'"</codeblock></p>
            <p>The third query looks for an airport name using it's FAA
                code.<codeblock outputclass="language-csharp">airports = _context.Query&lt;Airport>()
    .Where(x => x.Airportname.Contains(search))
    .Select(x => x.Airportname);
"SELECT airportname FROM `travel-sample` WHERE type = 'airport' AND airportname LIKE '%{search}%'"</codeblock></p>
            <p>Once one of the above queries has been executed, we then need to return the result to
                the frontend application along with a narration of the query that was
                executed.<codeblock outputclass="language-csharp">var data = airports.Select(airportname => new {airportname});
return Content(HttpStatusCode.OK, new Result(data, query));</codeblock></p>
        </section>

        <section>
            <title>N1QL: Flight Paths</title>
            <p><b>Where</b>: <codeph>src/try-cb-dotnet/Controllers/FlightsController.cs</codeph></p>
            <p><b>Goals</b>: Use N1QL to perform <codeph>SELECT</codeph> on Couchbase.</p>
            <p><b>Relevant Documentation Topics</b>: <xref href="n1ql-queries-with-sdk.dita"/>.</p>
            <p>In the SDK, we have a <codeph>query</codeph> method that accepts all variants of
                querying with Couchbase (views, spatial/geo views, N1QL and FTS). For N1QL, the
                    <codeph>IQueryRequest</codeph> is expected. This allows to wrap a N1QL
                    <codeph>Statement</codeph>, use positional parameters and provide query tuning
                (eg Timeout).</p>
            <note type="tip">N1QL is a super-set of SQL, so if you're familiar with SQL you'll feel
                at ease.</note>
            <p>This controller has one method, <codeph>GetFlights</codeph>, which provides flight
                routes between two airports and we're going to use a N1QL query to get them. The
                method has three parameters; <codeph>from</codeph>, <codeph>to</codeph> and
                    <codeph>leave</codeph> (string for departure date). The first thing we do is
                validate the parameters, returining a 500 (InternalServerError) if it's
                not.<codeblock outputclass="language-csharp">if (string.IsNullOrEmpty(from) || string.IsNullOrEmpty(to))
{
    return Content(HttpStatusCode.InternalServerError, new Error("Missing or invalid from and/or to airports"));
}

DateTime leaveDate;
if (!DateTime.TryParse(leave, out leaveDate))
{
    return Content(HttpStatusCode.InternalServerError, new Error("Missing or invalid leave date"));
}

var dayOfWeek = (int) leaveDate.DayOfWeek + 1; // Get weekday number; Sun (0) to Sat (7)</codeblock></p>
            <p>Next we use the <codeph>from</codeph> and <codeph>to</codeph> parameters to get the
                airport FAA code along with it's geo location latitude and longitude.</p>
            <codeblock outputclass="language-sql">var airportQuery = new QueryRequest()
    .Statement("SELECT faa AS fromAirport, geo.lat, geo.lon " +
        "FROM `travel-sample` " +
        "WHERE airportname = $1 " +
        "UNION " +
        "SELECT faa AS toAirport, geo.lat, geo.lon " +
        "FROM `travel-sample` " +
        "WHERE airportname = $2;")
    .AddPositionalParameter(from, to);
var airportQueryResult = await _bucket.QueryAsync&lt;dynamic>(airportQuery);</codeblock>
            <p>After doing some checks to ensure we got results from both airport codes, we then do
                some Geo Location calculations to get the distance between the two airports and the
                estimated travel time. We use the distance and flightTime calculating ticket
                prices.<codeblock outputclass="language-csharp">var fromCoordinate = new GeoCoordinate((double) fromAirport.lat, (double) fromAirport.lon);
var toCoordinate = new GeoCoordinate((double) toAirport.lat, (double) toAirport.lon);
var distance = fromCoordinate.GetDistanceTo(toCoordinate);
var flightTime = Math.Round(distance/AverageFlightSpeed, 2);</codeblock></p>
            <p>Next we have to get all flights between the the two
                airports<codeblock outputclass="language-csharp">var flightQuery = new QueryRequest()
    .Statement("SELECT a.name, s.flight, s.utc, r.sourceairport, r.destinationairport, r.equipment " +
        "FROM `travel-sample` AS r " +
         "UNNEST r.schedule AS s " +
         "JOIN `travel-sample` AS a ON KEYS r.airlineid " +
         "WHERE r.sourceairport = $1 " +
         "AND r.destinationairport = $2 " +
         "AND s.day = $3 " +
         "ORDER BY a.name ASC;")
    .AddPositionalParameter((string) fromAirport.fromAirport, (string) toAirport.toAirport, dayOfWeek);
queries.Add(flightQuery.GetOriginalStatement());</codeblock></p>
            <note type="tip"> Yes, you read that right, N1QL can do joins (on a single bucket or on
                several). It works as long as the "foreign key" described by <codeph>ON
                    KEYS</codeph> clause can be mapped to a document's Key in the joined bucket. </note>
            <p>A specificity of N1QL that we see in the second statement is <codeph>UNNEST</codeph>.
                It extracts a sub-JSON and puts it at the same root level as the bucket (so its
                possible to do joins on each element in this sub-json as if they were entries in a
                left-hand side bucket). </p>
            <p>We now have all flights between the <codeph>from</codeph> and <codeph>to</codeph>
                airports but we don't have any prices. Let's calculate them
                now.<codeblock outputclass="language-csharp">var flights = flightQueryResult.Rows;
foreach (var flight in flights)
{
    flight.FlightTime = flightTime;
    flight.Price = _random.Next(2000);
}</codeblock></p>
        </section>


        <section>
            <title>Indexing the Data: N1QL &amp; GSI</title>
            <p><b>Where</b>: <codeph>src/try-cb-dotnet/App_Start/CouchbaseConfig.cs</codeph></p>
            <p>Index management is a bit more advanced (and is already done when loading the
                sample), so now that you've learned about N1QL, we can take a look. For N1QL to
                work, you must first ensure that at least a <codeph>Primary Index</codeph> has been
                created. For that you can use the DSL from the <codeph>BucketManager</codeph> class: </p>
            <p><b>Goals</b>: Use the Index DSL to make sure data is indexed ready for N1QL to query
                it.</p>
<codeblock outputclass="language-java">bucketManager.CreateN1qlPrimaryIndex(false); // create primary index, and don't defer building it</codeblock>
            <p>The fluent API will guide you with the available options, you just have to declare
                that you want to <codeph>CreateN1qlPrimaryIndex()</codeph>. </p>
            <p>You can also create secondary indexes on specific fields of the JSON, for better
                performance: </p>
<codeblock outputclass="language-java">bucketManager.CreateN1qlIndex("index_name", false, "name", "address", etc);</codeblock>
            <p>In this case, give a name to your index, specify if the index is to be deferred for
                building then an array of property names to index.</p>
        </section>
        <section><title>Full Text Search: Finding Hotels</title><p><b>Where</b>:
                    <codeph>src/try-cb-dotnet/Controllers/HotelController.cs</codeph></p><p><b>Goals</b>:
                Use FTS to search for matching Hotels. Use subdoc API to fetch the relevant data for
                each hit.</p><p><b>Relevant Documentation Topics</b>: <xref
                    href="full-text-searching-with-sdk.dita"/>, <xref
                    href="../subdocument-operations.dita"/>.</p><p>In this service, we look for
                hotels using more fuzzy criterias like the content of the address or the description
                of an hotel, using FTS. Once we get some hits, we fetch only the relevant data for
                each hit to be displayed in the UI using the subdocument API. </p><p>Let's have a
                look at the <codeph>FindHotel</codeph> method. It accepts two parameters,
                    <codeph>location</codeph> and <codeph>description</codeph>, which are the two
                possible refining criterias for an hotel
                search.<codeblock outputclass="language-csharp">public HttpResponseMessage FindHotel(string description = null, string location = null)</codeblock></p><p>A
                    <codeph>ConjunctionQuery</codeph> allows you to combine multiple FTS queries
                into one, in a logical AND fashion. This query includes an exact match criteria that
                restricts it to the <codeph>hotel</codeph> data type (as reflected in the
                    <codeph>type</codeph> field of the JSON
                document).</p><codeblock outputclass="language-java">var query = new ConjunctionQuery(
    new TermQuery("hotel").Field("type")
);</codeblock><p>If
                the user provided a location keyword, we add a second component to the FTS query
                that will look for that keyword in several address-related fields of the document.
                That is done in an OR fashion, using a <codeph>Disjunction</codeph>
                query:</p><codeblock outputclass="language-java">if (!string.IsNullOrEmpty(location) &amp;&amp; location != "*")
{
    query.And(new DisjunctionQuery(
        new PhraseQuery(location).Field("address"),
        new PhraseQuery(location).Field("city"),
        new PhraseQuery(location).Field("state"),
        new PhraseQuery(location).Field("country")
    ));
}</codeblock><p>Similarly,
                if a description keyword was provided by the user, we look at the freeform text
                    <codeph>description</codeph> field and <codeph>name</codeph> field of the
                document:</p><codeblock outputclass="language-java">if (!string.IsNullOrEmpty(description) &amp;&amp; description != "*")
{
    query.And(new DisjunctionQuery(
        new PhraseQuery(description).Field("name"),
        new PhraseQuery(description).Field("description")
    ));
}</codeblock><p>The
                    <codeph>matchPhrase</codeph> FTS query can contain several words and will search
                for variations of the words (eg. including plural forms or words with the same
                root).</p><p>The compound FTS query is now ready to be executed. We build a
                    <codeph>SearchQuery</codeph> object out of it, which also determines which FTS
                index to use ("hotel") and allows us to set various parameters (like a limit of
                maximum 100 hits to return). The query is logged (and kept for narration) then
                executed, returning an <codeph>ISearchQueryResult</codeph>
                object:</p><codeblock outputclass="language-java">var search = new SearchQuery();
search.Index = "hotel";
search.Query = query;
search.Limit(100);</codeblock><p>Next
                we need to iterate over the FTS hits and get the hotel details but we only want to
                parts of the hotel document that will be displayed in the UI. That's where the
                sub-document API comes in!</p><p>Sub-document allows you to fetch or mutate only a
                set of paths inside a JSON document, without having to transmit the whole document
                back and forth. This can save bandwidth if the document is large and the parts that
                we're interested in are few. So here we iterate over the results of the FTS search
                and trigger a subdoc
                call:</p><codeblock outputclass="language-java">var result = _bucket.Query(search);
foreach (var row in result)
{
    var fragment = _bucket.LookupIn&lt;Hotel>(row.Id)
    .Get("name")
        .Get("description")
        .Get("address")
        .Get("city")
        .Get("state")
        .Get("country")
        .Execute();</codeblock><p>Each
                FTS hit is represented as an <codeph>ISearchQueryRow</codeph> which exposes the
                document's <codeph>Id</codeph>. We can use the sub-document API dedicated to
                fetching data (<codeph>bucket.LookupIn&lt;T>(documentId)</codeph>) and specify what
                parts we want: name, description, address, city, state and country. We then
                    <codeph>Execute()</codeph> the sub-document query. In the rest of the code, the
                address-related fields are aggregated together and the data we obtained is
                returned.</p>Now we have the results, we can build up the Hotel objects and return
            them along with the FTS query
            narration.<codeblock outputclass="language-java">    hotels.Add(new
    {
        name = fragment.Value.Name,
        description = fragment.Value.Description,
        address = fragment.Value.GetFullAddress()
    });
}

return Request.CreateResponse(new Result(hotels, queryJson));</codeblock></section>
    </body>
</topic>
