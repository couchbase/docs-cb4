<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_bxt_r2n_qv">
  <title>Multiprocessing and Threads</title>
  <body>
        <p>While the Python SDK has support for threads, using multiple threads in Python will not
            necessarily give you faster performance because of the <xref
                href="https://wiki.python.org/moin/GlobalInterpreterLock" format="html"
                scope="external">GIL</xref>. It is recommended that you use a module such as
                <i>gevent</i> or <i>twisted</i> which will typically allow you to get more out of
            your network while not introducing the problems typically associated with multi
            threading or multi processing.</p>
        <section><title>Using with gevent, twisted, or asyncio</title>See <xref
                href="async-programming.dita#topic_h3x_x4n_qv"/>.</section>
        <section><title>Using with Multiple Processes</title>If using multiple processes (such as
            with the <codeph>multiprocessing</codeph> module), or using a Python module which
            creates multiple processes, ensure that the <apiname>Bucket</apiname> object is not
            created in the parent process! Your Python interpreter may crash if the same
                <apiname>Bucket</apiname> object exists in more than a single process.</section>
        <section>
            <title>About Python Threads</title>
            <p>Python threads do <i>not</i> speed up an application. In fact, Python threads do not
                even run in parallel. Thus, in most cases, using multiple threads will actually slow
                down an application rather than speeding it up. The main use case for Python threads
                is allowing multiple blocking I/O operations to be performed with pseudoparallelism.
                This technique allows a Python application to perform several I/O operations in
                parallel without having to redesign the application to make use of an asynchronous
                I/O framework such as Twisted and gevent.</p>
            <p>For new applications, it is highly recommended to make use of such asynchronous
                operations and to avoid Python threads, if at all possible. The purpose of this
                document is to describe several points of using the Python SDK in a threaded
                environment.</p>
        </section>
        <section>
            <title>Using the Python SDK in Threaded Applications</title>
            <p>Each <apiname>Bucket</apiname> object contains an internal lock that is held for the
                duration of each operation performed on it. By default, when a method is called on
                the <apiname>Bucket</apiname> object, it checks whether the lock is already held,
                and if it is, throws a <apiname>couchbase.exceptions.ObjectThreadError</apiname>
                exception. This is because this would unnecessarily slow down the application and
                would indicate that there is contention between two threads for the
                    <apiname>Bucket</apiname> object.</p>
            <p>In general, you can choose between several possible strategies to apply when using an
                application with threads. The strategy to apply depends on the use case of the
                application itself. Here are the possible strategies:<ul id="ul_xxk_nfn_qv">
                    <li>Create a dedicated <apiname>Bucket</apiname> object per thread.<p>This
                            strategy is useful for a low number of threads, where each thread is
                            performing Couchbase operations very frequently. In this use mode, each
                            thread is assured that it will never have to wait for another thread to
                            complete a Couchbase operation.</p><p>Note that this approach is
                                <b>not</b> recommended for applications with high numbers of
                            threads, as this will dramatically increase the number of connections to
                            the cluster.</p></li>
                    <li>
                        <p>Create a global <apiname>Bucket</apiname> object shared between
                            threads.</p>
                        <p>This strategy is useful if the application is only intermittently
                            performing Couchbase operations (that is, every few seconds). In this
                            case the application maintains only a single connection to the cluster,
                            and application threads and access to the <apiname>Bucket</apiname>
                            singleton will be serialized across threads. To make use of this
                            strategy (and to disable the <apiname>ObjectThreadError</apiname>
                            exception), use the <varname>lockmode=LOCKMODE_WAIT</varname> in the
                            constructor, like
                            so:<codeblock outputclass="language-python">from couchbase.bucket import Bucket
from couchbase import LOCKMODE_WAIT

bucket = Bucket('couchbase://10.0.0.99/default', lockmode=LOCKMODE_WAIT)</codeblock>This
                            explicitly instructs the SDK to wait (and not throw an exception) if an
                            existing operation is in progress on the given <apiname>Bucket</apiname>
                            object.</p>
                    </li>
                    <li>
                        <p>Create a custom application-specific pool of <apiname>Bucket</apiname>
                            instances</p>
                        <p>This strategy allows an application to fine-tune access to the cluster.
                            There is no built-in support for connection pooling within the SDK,
                            however implementing a pooling strategy can be achieved. The source
                            distribution of the SDK features an <xref
                                href="https://github.com/couchbase/couchbase-python-client/blob/master/examples/connection-pool.py"
                                format="html" scope="external">example</xref> of a connection
                            pool.</p>
                    </li>
                </ul><note>A point of consolation about using the Python SDK with threads is that
                    the internal C extension <i>does</i> release the <i>GIL</i> when possible,
                    ensuring some modicum of true concurrency, to the extent that the application
                    may utilize more than one processor core at a time. Most of the actual I/O and
                    CPU is done entirely inside the C SDK, during which the <i>GIL</i> is released
                    by default.</note></p>
        </section>
        <section>
            <title>Disabling Threaded Functionality</title>
            <p>The SDK defaults to allowing usage with threads in order to not unexpectedly cause
                crashes within the Python interpreter itself. Nevertheless, there is a small
                performance cost for this default. To disable any threading functionality, pass
                these options to the
                constructor:<codeblock outputclass="language-python">from couchbase.bucket import Bucket
from couchbase import LOCKMODE_NONE

bucket = Bucket('couchbase://192.168.33.101/default', lockmode=LOCKMODE_NONE, unlock_gil=False)</codeblock>Note
                that using the above options in an application that uses Python threads will likely
                crash the interpreter.</p>
        </section>
    </body>
</topic>
