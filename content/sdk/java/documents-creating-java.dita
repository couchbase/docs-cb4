<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE concept
  PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept xml:lang="en-us" id="concept2677">
	<title>Creating Documents</title>
	<shortdesc>Describes creating documents by using the <codeph>insert()</codeph> or <codeph>upsert()</codeph> methods.</shortdesc>

	<conbody>

		<section>
			<title>Insert</title>

			<p>The <codeph>insert</codeph> method allows you to store a <codeph>Document</codeph> if it does
				not already exist in the bucket. If it does exist, the synchronous API throws a
					<codeph>DocumentAlreadyExistsException</codeph> (or the
					<codeph>Observable</codeph> propagates it to <codeph>onErro</codeph> in the case
				of the asynchronous API).</p>

<codeblock outputclass="language-java"><![CDATA[JsonObject content = JsonObject.empty().put("name", "Michael");
JsonDocument doc = JsonDocument.create("docId", content);
//this will throw DocumentAlreadyExistException:
JsonDocument inserted = bucket.insert(doc);]]></codeblock>

<codeblock outputclass="language-java"><![CDATA[JsonObject content = JsonObject.empty().put("name", "Michael");
JsonDocument doc = JsonDocument.create("docId", content);
Observable<JsonDocument> inserted = bucket.async().insert(doc);
inserted.subscribe(
	System.out::println,
	//this will be called with DocumentAlreadyExistException:
	Throwable::printStackTrace
);]]></codeblock>

			<p>If the <codeph>Document</codeph> also has the <codeph>expiry</codeph> time set, it is
				respected and picked up by the server.</p>

			<p>It doesn't matter what type of <codeph>Document</codeph> is inserted because its type is
				inferred from the method argument and the corresponding <codeph>Transcoder</codeph> is
				used to encode it.</p>

			<p>The <codeph>Document</codeph> returned, as a result, is different from the
					<codeph>Document</codeph> passed in. The returned document references some
				values like its <codeph>id</codeph> and <codeph>content</codeph> but also has the
					<codeph>CAS</codeph> value set.</p>

		</section>

		<section>
			<title>Upsert</title>

			<p>The <codeph>upsert</codeph> method works similar to <codeph>insert</codeph>, but it also
				overrides an already stored <codeph>Document</codeph> (so there is no
					<codeph>DocumentAlreadyExistsException</codeph> thrown by the synchronous API
				nor propagated by the asynchronous API).</p>

<codeblock outputclass="language-java"><![CDATA[JsonObject content = JsonObject.empty().put("name", "Michael");
JsonDocument doc = JsonDocument.create("docId", content);
JsonDocument inserted = bucket.upsert(doc);]]></codeblock>

<codeblock outputclass="language-java"><![CDATA[JsonObject content = JsonObject.empty().put("name", "Michael");
JsonDocument doc = JsonDocument.create("docId", content);
Observable<JsonDocument> inserted = bucket.async().upsert(doc);
inserted.subscribe(
	System.out::println,
	//this won't be called:
	Throwable::printStackTrace
);]]></codeblock>

			<p>If the <codeph>Document</codeph> also has the <codeph>expiry</codeph> time set, it is
				respected and picked up by the server.</p>

			<p>It doesn't matter what type of <codeph>Document</codeph> is upserted because its type is
				inferred from the method argument and the corresponding <codeph>Transcoder</codeph> is
				used to encode it.</p>

			<p>The <codeph>Document</codeph> returned, as a result, is a different one compared to the
					<codeph>Document</codeph> passed in. It references some values like its
					<codeph>id</codeph> and <codeph>content</codeph> but also has the
					<codeph>CAS</codeph> value set.</p>
		</section>

		<section>
			<title>Durability Requirements</title>

			<p>If no durability requirements are set on the <codeph>insert</codeph> or
					<codeph>upsert</codeph> methods, the operation will succeed when the server
				acknowledges the document in its managed cache layer. While this is a performant
				operation, there might be situations where you want to make sure that your document
				has been persisted or replicated so that it survives power outages and other node
				failures.</p>

			<p>Both methods provide overloads to supply such requirements:</p>

<codeblock outputclass="language-java"><![CDATA[D insert(D document, PersistTo persistTo);
D insert(D document, ReplicateTo replicateTo);
D insert(D document, PersistTo persistTo, ReplicateTo replicateTo);

D upsert(D document, PersistTo persistTo);
D upsert(D document, ReplicateTo replicateTo);
D upsert(D document, PersistTo persistTo, ReplicateTo replicateTo);]]></codeblock>

			<note type="tip">The synchronous API also provides the same methods with custom timeouts, whereas the asynchronous API in <codeph>AsyncBucket</codeph> would rely on RxJava's <codeph>timeout</codeph> operator.</note>

			<p>You can configure either just one or both of the requirements when inserting or upserting. From an application point of view nothing needs to be changed when working with the response, although there is something that need to be kept in mind:</p>

			<p>The internal implementation first performs a regular <codeph>insert</codeph> or
					<codeph>upsert</codeph> operation and afterward starts polling the specifically
				affected cluster nodes for the state of the document. If something fails during this
				operation (and failing the <codeph>Observable</codeph>), the original operation
				might have succeeded nonetheless.</p>

<codeblock outputclass="language-java"><![CDATA[// Insert the document and make sure it is persisted to the master node
bucket.insert(document, PersistTo.MASTER);

// Insert the document and make sure it is replicate to one replica node
bucket.insert(document, ReplicateTo.ONE);

// Insert the document and make sure it is persisted to one node and replicated to two
bucket.insert(document, PersistTo.ONE, ReplicateTo.TWO);]]></codeblock>

		</section>

		<section>
			<title>Batching</title>

			<p>Because everything is asynchronous internally, batching <codeph>inserts</codeph> or
					<codeph>upserts</codeph> can be achieved with the  <codeph>Observable</codeph>
				functionality of the <codeph>AsyncBucket</codeph>.</p>

			<p>A combination of <codeph>just()</codeph> and <codeph>flatMap()</codeph> is used to store them without blocking:</p>

<codeblock outputclass="language-java"><![CDATA[JsonDocument doc1 = JsonDocument.create("id1", content);
JsonDocument doc2 = JsonDocument.create("id2", content);
JsonDocument doc3 = JsonDocument.create("id3", content);

Observable
    .just(doc1, doc2, doc3)
    .flatMap(new Func1<JsonDocument, Observable<JsonDocument>>() {
        @Override
        public Observable<JsonDocument> call(JsonDocument document) {
            return bucket.async().insert(document);
        }
    }).subscribe();]]></codeblock>

    	<p>For the blocking API, batching is currently not supported. It is recommended to fall back on the asynchronous API for best performance.</p>

		</section>

	</conbody>
</concept>
