<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="async-programming-java">
  <title>Asynchronous Programming</title>
      <topic id="mastering-observables">
	<title>Mastering Observables</title>
	<shortdesc>This section helps you to get up to speed with asynchronous programming and
            <codeph>Observable</codeph> objects in particular. </shortdesc>
	<body>


		<section>
			<title>Motivation</title>

			<p>Asynchronous and reactive methodologies allow you to utilize system resources better. Instead
                of wasting a thread waiting for network or disk I/O, it can be fully utilized to
                perform other work instead.</p>

			<p>A broad range of technologies is available to facilitate this style of programming, ranging
                from the very limited and not really usable
                    <codeph>java.util.concurrent.Future</codeph> to complete libraries and runtimes
                like <xref href="http://akka.io" format="html" scope="external">Akka</xref>. A
                database driver must meet the following requirements:</p>

			<ul>
				<li>Rich functionality</li>
				<li>Interoperable and not opinionated</li>
				<li>Performant</li>
				<li>Small dependency and runtime footprint</li>
			</ul>

			<p>After evaluating the requirements and solutions closely, one library stood out: <xref
                href="http://reactivex.io/" format="html" scope="external">RxJava</xref>. It has
				a very rich set to compose asynchronous workflows, has no dependencies on its own and is
				used at high-profile companies like Netflix. The Rx model is mature and well thought
				out, and the community is vibrant.</p>

			<p>Couchbase hopes that after you read through the introduction and get more familiar with the
                concept, you will never want to go back. Couchbase fully supports blocking
                operations as well, so you can still use a traditional blocking-based model if you
                indeed want to.</p>

			<p>The next section gradually introduces you to the world of <term>Observables</term>, the first
                step to masterhood. If you want to learn more about the motivation, read on
                here.</p>
		</section>

		<section><title>Java 8, Lambdas and Anonymous Classes</title><p>Before jumping into the details,
                    one thing warrants clarification: RxJava and, therefore, the Java SDK, fully
                    supports Java 8. This support brings some great improvements, most prominently
                    support for <term>lambdas</term> and <term>method
                    references</term>.</p><p>Because the Java SDK has support for Java 6 and 7, most
                    of the examples shown in the documentation use anonymous classes instead of
                    lambdas. You are free and even encouraged to use them if you can, but Java 8 on
                    production servers is still a few months or even years away at most companies.
                    That said, Couchbase expects the SDK to be around for a long time and want to
                    pave the way for the future right now. </p><p>To whet your appetite, compare
                    some Java 6 code to Java 8 code (same code). </p><p>Here's an example with the
                    Java 6 code:</p><codeblock outputclass="language-java"><![CDATA[// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1<String, Observable<JsonDocument>>() {
        @Override
        public Observable<JsonDocument> call(String id) {
            return bucket.get(id);
        }
    }).subscribe(new Action1<JsonDocument>() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });]]></codeblock> Here's the same code written in Java 8: <codeblock outputclass="language-java"><![CDATA[// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(bucket::get)
    .subscribe(document -> System.out.println("Got: " + document));]]></codeblock><p>RxJava has
                    support for other languages such as Scala, Groovy or Clojure. If you are using
                    one of those languages, refer to the RxJava documentation on how to use the
                    adapters. </p></section>

		<section>
			<title>Understanding Observables</title>

			<p>You can think of an <term>Observable</term> as the push-based, asynchronous cousin
                ("dual") of the pull-based, synchronous <term>iterable</term>. The contract of
                an <codeph>Observable</codeph> is that zero to N data events can happen, followed by
                a complete event. An error event can also happen at any time and complete the
                    <codeph>Observable</codeph>.</p>

			<table frame="all" rowsep="1" colsep="1" id="table_qpl_ttq_44">
   <title>The duality of Iterable and Observable</title>

   <tgroup cols="3">
    <colspec colname="c1" colnum="1" colwidth="4.39*"/>
    <colspec colname="c2" colnum="2" colwidth="4.29*"/>
    <colspec colname="c3" colnum="3" colwidth="4.4*"/>
    <thead>
     <row>
      <entry>Event</entry>
      <entry>Iterable (Pull)</entry>
      <entry>Observable (Push)</entry>
     </row>
    </thead>
    <tbody>
      <row>
        <entry>retrieve data</entry>
        <entry><codeph>T next()</codeph></entry>
        <entry><codeph>onNext(T)</codeph></entry>
      </row>
      <row>
        <entry>discover error</entry>
        <entry><codeph>throws Exception</codeph></entry>
        <entry><codeph>onError(Exception)</codeph></entry>
      </row>
      <row>
        <entry>complete</entry>
        <entry><codeph>returns</codeph></entry>
        <entry><codeph>onCompleted()</codeph></entry>
      </row>
    </tbody>
   </tgroup>
</table>

		<p>An <codeph>Observable</codeph> can also be converted into a
				<codeph>BlockingObservable</codeph>, which then, unsurprisingly, behaves very much like
				an <codeph>Iterable</codeph>.</p>

		<p>The key element to take away is that an <codeph>Observable&lt;T&gt;</codeph> can emit 0 to N
                events, which is very different than a <codeph>Future&lt;T&gt;</codeph> that only
                contains one value. After you start to work on streams instead of single values, you
                will very much appreciate this fact.</p>

		<p>By definition, an <codeph>Observable</codeph> does not imply that the underlying code is
                executed asynchronously. As a consumer of an <codeph>Observable</codeph>, you leave
                the actual implementation to the supplier, who can change it later on without you
                having to adapt your code. Imagine, you are consuming this API:</p>

<codeblock outputclass="language-java"><![CDATA[public interface FooService {
    Observable<String> load();
}]]></codeblock>

		<p>It could be that when <codeph>load()</codeph> is called, the <codeph>String</codeph> value is
                fetched right out of a <codeph>Map</codeph> in memory (or even a hard-coded value).
                In this case, there is no need to move the execution away from the caller thread,
                because the value will be returned instantaneously. If later the implementation
                needs to be changed so that the <codeph>String</codeph> is loaded through a web
                service (introducing latency and other semantics), the API doesn't need to be
                changed because the underlying implementation is free to move it to a
                    <codeph>Scheduler</codeph>.</p>

		</section>

		<section>
			<title>Consuming Observables</title>

			<p>The first thing you want to do when working with <codeph>Observables</codeph> is to consume them. Consuming an
				<codeph>Observable</codeph> means subscribing to it. Here is an example that subscribes and prints out
				all the items emitted:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .just(1, 2, 3)
    .subscribe(new Subscriber<Integer>() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });]]></codeblock>

    <p>The example prints the following lines:</p>

<codeblock><![CDATA[Got: 1
Got: 2
Got: 3
Completed Observable.]]></codeblock>

	<p>You can see that our <codeph>Observer</codeph> gets notified of every event and also receives
                the completed event.<note>A well-formed <codeph>Observable</codeph> invokes its subscriberâ€™s
                        <codeph>onNext</codeph> method zero or more times and then invokes either
                    the <codeph>onCompleted</codeph> or <codeph>onError</codeph> method exactly
                    once.</note></p>

	<p>You can also test the error case by throwing an artificial exception when the value 2 is emitted:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .just(1, 2, 3)
    .doOnNext(new Action1<Integer>() {
        @Override
        public void call(Integer integer) {
            if (integer.equals(2)) {
                throw new RuntimeException("I don't like 2");
            }
        }
    })
    .subscribe(new Subscriber<Integer>() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });]]></codeblock>

    <p>The example prints:</p>

<codeblock><![CDATA[Got: 1
Whoops: I don't like 2]]></codeblock>

	<p>The first value gets through without problems, the second value throws an exception and,
                therefore, terminates the <codeph>Observable</codeph>. No subsequent values are allowed to be emitted
                after an error event.</p>

	<p><note>The <codeph>subscribe</codeph> method also returns a <codeph>Subscription</codeph> that you
                    can use to <codeph>unsubscribe</codeph> and not receive further events.</note></p>

	<p>Even if you don't unsubscribe explicitly, operations like <codeph>take</codeph> do that for you
				implicitly. The following code only takes the first five values and then
				unsubscribes:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .just("The", "Dave", "Brubeck", "Quartet", "Time", "Out")
    .take(5)
    .subscribe(new Subscriber<String>() {
        @Override
        public void onCompleted() {
            System.out.println("Completed Observable.");
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("Whoops: " + throwable.getMessage());
        }

        @Override
        public void onNext(String name) {
            System.out.println("Got: " + name);
        }
    });]]></codeblock>

	<p>This prints:</p>

<codeblock><![CDATA[Got: The
Got: Dave
Got: Brubeck
Got: Quartet
Got: Time
Completed Observable.]]></codeblock>

		<p><note>If you take a close look at the API, <codeph>subscribe()</codeph> can be fed with either an <codeph>Observer</codeph> or a <codeph>Subscriber</codeph>. Unless you are implementing a custom <codeph>Observer</codeph>, always use <codeph>Subscriber</codeph> (because otherwise it will be wrapped in one internally anyway and you are saving unnecessary object allocations).</note></p>

		<p>You do not need to implement the full subscriber every time. If you are only interested in the
				data events, you can subscribe like this:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .just(1, 2, 3)
    .subscribe(new Action1<Integer>() {
        @Override
        public void call(Integer integer) {
            System.out.println("Got: " + integer);
        }
    });]]></codeblock>

    <p>Be aware though that if an error happens, the following exception will be propagated:</p>

<codeblock><![CDATA[Exception in thread "main" rx.exceptions.OnErrorNotImplementedException
	at rx.Observable$36.onError(Observable.java:8412)
	at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:128)
	at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)
	at rx.internal.operators.OperatorDoOnEach$1.onError(OperatorDoOnEach.java:67)
	at rx.internal.operators.OperatorDoOnEach$1.onNext(OperatorDoOnEach.java:78)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer
          .request(OnSubscribeFromIterable.java:76)
	...]]></codeblock>

	<p>It is recommended always to implement an error handler right from the beginning since things can
                and will go wrong at some point. It can come in handy though if you just want to try
                things out quickly or for illustrative purposes.</p>

		</section>

		<section>
			<title>From Asynchronous to Synchronous</title>

			<p>As long as your <codeph>Observable</codeph> works on the same thread all the time, there is no
                need for communication between threads since only one is executing. When your
                    <codeph>Observable</codeph> flow gets executed on a different thread, you need
                to take some extra care to make sure you are not missing values. This is not
                specific to <codeph>Observables</codeph>: every time you need to deal with parallel
                threads you need to think about synchronization and communication.</p>

            <p><note>Most of the snippets in this documentation only call <codeph>subscribe</codeph>. You should
                    ensure that your program doesn't terminate before <codeph>onCompleted()</codeph>
                    is called (e.g., via <codeph>toBlocking()</codeph> or a
                        <apiname>CountDownLatch</apiname>) and be aware of that when trying to
                    replicate a snippet in its Main class.</note></p>

            <p><note>You should never perform long-running blocking operations inside of an asynchronous stream (eg. inside of <codeph>map</codeph>s or <codeph>flatMap</codeph>s).</note></p>

			<p>The following code emits an increasing value every second, which is done on a different
                thread:</p>

<codeblock outputclass="language-java"><![CDATA[public static void main(String... args) {
    Observable
        .interval(1, TimeUnit.SECONDS)
        .subscribe(new Action1<Long>() {
            @Override
            public void call(Long counter) {
                System.out.println("Got: " + counter);
            }
        });
}]]></codeblock>

    <p>It works perfectly fine; the only problem is though chances are you won't see anything
                printed out. Your main thread exits before the background thread had a chance to run
                and emit values.</p>

    <p>A common way to deal with such a situation is to add a <codeph>CountDownLatch</codeph>, which
                allows you to synchronize between different threads. One thread counts down the
                latch; the other one waits until it is counted down:</p>

<codeblock outputclass="language-java"><![CDATA[final CountDownLatch latch = new CountDownLatch(5);
Observable
    .interval(1, TimeUnit.SECONDS)
    .subscribe(new Action1<Long>() {
        @Override
        public void call(Long counter) {
            latch.countDown();
            System.out.println("Got: " + counter);
        }
    });

latch.await();]]></codeblock>

    <p>The example prints the following lines and then exits:</p>

<codeblock><![CDATA[Got: 0
Got: 1
Got: 2
Got: 3
Got: 4]]></codeblock>

	<p><note>One common mistake is to use <codeph>Thread.sleep()</codeph> instead of a latch to synchronize
                    the execution between threads. This is a bad idea because it synchronizes
                    nothing and just keeps one thread alive for a specific amount of time. If the
                    actual calls take less time you are wasting time, and if it takes longer you
                    won't get the desired effect. If you do this in unit tests, be prepared for a
                    good amount of non-determinism and randomly failing tests. <p><b>Always use a
                            <codeph>CountDownLatch</codeph>!</b></p></note></p>

	<p>A technique unique to <codeph>Observables</codeph> is to convert it into a <codeph>BlockingObservable</codeph> to
                achieve the same effect. In simple terms, it converts an <codeph>Observable</codeph>
                into an <codeph>iterable</codeph> and makes it execute on the caller thread,
                blocking it until one or more values arrive. This technique is used extensively in
                the documentation to show concepts, while not having to deal with count-down latches
                all the time. It can also be used if you for some reason are not able to use
                asynchronous computations.</p>

	<p>The conversion itself doesn't do any blocking in the first place, only subsequent calls will:</p>

<codeblock outputclass="language-java"><![CDATA[// This does not block.
BlockingObservable<Long> observable = Observable
    .interval(1, TimeUnit.SECONDS)
    .toBlocking();

// This blocks and is called for every emitted item.
observable.forEach(new Action1<Long>() {
    @Override
    public void call(Long counter) {
        System.out.println("Got: " + counter);
    }
});]]></codeblock>

    <p>Because this will run forever, you are free to chain any asynchronous computations before.
				Thus, you can build an asynchronous workflow and then block at the very end. This
				resembles the same code as with the <codeph>CountDownLatch</codeph> before:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .interval(1, TimeUnit.SECONDS)
    .take(5)
    .toBlocking()
    .forEach(new Action1<Long>() {
        @Override
        public void call(Long counter) {
            System.out.println("Got: " + counter);
        }
    });]]></codeblock>

    <p>If you know that only a single value is ever returned, you can use the
					<apiname>single()</apiname> method:</p>

<codeblock outputclass="language-java"><![CDATA[int value = Observable
    .just(1)
    .toBlocking()
    .single();]]></codeblock>

    <p>Be aware though that if more items get emitted, you get an exception:</p>

<codeblock><![CDATA[Exception in thread "main" java.lang.IllegalArgumentException: Sequence contains too many elements
	at rx.internal.operators.OperatorSingle$1.onNext(OperatorSingle.java:58)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:76)
	at rx.Subscriber.setProducer(Subscriber.java:148)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	....]]></codeblock>

	<p>The same thing happens if no value gets emitted:</p>

<codeblock><![CDATA[Exception in thread "main" java.util.NoSuchElementException: Sequence contains no elements
	at rx.internal.operators.OperatorSingle$1.onCompleted(OperatorSingle.java:82)
	at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:79)
	at rx.Subscriber.setProducer(Subscriber.java:148)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	at rx.Subscriber.setProducer(Subscriber.java:144)
	....]]></codeblock>

	<p>As an alternative, you can use singleOrDefault() so that a fallback value gets returned.</p>

	<p>You can use this technique with the Java SDK if you are loading a document and it does not exist:</p>

<codeblock outputclass="language-java"><![CDATA[JsonDocument doc = bucket.get("id").toBlocking().singleOrDefault(null);
if (doc == null) {
    System.err.println("Document not found!");
} else {
    System.out.println(doc);
}]]></codeblock>

	<p>If you check out the API documentation of the <apiname>BlockingObservable</apiname>, you will
                discover many more possibilities, including iterators or grabbing the first and last
                values.</p>

	<p>One last thing that comes in handy with blocking calls: sometimes you want to collect all emitted values into a list. You can combine the blocking calls with the toList() operator to achieve something like this:</p>

<codeblock outputclass="language-java"><![CDATA[List<Integer> list = Observable
    .just(1, 2, 3)
    .toList()
    .toBlocking()
    .single();

// Prints: [1, 2, 3]
System.out.println(list);]]></codeblock>

		</section>

		<section>
			<title>Creating Observables</title>

			<p>There are many ways to create <codeph>Observables</codeph>, and you've already seen <apiname>just()</apiname>
                and <apiname>interval()</apiname>. There are much more such  convenience methods
                available on the <codeph>Observable</codeph> class, but they all boil down to the
                    <apiname>create()</apiname> method. You can simulate the example from before
                with this:</p>

<codeblock outputclass="language-java"><![CDATA[Observable.create(new Observable.OnSubscribe<Integer>() {
    @Override
    public void call(Subscriber<? super Integer> subscriber) {
        try {
            if (!subscriber.isUnsubscribed()) {
                for (int i = 0; i < 5; i++) {
                    subscriber.onNext(i);
                }
                subscriber.onCompleted();
            }
        } catch (Exception ex) {
            subscriber.onError(ex);
        }
    }
}).subscribe(new Action1<Integer>() {
    @Override
    public void call(Integer integer) {
        System.out.println("Got: " + integer);
    }
});]]></codeblock>

		<p>Every time a Subscriber subscribes, the <apiname>call()</apiname> method is executed. You can
				then call <codeph>onNext</codeph>, <codeph>onComplete</codeph> and
					<codeph>onError</codeph> as you wish, but keep in mind that both
					<codeph>onComplete</codeph> and <codeph>onError</codeph> should only be called once,
				and afterward no subsequent <apiname>onNext</apiname> is allowed to follow so that the
				contract is met.</p>

		<p>You can see that no blocking call is needed because the <codeph>Observable</codeph> is completely handled on the
                current thread. In the section on schedulers, you learn more about that.</p>

		    <p><note>This example shows why it is crucial to call <apiname>subscribe()</apiname> on the <codeph>Observable</codeph>, because only such a call triggers the actual execution of the pipeline. This is a little different with subjects, which are covered later in this guide. Nevertheless, always call <apiname>subscribe()</apiname> on your observables.</note></p>

		    <p>Refer to the RxJava documentation for many more methods that you can use to create <codeph>Observables</codeph>.
                If you are dealing with the Java SDK, in most places this is done for you, but there
                are situations where it comes in handy.</p>

		    <p>The Java SDK does not expose bulk methods anymore on the API, because you can do this already with the help of <codeph>Observables</codeph>. Compare these two examples, one only loads one document, the other loads a few (you'll learn about <apiname>flatMap()</apiname> in the next section):</p>

<codeblock outputclass="language-java"><![CDATA[// Loads one document and prints it:
bucket
    .get("doc1")
    .subscribe(new Action1<JsonDocument>() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });]]></codeblock>


<codeblock outputclass="language-java"><![CDATA[// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1<String, Observable<JsonDocument>>() {
        @Override
        public Observable<JsonDocument> call(String id) {
            return bucket.get(id);
        }
    }).subscribe(new Action1<JsonDocument>() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });]]></codeblock>

		</section>

		<section>
			<title>Transforming Observables</title>

			<p>Observables can transform their values in various ways. One of the most basic ones is <apiname>map()</apiname>, which converts the incoming value into a different one. You surely like division, so here is the FizzBuzz game:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .interval(10, TimeUnit.MILLISECONDS)
    .take(20)
    .map(new Func1<Long, String>() {
        @Override
        public String call(Long input) {
            if (input % 3 == 0) {
                return "Fizz";
            } else if (input % 5 == 0) {
                return "Buzz";
            }
            return Long.toString(input);
        }
    })
    .toBlocking()
    .forEach(new Action1<String>() {
        @Override
        public void call(String s) {
            System.out.println(s);
        }
    });]]></codeblock>

    <p>The map function is used to convert the input number into a string and do some checks to satisfy the FizzBuzz game. As a more practical example, consider loading a document from the Java SDK and only extracting the first name of a user before passing it on:</p>

<codeblock outputclass="language-java"><![CDATA[bucket
    .get("id")
    .map(new Func1<JsonDocument, String>() {
        @Override
        public String call(JsonDocument document) {
            return document.content().getString("firstname");
        }
    }).subscribe();]]></codeblock>

    <p>A variation of <apiname>map()</apiname> is called <apiname>flatMap()</apiname>, which allows
				you to do those transformations with asynchronous calls. Taking the example from above,
				we want to map from String (the document ID) to a <codeph>JsonDocument</codeph> (the
				loaded document). With a normal <apiname>map()</apiname>, call you would either need to
        block on the <codeph>Observable</codeph> or at some point deal with an
					<codeph>Observable&lt;Observable&lt;JsonDocument&gt;&gt;</codeph>.</p>

    <p>Thankfully, <apiname>flatMap()</apiname> flattens the resulting values for us and return them
				into the original flow:</p>

<codeblock outputclass="language-java"><![CDATA[// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1<String, Observable<JsonDocument>>() {
        @Override
        public Observable<JsonDocument> call(String id) {
            return bucket.get(id);
        }
    }).subscribe(new Action1<JsonDocument>() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });]]></codeblock>

 	<p>You can see that <apiname>flatMap()</apiname> returns an Observable&lt;T&gt; whereas the normal map just returns &lt;T&gt;. You will use <apiname>flatMap()</apiname> a lot when dealing with flows like this, so keep it in mind.</p>

 	<p>Another helpful transformation is <apiname>scan()</apiname>. It applies a function to each
 	    value emitted by an <codeph>Observable</codeph>, sequentially, and emits each
                successive value. We can use it to aggregate values like this:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .just(1, 2, 3, 4, 5)
    .scan(new Func2<Integer, Integer, Integer>() {
        @Override
        public Integer call(Integer sum, Integer value) {
            return sum + value;
        }
    }).subscribe(new Action1<Integer>() {
        @Override
        public void call(Integer integer) {
            System.out.println("Sum: " + integer);
        }
    });]]></codeblock>

         <p>This prints:</p>

<codeblock><![CDATA[Sum: 1
Sum: 3
Sum: 6
Sum: 10
Sum: 15]]></codeblock>

		    <p>Finally, <apiname>groupBy()</apiname> comes in handy, which emits one <codeph>Observable</codeph> by each group, defined by a function. The following example emits two <codeph>Observables</codeph>, one for even and one for odd values:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .just(1, 2, 3, 4, 5)
    .groupBy(new Func1<Integer, Boolean>() {
        @Override
        public Boolean call(Integer integer) {
            return integer % 2 == 0;
        }
    }).subscribe(new Action1<GroupedObservable<Boolean, Integer>>() {
        @Override
        public void call(GroupedObservable<Boolean, Integer> grouped) {
            grouped.toList().subscribe(new Action1<List<Integer>>() {
                @Override
                public void call(List<Integer> integers) {
                    System.out.println(integers + " (Even: " + grouped.getKey() + ")");
                }
            });
        }
    });]]></codeblock>

   <p>The example prints:</p>

<codeblock><![CDATA[[1, 3, 5] (Even: false)
[2, 4] (Even: true)]]></codeblock>

	<p>Combined with the Java SDK, this technique can be used to separate returned Documents based on their content. The following example uses a view to load all documents from the <codeph>beer-sample</codeph> bucket, groups them by type and counts the number of occurrences:</p>

<codeblock outputclass="language-java"><![CDATA[bucket
    .query(ViewQuery.from("my_design_doc", "my_view"))
    .flatMap(ViewResult::rows)
    .flatMap(ViewRow::document)
    .groupBy(document -> document.content().getString("type"))
    .subscribe(observable ->
        observable.count().subscribe(integer ->
            System.out.println(observable.getKey() + ": " + integer)
        )
    );]]></codeblock>

		    <p>This code queries the view, extracts all rows, loads the full document for each row, groups it by the <codeph>type</codeph> property in the JSON document and then uses the <apiname>count()</apiname> operator to count the number of rows emitted by each <codeph>Observable</codeph>. This prints something like the following:</p>

<codeblock><![CDATA[brewery: 1412
beer: 5891]]></codeblock>

		</section>

		<section>
			<title>Filtering observables</title>

			<p>In addition to transforming observables, you can also filter them. Filtering doesn't change the emitted values itself, but rather how much and at which point (and if at all) they are emitted.</p>

			<p>For example, you can filter based on some criteria:</p>

<codeblock outputclass="language-java"><![CDATA[// This will only let 3 and 4 pass.
Observable
    .just(1, 2, 3, 4)
    .filter(new Func1<Integer, Boolean>() {
        @Override
        public Boolean call(Integer integer) {
            return integer > 2;
        }
    }).subscribe();]]></codeblock>

			<p>Or take only the first N values emitted and then unsubscribe:</p>

<codeblock outputclass="language-java"><![CDATA[// Only 1 and 2 will pass.
Observable
    .just(1, 2, 3, 4)
    .take(2)
    .subscribe();]]></codeblock>

			<p>Or use only the first or last value emitted:</p>

<codeblock outputclass="language-java"><![CDATA[// Only 1 will pass
Observable
    .just(1, 2, 3, 4)
    .first()
    .subscribe();]]></codeblock>

<codeblock outputclass="language-java"><![CDATA[// Only 4 will pass
Observable
    .just(1, 2, 3, 4)
    .last()
    .subscribe();]]></codeblock>

			<p>Finally, you can use distinct() to suppress duplicate values:</p>

<codeblock outputclass="language-java"><![CDATA[// 1, 2, 3, 4 will be emitted
Observable
    .just(1, 2, 1, 3, 4, 2)
    .distinct()
    .subscribe();]]></codeblock>

    <p><note><apiname>distinct()</apiname> also allows you to pass in a function that returns the key to select by. You can use this, for example, to separate out duplicate <codeph>JsonDocument</codeph> objects.</note></p>
		</section>

		<section>
			<title>Combining Observables</title>

		    <p>Multiple <codeph>Observables</codeph> can also be merged to form a combined one. Depending on how you want those to be merged, there are different operators available. Two of the most used ones are <apiname>merge()</apiname> and <apiname>zip()</apiname> which are covered here.</p>

			<p><apiname>Merge</apiname> only merges all emitted values by the source
			    <codeph>Observables</codeph> in the order they arrive:</p>
<codeblock outputclass="language-java"><![CDATA[Observable
    .merge(evens, odds)
    .subscribe(new Action1<Integer>() {
        @Override
        public void call(Integer integer) {
            System.out.println(integer);
        }
    });]]></codeblock>

    	<p>The example prints something similar to the following:</p>

<codeblock><![CDATA[2
4
6
8
10
1
3
5
7
9]]></codeblock>

		<p>With the zip operator, you can combine two streams in the strictly same order, defined by a function:</p>

<codeblock outputclass="language-java"><![CDATA[Observable<Integer> evens = Observable.just(2, 4, 6, 8, 10);
Observable<Integer> odds = Observable.just(1, 3, 5, 7, 9);

Observable
    .zip(evens, odds, (v1, v2) -> v1 + " + " + v2 + " is: " + (v1 + v2))
    .subscribe(System.out::println);]]></codeblock>

    	<p>This zips the pairs together in order and prints:</p>

<codeblock><![CDATA[2 + 1 is: 3
4 + 3 is: 7
6 + 5 is: 11
8 + 7 is: 15
10 + 9 is: 19]]></codeblock>

		</section>

		<section>
			<title>Error Handling</title>

		    <p>Error handling is a vital component of every real world application and needs to be considered from the start. RxJava provides sophisticated mechanisms to deal with errors that happen inevitably in your <codeph>Observable</codeph> flows.</p>

			<p>In general, you want to react in the following ways:</p>

			<ul>
				<li>Return a default value instead.</li>
			    <li>Flip over to a backup <codeph>Observable</codeph>.</li>
			    <li>Retry the <codeph>Observable</codeph> (immediately or with backoff).</li>
			</ul>

			<p>Returning a default value is a good idea if you cannot afford to retry or you just don't care
                (maybe because the flow is not crucial to your data flow). The following code throws
                an exception at the first emitted item, but falls back to a default value:</p>

			<p>Note that you can pass in a function that also takes the exception, so you can return
                different values for different exception types or use it for logging purposes.</p>

<codeblock outputclass="language-java"><![CDATA[// Prints:
// Default
// Oops: I don't like: Apples
Observable
    .just("Apples", "Bananas")
    .doOnNext(s -> {
        throw new RuntimeException("I don't like: " + s);
    })
    .onErrorReturn(throwable -> {
        System.err.println("Oops: " + throwable.getMessage());
        return "Default";
    }).subscribe(System.out::println);]]></codeblock>

		    <p>You can also flip to a backup <codeph>Observable</codeph> that will be called if the first one fails. The
                Java SDK has a<apiname> getFromReplica()</apiname> command that  allows you to read
                stale data from its replicas and treat availability for consistency on reads. You
                can use this approach to fall back:</p>

<codeblock outputclass="language-java"><![CDATA[bucket
    .get("id")
    .onErrorResumeNext(bucket.getFromReplica("id", ReplicaMode.ALL))
    .subscribe();]]></codeblock>

		    <p>Normally you want to have more control on which <codeph>Observable</codeph> should be run next depending on
				the type of error. The following example will only go to the replica if a
					<codeph>TimeoutException</codeph> happened (if not the error is passed down):</p>

<codeblock outputclass="language-java"><![CDATA[bucket
    .get("id")
    .timeout(500, TimeUnit.MILLISECONDS)
    .onErrorResumeNext(new Func1<Throwable, Observable<? extends JsonDocument>>() {
        @Override
        public Observable<? extends JsonDocument> call(Throwable throwable) {
            if (throwable instanceof TimeoutException) {
                return bucket.getFromReplica("id", ReplicaMode.ALL);
            }
            return Observable.error(throwable);
        }
    });]]></codeblock>

		    <p>Finally, it is possible to retry the <codeph>Observable</codeph> by resubscribing. This can be done as quickly as possible, or with a backoff interval, which is preferred when external resources are involved.</p>

    	<p>The following program desperately tries to read the numbers from 1 to 10, but a (not so hidden) flaw makes it randomly throw an exception. If that happens, the code retries. Since lots of values might be already emitted, we can use <apiname>distinct()</apiname> to filter those out.</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    .doOnNext(integer -> {
        if (new Random().nextInt(10) + 1 == 5) {
            throw new RuntimeException("Boo!");
        }
    })
    .retry()
    .distinct()
    .subscribe(System.out::println);]]></codeblock>

    	<p><note>If you only want to retry for a max amount, replace the <apiname>retry()</apiname> with a <apiname>retry(count)</apiname> call.</note></p>

    	<p>If you want to retry with backoff, you can use a technique like this:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .range(1, 10)
    .doOnNext(integer -> {
        if (new Random().nextInt(10) + 1 == 5) {
            throw new RuntimeException("Boo!");
        }
    })
    .retryWhen(attempts ->
        attempts.zipWith(Observable.range(1, 3), (n, i) -> i)
        .flatMap(i -> {
            System.out.println("delay retry by " + i + " second(s)");
            return Observable.timer(i, TimeUnit.SECONDS);
        }))
    .distinct()
    .subscribe(System.out::println);]]></codeblock>

    <p>The attempts get passed into the <apiname>retryWhen()</apiname> method and zipped with the number of seconds to wait. The timer method is used to complete once its timer is done. If you run this code a few times to generate an exception (or more), you will see something similar to this:</p>

<codeblock><![CDATA[1
2
3
4
delay retry by 1 second(s)
delay retry by 2 second(s)
5
6
7
8
9
10]]></codeblock>

<p>Since Java SDK 2.1.2 the advanced <codeph>retryWhen</codeph> is easier to write using the
                    <codeph>RetryBuilder</codeph> helper class. These can be used to specify a
                filter on which kind of <codeph>Exception</codeph> to retry, for how many attempts,
                with any <codeph>Delay</codeph>.</p>
<codeblock outputclass="language-java"><![CDATA[
Observable
    .range(1, 10)
    .doOnNext(integer -> {
         if (new Random().nextInt(10) + 1 == 5) {
             throw new RuntimeException("Boo!");
         }
    })
    .retryWhen(
         RetryBuilder
             .anyOf(RuntimeException.class)
             .delay(Delay.exponential(TimeUnit.MILLISECONDS, 100))
             .max(5)
             .build())
    .distinct()
    .subscribe(System.out::println);
]]></codeblock>

		</section>

		<section>
			<title>Schedulers and Threads</title>

			<p>Schedulers in RxJava are used to manage and control concurrency. Some operators implicitly use
				one or allow you to pass in a custom one.</p>

			<p>RxJava ships with a bunch of preconfigured Schedulers by default, which are all accessible through the Schedulers class:</p>

			<ul>
				<li><apiname>Schedulers.computation()</apiname>: Event-loop style scheduler for purely computational work.</li>
		        <li><apiname>Schedulers.immediate()</apiname>: Executes the work immediately on the current thread.</li>
		        <li><apiname>Schedulers.io()</apiname>: Executes work on an Executor-backed pool that
                    grows as needed.</li>
		        <li><apiname>Schedulers.newThread()</apiname>: Creates a new thread for each unit of work.</li>
		        <li><apiname>Schedulers.trampoline()</apiname>: Queues the work on the current thread and gets executed after the current work completes.</li>
		        <li><apiname>Schedulers.test()</apiname>: Test the <codeph>scheduler</codeph> used for
                    testing and debugging, which allows manual advancing of the clock.</li>
			</ul>

			<p>As a rule of thumb, the computation <codeph>scheduler</codeph> should always be used for
                in-memory processing, while the I/O scheduler should only be used for blocking-style
                I/O operations (so do not use it together with the Java SDK because it is
                asynchronous anyway).</p>

			<p>You can instruct an <codeph>observable</codeph> to be executed on such a
                    <codeph>scheduler</codeph> in the following ways:</p>

			<ul>
				<li>Implicitly by using an operator that makes use of one</li>
				<li>Explicitly by passing the Scheduler to such an operator</li>
				<li>By using <apiname>subscribeOn(Scheduler)</apiname></li>
				<li>By using <apiname>observeOn(Scheduler)</apiname></li>
			</ul>

			<p>Operators like <codeph>buffer</codeph>, <codeph>replay</codeph>, <codeph>skip</codeph>,
                    <codeph>delay</codeph>, <codeph>parallel</codeph> and so on use a
                    <codeph>scheduler</codeph> by default if not instructed otherwise. A list of
                default <codeph>schedulers</codeph> can be found <xref
                    href="https://github.com/ReactiveX/RxJava/wiki/Scheduler#default-schedulers-for-rxjava-observable-operators"
                    format="html" scope="external">here</xref>.</p>

			<p>As a rule of thumb, all of those operators allow you to pass in a custom
                    <codeph>scheduler</codeph> if needed, but most of the time sticking with the
                defaults is a good idea.</p>

			<p><note>The Java SDK uses an <term>internal scheduler</term> similar to the <term>computation
                        scheduler</term> to proper isolate the inner mechanisms from user-land. It
                    is possible to change that <codeph>scheduler</codeph> through the environment,
                    but it is not recommended.</note></p>

			<p>If you want the whole subscribe chain to be executed on a specific <codeph>scheduler</codeph>,
                you use the <apiname>subscribeOn()</apiname> operator. Without a scheduler set, the
                following code executes on the main thread:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .range(1, 5)
    .map(integer -> {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .subscribe(integer ->
        System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );]]></codeblock>

            <p>The example prints:</p>

<codeblock><![CDATA[Map: (main)
Got: 3 (main)
Map: (main)
Got: 4 (main)
Map: (main)
Got: 5 (main)
Map: (main)
Got: 6 (main)
Map: (main)
Got: 7 (main)]]></codeblock>

		<p>This example shows the <apiname>subscribeOn()</apiname> method added to the flow (it doesn't
				matter where you add it):</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .range(1, 5)
    .map(integer -> {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .subscribeOn(Schedulers.computation())
    .subscribe(integer ->
            System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );]]></codeblock>

        <p>In the output of the example that uses <apiname>subscribeOn()</apiname>, you can see it
				is executed on the same thread, but on the computation thread pool:</p>

<codeblock ><![CDATA[Map: (RxComputationThreadPool-6)
Got: 3 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 4 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 5 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 6 (RxComputationThreadPool-6)
Map: (RxComputationThreadPool-6)
Got: 7 (RxComputationThreadPool-6)]]></codeblock>

		<p>If you need tighter control regarding which parts are executed on what pool, use
					<apiname>observeOn()</apiname>. Here, the order matters:</p>

<codeblock outputclass="language-java"><![CDATA[Observable
    .range(1, 5)
    .map(integer -> {
        System.out.println("Map: (" + Thread.currentThread().getName() + ")");
        return integer + 2;
    })
    .observeOn(Schedulers.computation())
    .subscribe(integer ->
            System.out.println("Got: " + integer + " (" + Thread.currentThread().getName() + ")")
    );]]></codeblock>

       <p>Everything before the <apiname>observeOn()</apiname> call is executed in
					<codeph>main</codeph>, everything below in the scheduler:</p>

<codeblock><![CDATA[Map: (main)
Map: (main)
Map: (main)
Got: 3 (RxComputationThreadPool-6)
Got: 4 (RxComputationThreadPool-6)
Got: 5 (RxComputationThreadPool-6)
Map: (main)
Map: (main)
Got: 6 (RxComputationThreadPool-6)
Got: 7 (RxComputationThreadPool-6)]]></codeblock>

		<p>There is also a way to use <codeph>schedulers</codeph> directly to schedule operations. For
                more information about <codeph>schedulers</codeph>, refer to the RxJava
                documentation about <xref
                    href="https://github.com/ReactiveX/RxJava/wiki/Scheduler#default-schedulers-for-rxjava-observable-operators"
                    format="html" scope="external">schedulers</xref>. </p>
		</section>

		<section>
			<title>Subjects</title>

		    <p>A <term>subject</term> is a hybrid between an <codeph>Observable</codeph> and a
                    <codeph>subscriber</codeph>. It can both receive and emit events. Most of the
                time you don't need <codeph>subjects</codeph> and can handle everything fine through
                    <codeph>Observables</codeph> alone, but there are certain cases when they come
                in handy.</p>

		    <p>There is a distinction between different <codeph>Observables</codeph> that have not been covered yet:</p>

			<ul>
				<li>A <term>cold Observable</term> waits for a subscription until it emits values and does this freshly for every subscriber.</li>
				<li>A <term>hot bservable</term> begins emitting values upfront and presents them to every
                    subscriber subsequently. <codeph>Subjects</codeph> are <codeph>hot
                        Observables</codeph>.</li>
			</ul>

			<p><note>Because of the network layer in between, the Java SDK needs to use subjects for its request
                    and response cycles. This also makes sense because if you subscribe twice to a
                        <apiname>bucket.get()</apiname> call, you only want one network call instead
                    of two.</note></p>

			<p>Currently, these subjects are supported by RxJava, slightly differing in their functionality:</p>

			<ul>
				<li><codeph>AsyncSubject</codeph>: Emits the last value (and only the last value) emitted by the
				    source <codeph>Observable</codeph>, and only after that source
				    <codeph>Observable</codeph> completes. If the source <codeph>Observable</codeph> does not
                    emit any values, the AsyncSubject also completes without emitting any
                    values.</li>
				<li><codeph>BehaviorSubject</codeph>: When a <codeph>subscriber</codeph> subscribes to a
                        <codeph>BehaviorSubject</codeph>, it begins by emitting the item most
                    recently emitted by the source <codeph>Observable</codeph> or an optional seed
                    or default value if none has yet been emitted. Then it continues to emit any
                    other items emitted later by the source <codeph>Observables</codeph>.</li>
				<li><codeph>PublishSubject:</codeph>
					<codeph>PublishSubject</codeph> emits to a subscriber only those items that are
				    emitted by the source <codeph>Observables</codeph>s subsequent to the time of the subscription.</li>
				<li><codeph>ReplaySubject</codeph>: <codeph>ReplaySubject</codeph> emits to any subscriber all
                    of the items that were emitted by the source <codeph>Observables</codeph>,
                    regardless of when the <codeph>subscriber</codeph> subscribes.</li>
			</ul>

			<p>As an example: if you call <apiname>bucket.get()</apiname>, an <codeph>AsyncSubject</codeph>
				is created under the covers and returned to you immediately. In addition, it is passed
				down the I/O layer and stored. When a response arrives from the server, the subject is
				fed with the response and you get notified appropriately.</p>

			<p>If you need to use a subject, choose which one to use wisely in order to keep resource usage
                low (some of them cache data for subscribers) especially if you push lots of data
                through them. You can read more about them here:
                https://github.com/ReactiveX/RxJava/wiki/Subject</p>

			<p>There is one last thing you need to know when dealing with subjects: because you are not getting new values when resubscribing (because it's cached), the following won't work (doing a get call every second):</p>

<codeblock outputclass="language-java"><![CDATA[bucket
    .get("id")
    .delay(1, TimeUnit.SECONDS)
    .repeat()
    .subscribe();]]></codeblock>

		    <p>This will only execute one get call, because subsequent attempts only load the cached value. For this reason <apiname>Observable.defer()</apiname> was added, which creates a new <codeph>Observable</codeph> for every subscriber that comes along:</p>

<codeblock outputclass="language-java"><![CDATA[Observable.defer(new Func0<Observable<JsonDocument>>() {
    @Override
    public Observable<JsonDocument> call() {
        return bucket.get("id");
    }
})
.delay(1, TimeUnit.SECONDS)
.repeat()
.subscribe();]]></codeblock>

		</section>

	</body>
</topic>
    <topic id="topic_drb_nrp_f5">
  <title>Writing Resilient Reactive Applications</title> <shortdesc>Read this section to learn how to write resilient code for production with the Couchbase
    Java SDK. </shortdesc>
  <body>
    <note type="note">Many concepts can be applied for both synchronous and asynchronous access.
      When necessary, both patterns are discussed separately. The focus is on database interaction,
      but if you are using RxJava as part of your stack, you can and should apply most of the
      principles there as well.</note>
    <section><title>RxJava 101 Recap: Cold and Hot Observables</title>
    <p>When working with <codeph>Observables</codeph>, it is important to understand the difference
        between <term>cold</term> and <term>hot</term>.</p> 
    <ul>
      <li><term>Cold Observables</term> will start to emit events once an Observer subscribes, and will do
          it "fresh" for each Observer. </li>
      <li><term>Hot Observables</term> instead are starting to emit data as soon as it becomes
          available, and will return the same (or parts of the same) to each Observer. There is also
          a special category of <codeph>Hot Observables</codeph> called <term>Subjects</term> in
          RxJava (these allow to construct <codeph>Observables</codeph> that are also Observers, so
          you can feed data manually by calling <apiname>onNext</apiname>). <!--<p>The
              <codeph>Observables</codeph> are discussed in more detail in <xref
              href="observables.dita#concept2677"/>.</p>--><p>Up to the version 2.2.0, Couchbase Java
            SDK uses <codeph>Hot Observables</codeph> for each database operation, sending a request
            to the server as soon as you obtain the <codeph>Observable</codeph>. This initial
            architectural choice allowed to avoid firing two network operations, such as when doing
            a get and subscribing twice, but it implied harder to grasp behavior when dealing with
            failures.</p><p>One of the most important things to remember is the following: when you
            resubscribe to a <codeph>Hot Observable</codeph>, it won't perform the operation against
            Couchbase Server again. In some cases, your Subscriber will only get notified about new
            emissions coming. In some cases, such as with cached/replaying
              <codeph>Observables</codeph> for the SDK, the source will emit the same data again on
            each new subscription, including if it was an error. Emitting the same data is okay in
            many cases, but not if you want to retry an operation because it has failed. That said,
            RxJava provides ways to turn <codeph>Hot Observables</codeph> into <codeph>cold</codeph>
            and vice versa. </p></li>
    </ul>
    <p>The following example is wrong for the Java SDK versions before 2.2.0 because it will give
        you the same result over and over again:</p>
      
      <codeblock outputclass="language-java">// Will just retry on the same result from the first get request \
        bucket.async().get("id").retry(5).subscribe();</codeblock>
      <p>The next example is correct, because it will produce a brand new
          <codeph>Observable</codeph> every time you retry (resubscribe).</p>
      <codeblock outputclass="language-java">// Will correctly do a new get operation against the server \
        Observable .defer(new Func0&lt;Observable&lt;JsonDocument&gt;&gt;() { @Override \
        public Observable&lt;JsonDocument&gt; call() { return \
        bucket.async().get("id"); } }) .retry(5) .subscribe();</codeblock>
      <p>Use <apiname>Observable#defer()</apiname> if you want a new <codeph>Observable</codeph> for
        every subscriber. You can also use this technique if you want to defer the execution of an
          <codeph>observable</codeph> until someone subscribes.</p>
      <p>As of Java SDK 2.2.0, all the requests sent by the SDK are using <apiname>Observable.defer
        </apiname>and as such are now <codeph>cold</codeph>.</p> 
      <p>If you want to turn a <codeph>cold</codeph> into a <codeph>hot Observable</codeph>, take a
        look at the <apiname>Observable#cache()</apiname> or <apiname>Observable#replay()</apiname>
        operators.</p>
      <p>Finally, the <codeph>Observable</codeph> is not converted from <codeph>cold</codeph> to <codeph>hot</codeph>
        just because a <codeph>hot Observable</codeph> is <codeph>flatMapped</codeph>. Therefore this code works
        perfectly fine:</p>
      <codeblock outputclass="language-java">   Observable .just("id") .flatMap(new Func1&lt;String, \
        Observable&lt;JsonDocument&gt;&gt;() { @Override public \
        Observable&lt;JsonDocument&gt; call(String id) { return \
        bucket.async().get(id); } }) .retry(5) .subscribe();</codeblock> 
    </section> 
<section><title>Error Recovery</title>
  <p>This section discusses different strategies to mitigate errors that might come up during
        operations (covered in <xref href="#topic_drb_nrp_f5/errorcauses" format="dita"/>). Some of
        them are shown to make a point, but the techniques apply to all different types of errors
        and can be applied as you see fit.</p>

<sectiondiv>
  <p><b>Logging</b></p>
 
    <p>It is always important to log errors, but even more so in the case of reactive applications.
          Because of the event driven nature, stack traces get harder to look at, and caller context
          is sometimes lost.</p> <p>RxJava provides operators for "side effects" (additional behavior that doesn't change the items
          flowing through the <codeph>Observable</codeph> stream), which should be used to log
          errors. Of course, you can also put logging into the error handlers, but readability is
          increased if the logging is put explicitly as a side effect.</p>
            <codeblock outputclass="language-java">   Observable .error(new Exception("I'm failing")) .doOnError(new \
        Action1&lt;Throwable&gt;() { @Override public void call(Throwable \
        throwable) { // I'm an explicit side effect // use a proper logger of \
        your choice here LOGGER.warn("Error while doing XYZ", throwable); } }) .subscribe(); </codeblock><p>It is also recommended to configure your logger to include absolute timestamps. While this is
          always a good idea, if combined with good logging throughout the application it makes it
          easier to debug error cases and see later what was going on inside your reactive
          application. </p><p>You can also utilize the various other side-effect operators for general logging
            (<apiname>doOnNext</apiname>, <apiname>doOnCompleted</apiname>). If you don't want to
          have different side effects for the same logging operation, you can use
            <apiname>doOnEach</apiname>. It will be called for both errors and next events with a
            <apiname>Notification</apiname> object that denotes what kind of event is being
          processed.</p>
</sectiondiv>     
 <sectiondiv> 
<p><b>Failing</b></p>
 <p>Failing is the easiest way to handle errors - because you don't. While most of the time you want
          more sophisticated error handling strategies (as discussed later), sometimes you just need
          to fail. It makes no sense for some errors to be retried, either because they are not
          transient or because you already tried everything to make it work and it still keeps
          failing. </p><p>In error-resilient architectures, you want to do everything to keep the error contained. However,
          if the containment is not able to handle the error it needs to propagate it to a parent
          component that (possibly) can.</p><p>In the async case, errors are events like every other for your subscribers. Once an error
          happens, your <codeph>Subscriber</codeph> is notified in the method
            <apiname>onError(Throwable)</apiname>, and you can handle it the way you want to. Note
          that by <codeph>Observable</codeph> contract, after the <apiname>onError</apiname> event,
          no more <apiname>onNext</apiname> events will happen.</p>
         
      <codeblock outputclass="language-java">   Observable
        .error(new Exception("I'm failing"))
        .subscribe(new Subscriber&lt;Object&gt;() {
          @Override
          public void onCompleted() {
          }
          
          @Override
          public void onError(Throwable e) {
          System.err.println("Got Error: " + e);
          }
          
          @Override
          public void onNext(Object o) {
          }
          });  </codeblock>   
      <p>It is always a good idea to implement error handling.</p>
      <p>In the synchronous case, every error is converted into an Exception and thrown so that you
          can use regular <apiname>try</apiname>/<apiname>catch</apiname> semantics.</p>
      <codeblock outputclass="language-java">   try {
        Object data = Observable
        .error(new Exception("I'm failing"))
        .toBlocking()
        .single();
        } catch(Exception ex) {
        System.err.println("Got Exception: " + ex);
        }
        </codeblock>
      <p>If you do not catch the Exception, it will bubble up:</p>
      <codeblock outputclass="language-java"> Exception in thread "main" java.lang.RuntimeException: java.lang.Exception: I'm failing
      at rx.observables.BlockingObservable.blockForSingle(BlockingObservable.java:482)
      at rx.observables.BlockingObservable.single(BlockingObservable.java:349)
      </codeblock>     
 </sectiondiv>  
  <sectiondiv>
    <p><b>Retry</b></p>
    <p>Retrying operations is a common technique to ride over transient errors. It should not be
          used for non-transient errors because it will only put a load onto the system without the
          chance to resolve the error.</p>
    <p>In practice, the following retry strategies can be applied when a transient error is discovered:</p>
    <ul>
      <li>Retry immediately.</li>
      <li>Retry with a fixed delay.</li>
      <li>Retry with a linearly increasing delay.</li>
      <li>Retry with an exponentially increasing delay.</li>
      <li>Retry with a random delay.</li>   
    </ul>
    <p>Unless you have a very good reason not to, <i>always</i> apply a maximum number of attempts
          and then escalate the error. Systems stuck in infinite retry loops can cause issues that
          are very hard to debug. It's better to fail and propagate at some point.</p>
    <p>Also, we recommend that you use asynchronous retry even if you are blocking at the very end.
          Retrying in the asynchronous <codeph>Observables</codeph> is way more resource efficient
          and also the only sane way to handle multiple operation steps (and bulk operations) under
          a single timeout (read more in  <xref href="#topic_drb_nrp_f5/timeouts" format="dita"
          />).</p>
    <p>Starting with 2.1.0 the Java SDK comes with a <apiname>RetryBuilder</apiname>, a utility
          class to describe retries with a fluent API (see ). In earlier versions use the code
          provided in the documentation.</p>
  
  <dl>
    <dlentry>
      <dt>Retry without delay</dt>
      <dd>Let's get one thing straight right away: immediately retrying is almost never a good idea.
              Instead of resolving the error more quickly, it will put more pressure onto the
              retried system, and there is a good chance it will make resolving errors harder.
                <p>One good reason to do so is if you have a specific operation with a very short
                timeout that you want to keep retrying for a small, fixed amount of times and if it
                still does not work, fail fast. </p><p>If you have the feeling you need to retry
                very quickly, you can also apply a very slight increasing delay to, at least,
                release some pressure from the target system. </p><p>RxJava provides the
                  <apiname>retry</apiname> operator to resubscribe to the source
                  <codeph>Observable</codeph> immediately once it fails (an error event happens).
                Three flavors are available: </p><ul>
                <li><apiname>retry()</apiname>: Instantly retry as long as the source
                    <codeph>Observable</codeph> emits an error. It is strongly recommend not to use
                  this operator.</li>
                <li><apiname>retry(long count)</apiname>: Instantly retry as long as the source
                    <codeph>Observable</codeph> emits an error or the max count is reached. If the
                  count is reached, the Observable will not be resubscribed, but the error is
                  propagated down the stream. This operator is recommended for use.</li>
                <li><apiname>retry(Func2&lt;Integer, Throwable, Boolean&gt; predicate)</apiname>:
                  Instantly retry as long as the predicate returns true. Arguments to the predicate
                  are the number of tries, as well as the exception type. </li>
              </ul><p>Since the <codeph>predicate</codeph> method provides the most flexibility, it
                is recommended to use it. If you only want to handle a specific exception and retry
                a maximum of <codeph>MAX_TRIES</codeph> times, you can do it like this:
                </p><codeblock outputclass="language-java">   Observable .error(new CASMismatchException()) .retry(new \
          Func2&lt;Integer, Throwable, Boolean&gt;() { @Override public Boolean \
          call(Integer tries, Throwable throwable) { return (throwable \
          instanceof CASMismatchException) &amp;&amp; tries &lt;MAX_TRIES; } }) .subscribe();         </codeblock><p>Try
                replacing <codeph>CASMismatchException</codeph> with something else and you will see
                that it does not try to retry, but rather propagates the error downstream. You can
                use this technique to handle specific errors differently by adding more retry
                operators in the pipeline. </p><p>Using the <codeph>retry</codeph> with
                  <codeph>predicate</codeph> also allows you to log the number of retries for a
                specific error. If you use the <apiname>doOnError</apiname> for logging, it's harder
                to log the number of retries.</p><p>The synchronous equivalent to the latest code
                looks like
              this:</p><codeblock outputclass="language-java">   int tries = 0; while(true) { tries++; try { pretendWorkThatMaybeThrows(); // \
          does some work and maybe throws break; } catch(Throwable throwable) { if (!(throwable \
          instanceof CASMismatchException) || tries >= MAX_TRIES) { throw throwable; // \
          rethrow exceptions } } }</codeblock>
            </dd>
    </dlentry>
  </dl>
        <dl id="retrydelay">
          <dlentry>
            <dt>Retry with delay</dt>
            <dd>When applying a <term>Retry with delay</term>, the main question you need to ask
              yourself is: how often and how long is it feasible to retry before giving up (and
              escalate the error). Using this retry option depends on the type of operation, use
              case, and SLA that the application requires, but the techniques are the same.
                <p>RxJava provides the <apiname>retryWhen</apiname> operator, which allows you more
                flexibility with the actions performed as well as when the resubscription is
                happening. This section covers the different delay approaches based on this
                operator.</p><p>Here is the contract for <apiname>retryWhen</apiname> that you
                should always keep in mind: </p><ul>
                <li>It is called when an error on the source <codeph>Observable</codeph>
                  happens.</li>
                <li>The function provided will be called with an <codeph>Observable</codeph>
                  containing this error.</li>
                <li>If you make this <codeph>Observable</codeph> error, it is propagated downstream
                  (without retrying).</li>
                <li>If you make this <codeph>Observable</codeph> complete, it is propagated
                  downstream (without retrying).</li>
                <li>If you make this <codeph>Observable</codeph> call <apiname>onNext</apiname>, a
                  retry will happen. </li>
              </ul><p>Since the version 2.1.0 the Java SDK comes with the
                  <apiname>RetryBuilder</apiname>, a helper to describe when and how to retry: only
                on certain classes of exceptions, max 5 attempts, the exponential delay between
                attempts, and so on. The result of this builder (<apiname>calling build()</apiname>)
                can be used with RxJava's <apiname>retryWhen</apiname> operator directly:
                </p><codeblock outputclass="language-java">Observable.error(new IllegalStateException())
          .retryWhen(
          RetryBuilder.anyOf(IllegalStateException.class).max(6).delay(Delay.linear(TimeUnit.SECONDS)).build()
          ); </codeblock><p>This
                code will ultimately fail after 6 additional attempts. It would fail fast if the
                source errored with something else than an<apiname> IllegalStateException</apiname>
                during retries. Each attempt will be made with an increasing delay, which grows
                linearly (1 second, then 2, 3, 4). If an exception occurs that is not managed by the
                handler, it is propagated as is, allowing you to chain such handlers. </p><p>If the
                maximum number of attempts is reached, the last exception that occurred is
                propagated, wrapped in a <apiname>CannotRetryException</apiname>. This helper allows
                to write retry semantics more easily, but in this section it is explained how to
                write them from scratch. </p><p>The easiest approach is the <term>fixed
                delay</term>. The source <codeph>Observable</codeph> will be resubscribed after a
                specified amount of time and for a fixed maximum number of times. </p><p>Because the
                nested logic is a bit harder to understand in the first place, let's talk through it
                step by step and then put it together. </p><p>Our <apiname>retryWhen</apiname>
                function is called every time an error happens on the source
                  <codeph>Observable</codeph>. If we wanted to try forever every second, it could
                look like this: </p><codeblock outputclass="language-java">    .retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, \
          Observable&lt;?&gt;&gt;() { @Override public Observable&lt;?&gt; call(Observable&lt;? \
            extends Throwable&gt; errorNotification) { return \
            errorNotification.flatMap(new Func1&lt;Throwable, Observable&lt;?&gt;&gt;() { \
          @Override public Observable&lt;?&gt; call(Throwable throwable) { return \
            Observable.timer(1, TimeUnit.SECONDS); } }); } })
          </codeblock>
              <p>We <apiname>flatMap</apiname> our notification <codeph>Observable</codeph> and
                utilize the <apiname>Observable#timer</apiname> to defer emitting a new event for a
                second. Since we need to stop at some point, after a given number of tries, we can
                utilize the <apiname>Observable#zipWith</apiname> operator to zip our error stream
                together with a range where we specify the number of tries we want to allow. Zipping
                has the nice side-effect that once one of the <codeph>Observable</codeph> is
                completed, the resulting <codeph>Observable</codeph> will also be complete, which
                triggers our Rule 4 from above.</p><p>The modified version looks like this:</p><codeblock outputclass="language-java">   .retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() {
                @Override
                public Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; errorNotification) {
        return errorNotification
            .zipWith(Observable.range(1, 4), new Func2&lt;Throwable, Integer, Integer&gt;() {
                @Override
                public Integer call(Throwable throwable, Integer attempts) {
                    return attempts;
                }
            })
            .flatMap(new Func1&lt;Integer, Observable&lt;?&gt;&gt;() {
                @Override
                public Observable&lt;?&gt; call(Integer attempts) {
                    return Observable.timer(1, TimeUnit.SECONDS);
                }
            });
    }
}) </codeblock>
              <p>Technically, we don't need the zip function here because we ignore it later on, but
                it is required for the <codeph>zipWith</codeph> operator to work. We use the
                  <apiname>Observable#range</apiname> operator to create an
                  <codeph>Observable</codeph> that emits three events and then completes, so we will
                never end up with more retries.</p><p>There is one more enhancement needed: the code
                as it stands there will swallow the originating exception when moving on, which is
                not good because it should be propagated if it can't be handled in this code block.
                </p><p>The following code is modified so that the function of
                  <codeph>zipWith</codeph> returns not only the attempted count but also the
                throwable, so that Couchbase Server has access to it in the
                  <apiname>flatMap</apiname> method. For this, the Java client has a generic
                  <apiname>Tuple</apiname> the server can utilize. In the
                <apiname>flatMap</apiname>, Couchbase Server checks for the number of attempts, and
                if it is over the threshold, it rethrows the exception. Keep in mind that you need
                to change <apiname>Observable#range</apiname> call to
                  <codeph>MAX_ATTEMPTS+1</codeph>, to give your code a chance to be called again one
                final time.</p>
              <codeblock outputclass="language-java">   .retryWhen(new Func1&lt;Observable&lt;? extends Throwable>, \
          Observable&lt;?&gt;&gt;() { @Override public Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; \
          errorNotification) { return errorNotification .zipWith(Observable.range(1, 5), \
          new Func2&lt;Throwable, Integer, Tuple2&lt;Throwable, Integer&gt;&gt;() { @Override \
          public Tuple2&lt;Throwable, Integer> call(Throwable throwable, Integer attempts) { \
          return Tuple.create(throwable, attempts); } }) .flatMap(new Func1&lt;Tuple2&lt;Throwable, \
          Integer&gt;, Observable&lt;?&gt;&gt;() { @Override public Observable&lt;?&gt; \
          call(Tuple2&lt;Throwable, Integer&gt; attempt) { if (attempt.value2() == 3) \
          { return Observable.error(attempt.value1()); } return Observable.timer(1, TimeUnit.SECONDS); } }); } })</codeblock><p>If
                you want to enhance it even further, you can add one more
                <apiname>if()</apiname>clause in the <apiname>flatMap</apiname> to see if the
                throwable that is passed down is actually the one we want to
                retry.</p><p>Functionality like this is a great candidate to be generic and
                encapsulated, so that's what we did with <apiname>RetryBuilder</apiname>. If you are
                already using Java 8, the code becomes more condensed as
                well:</p><codeblock outputclass="language-java">  .retryWhen(notification -> notification .zipWith(Observable.range(1, 5), \
                Tuple::create) .flatMap(att -> att.value2() == 3 ? Observable.error(att.value1()) : \
                Observable.timer(1, TimeUnit.SECONDS) ) ) </codeblock><p>Here
                are the variations for linear, exponential and random delays:
                </p><p><b>Linear:</b></p><codeblock outputclass="language-java">   // Utilizes the number of attempts for the number of seconds to wait .\
                retryWhen(notification -> notification .zipWith(Observable.range(1, 5), \
                Tuple::create) .flatMap(att -> att.value2() == 3 ? Observable.error(att.value1()) : \
                Observable.timer(att.value2(), TimeUnit.SECONDS) ) )</codeblock><p><b>Exponential:</b></p><codeblock outputclass="language-java">   // Uses the timer with 2^attempts to generate exponential delays \
                .retryWhen(notification -> notification .zipWith(Observable.range(1, 5), \
                Tuple::create) .flatMap(att -> att.value2() == 3 ? Observable.error(att.value1()) : \
                Observable.timer(1 &lt;&lt; att.value2(), TimeUnit.SECONDS) ) )</codeblock><p><b>Random:</b></p><codeblock outputclass="language-java">   // Random between 0 and 5 seconds to retry per attempt .retryWhen(notification -> \
                notification .zipWith(Observable.range(1, 5), Tuple::create) .flatMap(att -> \
                att.value2() == 3 ? Observable.error(att.value1()) : \
                Observable.timer(new Random().nextInt(5), TimeUnit.SECONDS) ) )</codeblock><p>With
                the synchronous code, there are not many options other than using
                  <apiname>Thread.sleep()</apiname> to keep the current thread waiting until the
                loop is allowed to proceed:</p><codeblock outputclass="language-java">   // Linear Backoff
                int tries = 0;
                while(true) {
                tries++;
                try {
                pretendWorkThatMaybeThrows(); // does some work and maybe throws
                break;
                } catch(Throwable throwable) {
                if (!(throwable instanceof CASMismatchException) || tries >= MAX_TRIES) {
                throw throwable; // rethrow exceptions
                }
                }
                
                Thread.sleep(TimeUnit.SECONDS.toMillis(tries));
                }             </codeblock>
              <p>You can then use the same approaches as with the asynchronous ones on the
                  <apiname>Thread.sleep()</apiname> time to accommodate for a static, linear,
                exponential or random delay. </p></dd>
    </dlentry>
  </dl>
    
  </sectiondiv>
  <sectiondiv><p><b>Fallback</b></p><p>Instead of (or in addition to) retrying, another valid option is falling back to either a
          different <codeph>Observable</codeph> or a default value. </p><p>RxJava
          provides you with different operators, prefixed with <apiname>onError*()</apiname>:</p><ul>
          <li><apiname>onErrorReturn(Func1&lt;Throwable, T&gt;)</apiname>: It is called when the
            source <codeph>Observable</codeph> errors and allows to return custom data instead.</li>
          <li><apiname>onErrorResumeNext(Observable&lt;?&gt;)</apiname>: It is called when the
            source <codeph>Observable</codeph> errors and allows to resume transparently with a
            different Observable.</li>
          <li><apiname>onErrorResumeNext(Func1&lt;hrowable, Observable&lt;?&gt;)</apiname>: It is
            called when the source <codeph>Observable</codeph> errors and allows to transparently
            resume with an <codeph>Observable</codeph> (based on a specific
              <codeph>Throwable</codeph>).</li>
        </ul><p>You should use the <apiname>onErrorReturn</apiname> if you want to fallback to
          static data quickly. For
          example:</p><codeblock outputclass="language-java">    Observable
      .&lt;String&gt;error(new Exception("I failed"))
        .onErrorReturn(new Func1&lt;Throwable, String&gt;() {
          @Override
          public String call(Throwable throwable) {
          // You could return data based on the throwable as well
          return "Default";
          }
          })
          .subscribe();</codeblock><p>If you only want to return default values based on a specific exception or even call another
            <codeph>Observable</codeph> as fallback, <apiname>onErrorResumeNext</apiname> is what
          you're looking for. </p>
    <codeblock outputclass="language-java">Observable
      .&lt;String&gt;error(new TimeoutException("I failed"))
        .onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends String&gt;&gt;() {
          @Override
          public Observable&lt;? extends String&gt; call(Throwable throwable) {
            if (throwable instanceof TimeoutException) {
                return Observable.just("Default");
            }
            // Forward anything other than the TimeoutException
            return Observable.error(throwable);
        }
    })
    .subscribe();</codeblock><p>If you just want to fallback onto another <codeph>Observable</codeph> that you have in scope
          without caring about the Exception, you can use the other
            <apiname>onErrorResumeNext()</apiname> overload. For example, this loads data from all
          replicas if the <apiname>get()</apiname> call did not succeed with the Java SDK:</p><codeblock outputclass="language-java">   bucket
      .async()
      .get("id")
      .onErrorResumeNext(bucket.async().getFromReplica("id", ReplicaMode.ALL))
      .subscribe();   </codeblock><p>Synchronous
          fallbacks can be implemented by conditionally setting the default in the
            <apiname>catch</apiname>
          clause:</p><codeblock outputclass="language-java">   String value;
      try {
      value = pretendWorkThatMaybeThrows();
      } catch(Exception ex) {
      value = "Default";
      }   </codeblock><p>Here is the gotcha: this synchronous example only works great if the fallback is static. If you
          need to fallback into another database call, for example, you quickly get into nested
          error handling and timeouts are a pain to handle (since they start to accumulate for every
          synchronous call). It is recommended to use asynchronous fallbacks and then block at the
          very end through <apiname>toBlocking().single()</apiname> or equivalents.</p></sectiondiv>
 
  
  <sectiondiv><p><b>Defaults</b></p><p>Another possibility that requires intervention on the application side are
            <codeph>Observables</codeph> that do not emit a single value. This can happen because
          operators filtered the <codeph>Observable</codeph> so that nothing is left, or they did
          not produce any values in the first place. One common case in the Java SDK is
            <apiname>get()</apiname>. If the Document is not found, the <codeph>Observable</codeph>
          will complete without emitting anything.</p><p>RxJava provides helper operators that all end with <apiname>*OrDefault()</apiname> and allow you
          to return default values if no item is emitted when the <codeph>Observable</codeph>
          completes.</p><p>In most cases, you want to use <apiname>singleOrDefault()</apiname> and return a default value
          when not a single item is emitted by the source <codeph>Observable</codeph>:</p>
    <codeblock outputclass="language-java">Observable
      .&lt;String&gt;empty()
        .singleOrDefault("Default")
        .subscribe(); </codeblock>   
          
          <p>If you are dealing with potentially more than one item emitted in your
            <codeph>Observable</codeph> and you only want to emit either the first or the last
          value, there are also operators that allow you to emit a default if it's unexpectedly
          empty. See <apiname>firstOrDefault()</apiname> as well as
            <apiname>lastOrDefault()</apiname> for more details.</p><p>Lastly, RxJava offers the method <apiname>defaultIfEmtpy</apiname>, which allows you to return a
          value if the source doesn't emit anything. In recent versions, the method
            <apiname>switchIfEmpty</apiname> allows you to switch to a different
            <codeph>Observable</codeph> in that same case.</p></sectiondiv>
  <sectiondiv>
    <p><b>Error handling in bulk scenarios</b></p>
    
    <p>Bulk operations are used to handle more data in one batch and, therefore, benefit from better
          resource utilization. However,  error handling becomes more complicated. There are three
          high-level cases to consider:</p>
    
    <ul>
      <li><b>Best Effort</b>: Keep going and just use the results that succeeded when errors
            happen.</li>
      <li><b>Full Retry</b>: Retry the complete Observable when errors happen.</li>
      <li><b>Incremental Retry</b>: Only retry specific events of the Observable.</li>
    </ul>
    <p>Before we "dig" into the specific approaches, let's revisit the contract of Observables:</p>
    <codeblock outputclass="language-java">onNext* (onError | onComplete)</codeblock>
    <p>Zero or more events are followed by either an error event or a complete event. 
      This provides an important clue right away: once our <codeph>Observable</codeph> fails, no more events can be passed through. 
      Therefore, 
      you need to make sure that errors are handled at the smallest scope possible, only letting it proceed 
      if you cannot handle it right away.</p>
  
  <dl>
    <dlentry>
      <dt>Best effort bulk handling</dt>
      <dd>Sometimes it is more important to get data in a timeframe, or maybe with a short timeout,
              then getting all data. In general, you want to keep a timeout that lets you fetch all
              the data, but depending on the use case you are fine with only getting a subset of the
              data returned. <p>To ignore errors and turn them into "noops", you can utilize
                  <apiname>onErrorResumeNext()</apiname>:</p><codeblock outputclass="language-java">    Observable
          .create(new Observable.OnSubscribe&lt;String&gt;() {
            @Override
            public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext("A");
            subscriber.onNext("B");
            subscriber.onError(new IllegalStateException("Woops"));
            subscriber.onNext("C");
        }
    })
    .onErrorResumeNext(Observable.&lt;String&gt;empty())
    .toBlocking()
    .forEach(new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            System.out.println("Got: " + s);
        }
    });</codeblock>
              <p>This will not raise any exception to your calling thread, but it will never process
                "C" because, based on the <codeph>Observable</codeph> contract, once
                  <apiname>onError</apiname> is called no more events are allowed to be
                generated.</p><p>To keep going in case an event fails, you need to turn each event
                into a single <codeph>Observable</codeph> and then merge it back together to either
                defer the error handling (through <apiname>Observable#mergeDelayError</apiname>) or
                use <apiname>flatMap</apiname> and make sure to contain the errors before
                flattening.</p><p>This code provides some fake data with which you can work. It will
                emit four <codeph>Observables</codeph> where one of them will
                fail:</p><codeblock outputclass="language-java">    Observable&lt;Observable&lt;String&gt;&gt; dataObservables = Observable
          .just("a", "b", "c", "d")
          .map(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
            @Override
            public Observable&lt;String&gt; call(String s) {
              if (s.equals("b")) {
              return Observable.error(new IllegalStateException("I dont like b"));
              }
              return Observable.just(s);
              }
              });</codeblock><p>You
                can then use <apiname>mergeDelayError</apiname> to defer error handling until the
                end. If you uncomment the <apiname>onErrorResumeNext</apiname>, it will silently
                discard any errors as well leaving you with an <codeph>Observable</codeph> that
                provides best-effort processing of the source <codeph>Observables</codeph>.
                </p><codeblock outputclass="language-java">   Observable.mergeDelayError(dataObservables)
          //.onErrorResumeNext(Observable.&lt;String&gt;empty())
            .toBlocking()
            .forEach(new Action1&lt;String&gt;() {
              @Override
              public void call(String s) {
              System.out.println(s);
              }
              });        </codeblock><p>Alternatively,
                you can use <apiname>flatMap</apiname> and make sure the errors are contained for
                each emitted
                <codeph>Observable</codeph>:</p><codeblock outputclass="language-java">    Observable
          .just("a", "b", "c", "d")
          .flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
            @Override
            public Observable&lt;String&gt; call(String s) {
              // Simulate some observable that sometimes fails
              Observable&lt;String&gt; obs;
                if (s.equals("b")) {
                obs = Observable.error(new IllegalStateException("I dont like b"));
                } else {
                obs = Observable.just(s);
                }
                
                // Here comes the actual handling part before we flatten it back
                return obs.onErrorResumeNext(Observable.&lt;String&gt;empty());
                  }
                  })
                  .toBlocking()
                  .forEach(new Action1&lt;String&gt;() {
                    @Override
                    public void call(String s) {
                    System.out.println(s);
                    }
                    });
        </codeblock><p>As
                a more practical example here is a best effort bulk loading of documents from
                Couchbase Server that just discards operations that fail: </p><codeblock outputclass="language-java">    private static Observable&lt;JsonDocument&gt; loadDocsBestEffort(Bucket bucket, List&lt;String&gt; ids) {
            return Observable
            .from(ids)
            .flatMap(new Func1&lt;String, Observable&lt;JsonDocument&gt;&gt;() {
              @Override
              public Observable&lt;JsonDocument&gt; call(String id) {
                return bucket
                .async()
                .get(id)
                .onErrorResumeNext(Observable.&lt;JsonDocument&gt;empty());
                  }
                  });
                  }
        </codeblock>
              <p>Of course, you can add more logic onto each emitted <codeph>Observable</codeph> and
                also proper logging so that you at least know which errors occurred.</p></dd>
    </dlentry>
  </dl>
    <dl>
      <dlentry>
        <dt>Full retry bulk handling</dt>
        <dd>Full retry bulk handling can be done by just chaining one of the retry operators right
              at the end of the <codeph>Observable</codeph> chain. <note type="note">This example
                uses Java 8 Lambda syntax for conciseness.</note><codeblock outputclass="language-java">    private static Observable&lt;JsonDocument&gt; loadDocsFullRetry(Bucket bucket, List&lt;String&gt; ids) {
              return Observable
              .from(ids)
              .flatMap(id -> return bucket.async().get(id))
              .retry(4);
              } </codeblock>
              <p>This is, however, a bit crude because the whole list of IDs will be retried if
                there is an error. This is the case even if the error happens late in the stream and
                some items have already been emitted. Imagine that you retrieve items
                  <codeph>A</codeph>, <codeph>B</codeph>, <codeph>C</codeph>, <codeph>D</codeph> and
                that an error occurs just the first time the SDK retrieves C. What you will see is
                  <codeph>A</codeph>, <codeph>B</codeph>, <codeph>A</codeph>, <codeph>B</codeph>,
                  <codeph>C</codeph>, <codeph>D</codeph>.</p><p>This can be mitigated by using the
                  <apiname>distinct()</apiname> operator, but keep in mind the memory tradeoff
                (distinct will maintain a set of values it saw in the background, which can be
                problematic for infinite or very large streams).</p></dd>
      </dlentry>
    </dl>
    <dl>
      <dlentry>
        <dt>Incremental retry bulk handling</dt>
        <dd>Incremental retry improves on full retry by only actually retrying elements that
              couldn't be loaded. It is easily done by chaining the retry operators inside the
                <apiname>flatMap</apiname> instead of outside of it.
              <codeblock outputclass="language-java">    private static Observable&lt;JsonDocument&gt; loadDocsIncrementalRetry(Bucket bucket, List&lt;String&gt; ids) {
              return Observable
              .from(ids)
              .flatMap(id -> return bucket.async().get(id)
              .retry(4)
              );
              }         </codeblock>
              One thing to keep in mind with <apiname>flatMap</apiname> is that the order of
              emissions isn't guaranteed to be the same as the source emissions. This can be
              especially visible in this case since individual streams are retried on their own:
              retried keys could come back with a value much later than other keys, more often
              changing the order in which they appear.</dd>
      </dlentry>
    </dl>
    <dl>
      <dlentry>
        <dt>Bulk pattern, <apiname>BackpressureException</apiname> and reactive pull backpressure</dt>
        <dd>The bulk pattern is powerful, but if you try it with a very large collection, it is
              especially susceptible to a <apiname>BackpressureException</apiname>. This exception
              is a way for the SDK to tell you that you're asking for too much in a short amount of
              time, and requests have piled up too much while waiting for a server response to free
              up a spot. <p>By default, the internal structure that holds pending requests is sized
                to a little over 16 000 slots. Since <apiname>from</apiname> iterates over a
                collection in memory, which is <i>very</i> fast, it can easily flood the SDK if the
                size of it is over or close to 16K.</p><p>You could try to react to that by
                implementing a retry strategy, but it is hard to get it right. Fortunately, RxJava
                comes with an even better solution, a form of flow-control called <term>reactive
                  pull backpressure</term> that you can leverage to avoid getting a
                  <apiname>BackpressureException</apiname>. </p><p>This is done through the
                Subscriber, its <apiname>onStart()</apiname> method and the
                  <apiname>request(n)</apiname> method.</p><note type="note">You have to use the
                Subscriber to <apiname>subscribe()</apiname> instead of the convenience methods that
                just take <apiname>Action</apiname> individually for <apiname>next</apiname>,
                  <apiname>error</apiname> and <apiname>completed</apiname> handlers.</note>
              <codeblock outputclass="language-java"> 
    Observable&lt;JsonDocument&gt; largeBulk = Observable
              .from(oneMillionIds)
              .flatMap(id -> return bucket.async().get(id));
              
              //the subscription is where reactive pull backpressure happens
              largeBulk.subscribe(new Subscriber&lt;JsonDocument&gt;() {
                
                //onStart initiates the backpressure
                @Override
                public void onStart() {
                request(100);
                }
                
                @Override
                public void onNext(JsonDocument jsonDocument) {
                System.out.println(jsonDocument.content());
                request(100); //request more items
                }
                
                //onCompleted and onError are less relevant.
                //Note that if you want to block you'd need a CountDownLatch in this case
                
                @Override public void onCompleted() { System.out.println("Done"); }
                
                @Override public void onError(Throwable e) { e.printStackTrace(); }
                
                });
          </codeblock>
              <p>The <apiname>request(n)</apiname> method allows to notify the upstream source that
                the consumer is ready for more, and is prepared to consume <codeph>n</codeph> items.
                For example, this avoids instant iteration of the collection in the case of
                  <apiname>from</apiname>. And as long as responses come in from Couchbase Server,
                we continue asking for more.</p><p> This is a form of <term>error mitigation</term>,
                and we'll see a few others in the next section. </p></dd>
      </dlentry>
    </dl>
  </sectiondiv>  
  
</section>
<section><title>Error Mitigation</title>
  <p>The idea behind <term>error mitigation</term> is to limit the impact a failing piece had on the
        rest of the system. When an error occurs, you don't want it to cause failures downstream.
        You also want to prevent as much of the error conditions to happen as possible.</p>
  <p>The <apiname>BackpressureException</apiname> and RxJava's <term>reactive pull
          backpressure</term> are forms of error mitigation we already saw since they both allow a
        form of flow control that avoids overloading the system.</p>
<sectiondiv>
  <p><b>Slowing down</b></p>
  <p>Rate limiting of the requests can be a way to keep the system within parameters that are known
          to be stable, thus mitigating overloading errors. This can happen in the client-to-server
          direction, which avoids making more requests than can be processed later. It can also
          happen in the server-to-client direction, when the client can't keep up with the bandwidth
          at which data is sent from the server because, for instance, it has to process it through
          long-running tasks. Rather than choking on that data when backpressure mechanisms are not
          available, the client can decide to discard some of the data. This is referred to as
            <term>Load Shedding</term>.</p> 
  <p>For example, consider a system where multiple sensors write data into Couchbase, and the client
          application reads that data and displays it in a UI. The graphs in the UI can be built on
          a <codeph>sample</codeph> of the data, and that's the key point. The processing rate of
          the data is lower than its producing rate, but at the same time the resolution is also
          lower. That means we can simply ignore some of the data and only consume what's needed,
          such as take the data point at every second to trigger a refresh of the graph in the
          UI.</p>
  <p>RxJava allows you to do that through several operators:</p>
  <ul>
    <li><apiname>sample</apiname> (alternatively <apiname>throttleLast</apiname>) periodically looks at an Observable and emits the item last seen during this period.</li>
    <li><apiname>throttleFirst</apiname> does the same except it emits the <codeph>first</codeph> item seen during the period.</li>
    <li><apiname>debounce</apiname> only emits an item if a given timespan has passed since the last emission, eliminating items that are rapidly following another item.</li>
  </ul>
  <p>The operator <apiname>sample</apiname> is useful for sources that are "too chatty" even at a
          regular rate. The operator <apiname>debounce</apiname>, on the other hand, is really
          shining with sources that have a variable rate of emission.  The sources only trigger a
          web search for autocomplete suggestions from an input form once the user has stopped
          typing for 500ms.</p>
  
</sectiondiv>
  <sectiondiv>
    <p><b>Semaphore</b></p>
    <p>To limit the strain put on dependencies of your application, one possibility is to put hard
          limits on how many concurrent threads can access a resource. This is done with the classic
          concurrency programming pattern of the <apiname>Semaphore</apiname>, which is implemented
          in <apiname>java.util.concurrent</apiname> since Java 7.</p>
    
    <p>Note that Semaphores are a bit different from locks since they don't have a notion of
          ownership. For example, two different threads can respectively
            <apiname>acquire()</apiname> and <apiname>release()</apiname> a
            <apiname>Semaphore</apiname> permit), which can avoid things like deadlocks.</p>  
    <p>The same concept could also be implemented using a fixed-size thread pool. Such thread pool
          adds overhead but allows upstream code to just "walk away" from the call if it takes too
          long for a slot to become available, providing an even better isolation.</p>  
    
  </sectiondiv>
  <sectiondiv>
    <p><b>Collapsing requests</b></p>
    <p>Another way of mitigating errors is to batch similar requests together and "collapse" them
          into one request to the subsystem. If you have multiple threads that potentially ask for
          the same data, the benefit can be immediate by just putting a facade on your calls that
          will deduplicate parallel requests.</p>
    <p>You can go beyond and trade a little bit of latency to allow for more potential
          deduplication. Wait a little longer to see if any duplicate request comes in before firing
          the actual deduplicated request.</p>
  </sectiondiv> <sectiondiv>
    <p><b>Implementation</b></p>
    <p>All the mentioned techniques can be easily implemented in an application in a
          RxJava-compatible way by using another library from Netflix, <xref
            href="https://github.com/Netflix/Hystrix/wiki" format="html" scope="external"
            >Hystrix</xref>. It is a very comprehensive library for building resilient applications,
          including techniques for error mitigation but also failing fast. Here, the circuit-breaker
          pattern short-circuits calls to a service that is known to be down until we detect it is
          back up, which stops cascading failures, provides fallbacks and gathers metrics.</p> 
  </sectiondiv>
</section> 
    <section id="errorcauses">
    <title>Error Causes</title>
    <p>This section discusses errors that need to be covered by the application developer to make
        the application resilient.</p>
    </section>
    <section id="timeouts"><title>Timeouts</title>
     
      <p>Timeouts are a very important part of a distributed application that needs to be resilient.
          When a network is involved, you can be sure that something will fail, be it a network
          partition, a server that takes a long time to answer or one that is simply down. Timeouts
          are both your worst nightmare and a very important safety net. You should never let a call
          hang forever. On the contrary, it is usually better to fail fast and retry/fallback, as we
          saw earlier. The <codeph>sane</codeph> timeouts (not too long, not too short) give you
          that guarantee that the call won't block forever. They can keep you awake at night because
          you are virtually guaranteed to see some of them in production. However,  that's OK once
          you embrace them  because they do, in fact, give you control. You decide how much time
          your application will wait before either a result or an error happens, and there are no
          more random (and potentially very long) outliers.</p>
      <p>You have to decide on relevant durations for your timeouts, and then put them into place,
          and finally design and implement the failure-recovery scenarios for the situation when a
          timeout occurs. This should be guided in part by your SLAs: say your SLAs indicate that
          the app should respond in 1.5s in the 99th percentile, and then you'll probably have to
          set timeouts below this duration. Think about the compounding effect as well! Note that it
          is usually a good idea to come up with SLAs internally if your business doesn't explicitly
          define some.</p>
      <p>There are so many places where you can set a timeout, especially in fan-out requests
          scenarios where you could set an individual timeout on each fanned-out request or a global
          timeout, on the whole operation.</p>
      
   <dl>
     <dlentry>
       <dt>Setting timeouts on an async workflow</dt>
       <dd>RxJava offers an easy way to set up a timeout on any <apiname>Observable</apiname>:
              simply chain in a call to <apiname>timeout(long duration, TimeUnit unit)</apiname>. If
              the timeout is triggered, the Observable is notified of a
                <apiname>TimeoutException</apiname> in its <apiname>onError</apiname> handler.
                <p>The underlying timer used for enforcing the timeout considers the delay between
                each emission in the source Observable. It is by default running on the
                  <apiname>Schedulers.computation()</apiname> Scheduler. Note that in the Couchbase
                blocking API, this <apiname>TimeoutException</apiname> is in turn wrapped into a
                  <apiname>RuntimeException</apiname> so that only unchecked exceptions are used in
                the API. </p><p>There is a <apiname>timeout</apiname> variant that will directly
                switch to a provided fallback Observable instead of propagating an Exception.
                Another variant also accepts a <term>timeout selector</term> instead of a simpler
                duration, in the form of an Observable for each emission. If said Observable
                completes before a new emission is seen in the source Observable, this is considered
                a timeout. This is a much more flexible implementation should you needs go beyond
                the simple duration-based timeout. </p></dd>
     </dlentry>
   </dl> 
    <dl>
      <dlentry>
        <dt>Timeouts in the Couchbase synchronous API</dt>
        <dd>The way the synchronous API is built around calling the async API and blocking on it
              means that you cannot weave in timeouts from RxJava directly. So the API offers
              overloads for every methods that allow you to explicitely set a timeout duration.
                <p>If you don't provide one explicitly on each operation, a default timeout will be
                used. Each operation belongs to a broad category for which a default timeout can be
                tuned in the <apiname>CouchbaseEnvironment</apiname> used to configure the SDK (for
                  example,<apiname>connectionTimeout</apiname> for bootstrapping,
                  <apiname>kvTimeout</apiname> for Key/Value operations or
                  <apiname>viewTimeout</apiname> for view operations), so there'll never be a
                blocking operation that doesn't have a timeout set. </p></dd>
      </dlentry>
    </dl>
    </section>
    <section><title><apiname>BackpressureException</apiname></title>
  
      <p>Sometimes you'll see a <apiname>BackpressureException</apiname> being propagated in your
          Observable. This error indicates that the SDK was overloaded with too many operations. By
          default, the SDK maintains an internal structure called the <term>Ring Buffer</term>,
          which has a little over 16K slots for queuing up requests. As soon as the server responds,
          the corresponding request's slot is freed. <apiname>BackpressureException</apiname>
          happens when this ring buffer becomes full, meaning that 16K requests were still pending,
          and the server couldn't keep up with the load.</p>
      <p>One very common cause for this is to use a bulk get/set using
            <apiname>Observable.from(collection)</apiname> where <codeph>collection</codeph> is
          larger than or close to the size of the ring buffer. Since
            <apiname>Observable.from</apiname> consumes the collection from memory in one sweep, it
          can be done extremely fast, thus filling the ring buffer almost instantly and causing a
            <apiname>BackpressureException</apiname> (such as clogging the pipes).</p>
      <p>We've seen the solution to this in the section "Bulk pattern,
            <apiname>BackpressureException</apiname> and reactive pull backpressure". One can use
          RxJava's reactive pull backpressure mechanisms only to consume from the collection as
          slots free up. Another possibility is to implement retry and backoff semantics, especially
          if the error happens out of a bulk context. For example, that happens if the server is
          under heavy load, and locally the application does many operations in parallel, but these
          operations are isolated from one another instead of batches.</p>
      
      
    
    </section>
    <section><title>Correctly Dealing with Binary Data, <apiname>ByteBuf</apiname>, and Memory Leak</title>
      
      <p>The Java SDK uses Netty for network IO. The library has an implementation of byte buffers
          that go beyond what the JVM currently offers, <apiname>ByteBuf</apiname>. Such buffers can
          wrap JVM buffers, use memory from the heap or off the heap, and be pooled or not. For
          performance reasons, the SDK mainly uses <term>pooled off-heap</term>
          <apiname>ByteBuf</apiname>.</p>
      <p>Netty's buffers are <term>reference counted</term>. Once their <apiname>refCnt()</apiname>
          (reference count) reaches 0, the buffer is cleaned up, returned to the pool (if it was
          pooled). Most operations will automatically <apiname>release()</apiname> the buffers,
          especially when a buffer is written on the wire. But sometimes you'll need to
            <apiname>retain()</apiname>the buffer if you need to reuse it after such an automatic
          cleanup. Usually, the symptom for this is an
            <apiname>IllegalReferenceCountException</apiname> mentioning a <codeph>refCnt:
            0.</codeph></p>
      <p>The opposite symptom is when you see a trace in the logs that says <systemoutput>LEAK:
            ByteBuf.release() was not called before it's garbage-collected</systemoutput>. This is
          symptomatic of a buffer that is not released correctly. Netty will by default sample 1% of
          the created buffer, which can be tuned up by using
            <apiname>ResourceLeakDetector.setLevel(...) </apiname>method. This message appears in
          the logs when one of these sampled buffers is detected to be garbage-collected while still
          having a <codeph>refCnt > 0.</codeph></p>
      <p>One context where both of these are more likely to happen is when you use a
            <apiname>BinaryDocument</apiname>. Since this kind of <codeph>Document</codeph> exposes
          the raw <codeph>ByteBuf</codeph> to the user, it is your responsibility to manage the
          buffer correctly. On the <codeph>write</codeph> path, you create the buffer and you pass
          it to the SDK through the <apiname>BinaryDocument</apiname>. The SDK will take it from
          here and Netty will release the buffer once it writes it down the wire during IO. However,
          on the read path the SDK creates a buffer and passes it to you, giving you responsibility
          for <apiname>release()</apiname>. See the <xref
            href="http://netty.io/wiki/reference-counted-objects.html" format="html"
            scope="external">Netty</xref> documentation for more information about managing buffers. </p>
      <p>There could also be subtleties with use cases where you reuse a buffer, like in the
          following code.  The buffer CAN be used twice, and second time as fallback if the document
          didn't exist:</p>
      <codeblock outputclass="language-java">  byteBuffer.retain(); //prepare for potential multi usage (+1 refCnt, refCnt = 2)
        try {
        bucket.append(document);
        // refCnt = 2 on success
        byteBuffer.release(); //refCnt = 1
        } catch (DocumentDoesNotExistException dneException) {
        // buffer is released on errors, refCnt = 1
        //second usage will also release, but we want to be at refCnt = 1 for the finally block
        byteBuffer.retain(); //refCnt = 2
        bucket.insert(document); //refCnt = 1
        } // other uncaught errors will still cause refCnt to be released down to 1
        finally {
        //we made sure that at this point refCnt = 1 in any case (success, caught exception, uncaught exception)
        byteBuffer.release(); //refCnt = 0, returned to the pool
        }   
      </codeblock>
      <p>You have to prepare everything beforehand by calling <apiname>retain()</apiname> because
          once the <apiname>refCnt</apiname> reaches 0 you cannot do anything else with the
          buffer.</p>   
      
    </section>
    <section><title>Operation Effects</title>
  
      <p>Most operations have a set of error conditions described in their corresponding Javadoc.
          This section describes a few that are quite common and their usual meaning:</p>
      <ul>
        <li><apiname>DocumentDoesNotExistException</apiname></li>
        <li><apiname>DocumentAlreadyExistsException</apiname></li>
        <li><apiname>CASMismatchException</apiname></li>
        <li><apiname>TemporaryLockFailureException</apiname></li>
        <li><apiname>DurabilityException</apiname></li>
        <li><apiname>TemporaryFailureException</apiname></li>
      </ul>
      <p>The first two, <apiname>DocumentDoesNotExistException</apiname> and
            <apiname>DocumentAlreadyExistsException</apiname>, happen respectively when using
            the<apiname> replace()</apiname> operation and the <apiname>insert()</apiname>
          operation. First operation semantics implies that the operation expects a document with
          the provided key to be already stored in the database. If this is not the case, the
          exception is thrown. On the other hand of the spectrum, <codeph>insert</codeph> semantics
          implies that there should not be any document in the database with the given key. Hence
          the <apiname>DocumentAlreadyExistsException</apiname> when one such document is found.
          Note that if you want a <codeph>write</codeph> operation that works in both cases, you can
          use <apiname>upsert()</apiname>, which will by design also ignore the CAS value.</p>  
      <p>Mutative operations will usually take the Document's CAS into account and update it in the
          returned instance of <codeph>Document</codeph>. This is optimistic locking, meaning that
          the database is optimistic about the rarity of a clash of writes. Instead of paying the
          costly overhead of locking the document whenever it is accessed, the engine will instead
          refuse to execute one of the conflicting operations, detecting such changes by a variation
          of the CAS metadata. This surfaces in the SDK with a
            <apiname>CASMismatchException</apiname>. Usually, the way to go in this case is to retry
          by issuing a <apiname>get()</apiname> command to get the latest version of the document,
          or the one that took precedence. Then re-apply the mutation, maybe by reapplying a delta
          change or maybe by presenting the document to the user for the edition, and re-perform
            <apiname>replace()</apiname>.</p>  
      <p>Couchbase also allows to perform pessimistic locking, meaning that a particular key cannot
          be touched by anyone except the performer of a<apiname>getAndLock()</apiname> for up to 30
          seconds. If some code tries to access or mutate a locked document, a
            <apiname>TemporaryLockFailureException</apiname> will be thrown. Once again, the best
          way to deal with that error is to try again later, but you'll usually have to make sure
          that the attempted change does not overwrite the one performed during lock. After all, it
          was important enough that a pessimistic lock was enforced around it.</p>  
      <p>Durability constraints (<apiname>ReplicateTo</apiname> and <apiname>PersistTo</apiname>)
          allow you to instruct the SDK not to return until the database has acknowledged a certain
          level of replication/persistence. This is done using the corresponding overloads, on a
          per-operation basis. The SDK will perform the operation and will poll the cluster until
          enough replicate nodes have acknowledged seeing the mutation in RAM (for
            <apiname>ReplicateTo</apiname>) and/or having persisted it on disk
            (<apiname>PersistTo</apiname>). The original operation and the polling for durability
          constraint requirements are two separate things. It the later fails a
            <apiname>DurabilityException</apiname> will be raised mainly for these reasons:</p>
      <ul>
    
        <li>The constraint cannot be met in the first place due to replication factor being set up
            too low. The cause of the exception would be a
              <apiname>ReplicaNotConfiguredException</apiname>.</li>
        <li>One of the replicas is down and brings the total number of alive replicas under the
            number required for the durability constraint to be met. The cause of the exception
            would then be a <apiname>ReplicaNotAvailableException</apiname>. </li>
      </ul>
      <p>Finally, Couchbase Server is sometimes in a very busy state, for example: rebalance,
          reindexing and heavy load combined. In some cases, it will prefer to drop a request rather
          than failing into an unstable state. This <apiname>TemporaryFailureException</apiname>
          indicates that the server couldn't answer, but this is due to a transient state. Retrying
          later with that kind of exception is very likely to succeed.</p> 

  </section>  
    
    
  </body>  
</topic>
</topic>
