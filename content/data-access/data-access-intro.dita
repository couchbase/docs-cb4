<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="concept_ul5_45f_ps">
 <title>Data access</title>
	<shortdesc>
	 Couchbase offers multiple ways to access data: by issuing N1QL queries, by querying MapReduce views, by querying spatial views, and by key-value operations that allow fast direct access to documents using their unique identifiers.  </shortdesc>
 <conbody>
  <p>Couchbase permits you to mix and match access methods. N1QL queries, key-value, and MapReduce
   data access can all co-exist within the same application and Couchbase SDK. </p>
  <section> <title> SQL queries with N1QL</title>
   <p>Couchbase Server can be programmed using SQL. Given that nearly all programmers already know
    SQL, most developers will be able to get started quickly on Couchbase. And since most
    organizations already have significant amounts of SQL code, Couchbase Server fits into the
    technology landscape easily. Support for SQL by JDBC and ODBC drivers opens the ecosystem of
    tools for analytics and data integration such as Microsoft Excel, Tableau, and Informatica.</p>
   <p>Couchbase created its own SQL dialect called N1QL in order to give developers and enterprises an expressive, powerful, and complete language for querying, transforming, and manipulating JSON data. The N1QL query engine is optimized for modern, highly parallel multi-core execution. N1QL has special extensions that allow it to deal with documents with variable and/or nested structures.  Just as SQL operates on rows, columns and tables of an RDBMS and returns rows and columns to the application, N1QL operates on JSON and returns JSON to the application.
   </p>
   <p>N1QL provides a full range of functionality immediately familiar to anyone who has used SQL. N1QL can even query across document relationships. 
    <ul>
     <li><b>SELECT</b> statements for queries and sub-queries</li>
     <li><b>UPDATE, UPSERT, INSERT, DELETE</b> statements <note>DML statements are experimental in
       Couchbase Server 4.0.</note></li>
    <li><b>JOIN clauses</b> to combine results from multiple documents into a single set</li>
    <li><b>WHERE clauses</b> to define filters that narrow query selectivity and constrain UPDATE,
      UPSERT, INSERT and DELETE statements</li>
    <li><b>Aliases</b> to rename elements for convenience and clarity</li>
    <li><b>Transformations</b> such as GROUP BY, ORDER BY, LIMIT and OFFSET</li>
    <li><b>Set operators</b>, both distinct and non-distinct: UNION, INTERSECT, and EXCEPT</li> 
    <li><b>Aggregate functions</b> such as AVG, SUM, MAX, and COUNT</li>
    <li><b>A full range of expressions </b>including string comparisons with LIKE and string
      operators such as UPPER and SUBSTR</li>
    <li><b>Prepared statements</b> that get and cache a query plan independently of query execution,
      eliminating unnecessary work and therefore lowering query latency</li>
   </ul>
   </p>
   <p>
    N1QL also has extensions to SQL that enable it to better express the semantics of processing  JSON, which is more varied and flexible than RDBMS schemas and which has more embedded structure. N1QL’s extensions to SQL reduce application-side complexity of post-processing and filtering the query results, and also reduce the load on the network by transmitting less data:
    <ul>
     <li><b>Paths</b> expressed with dot notation to address embedded JSON elements like arrays and
      objects. Paths work with both named attributes and numbered indexes: for example,
      route.schedule[0].day returns just the day of the first schedule object in an array.</li>
     <li><b>NEST / UNNEST</b> commands to either construct or flatten an array in a query result,
      such as a user might do to create a clean list of items to display in a web page. NEST/UNNEST
      can be chained with JOIN in any combination.</li>
     <li><b>USE KEYS</b> bypasses the index scan to directly access one or more documents using a
      primary key lookup. Because the hash of the key is used to physically place data on the
      appropriate Couchbase node, the request can be completed without any other lookup. This makes
      USE KEYS operations extremely fast, nearly as fast as a Couchbase Key-Value operation.</li>
     <li><b>JOIN… ON KEYS…</b> As in use keys, the JOIN can be fulfilled by direct access, using a
      highly efficient nested loop join algorithm.</li>
     <li><b>Ranging over collections</b> with operators ANY and EVERY to check the members of an
      array that meet a particular condition.</li>
     <li><b>Mapping with filtering</b> using the ARRAY command</li>
     <li><b>WITHIN</b> walks a hierarchical JSON structure of arbitrary depth. Can be combined with
      SET and UNSET commands to add or remove nodes in the hierarchy. </li>
     <li><b>Dynamic JSON object construction</b> using the result of a query.</li>
     <li><b>Nested traversal of structures</b> so that queries can “see” and directly address parts
      of documents including embedded properties and arrays.</li>
     <li><b>MISSING</b>, a special query value that indicates the lack of a given field within a
      document. Unlike RDBMSs, Couchbase documents can simply omit properties that are not
      applicable rather than being forced to include them for consistency and setting them to NULL.
      Since NULL is also a valid datatype in JSON, MISSING allows programmers to express different
      handling for each case if they so choose.</li>
    </ul>
   </p>
   <p>N1QL also has functions to help with querying: <ul>
     <li><b>Date functions</b> that convert a date string into something which can be sorted and/or
      compared in a query</li>
     <li><b>Regular expressions</b> a powerful alternative to LIKE</li>
     <li><b>String</b> concatenation functions</li>
     <li><b>Type coercion</b> to parse a string as a number, for example</li>
    </ul>
   </p>
   <p> N1QL uses native JSON data types for Numbers, Strings, Booleans, Null, Arrays, and Objects.
    In addition, N1QL also supports binary types as required to interoperate with the Key Value
    store, as well as MISSING, mentioned above. All data types have well defined semantics for
    comparison, sort order, date handling, and more. An interactive N1QL shell called cbq can be
    used to quickly issue queries and examine their results. To help novices get started quickly, an
    interactive tutorial is built into the query server itself. </p>
   
  </section>
  <section> <title> Key-Value operations</title>
  <p>
   At the heart of Couchbase is the distributed Key-Value (KV) store. The KV store provides an extremely simple and fast mechanism by which to store data. A KV store is a simple, schema-less approach to data management that, as the name implies, involves storing a unique ID (key) with a piece of arbitrary information (value); it may be thought of as a hashmap or dictionary. The KV store itself can accept any data, whether it be a binary blob or a JSON document, and Couchbase features such as N1QL and MapReduce make use of the KV store’s ability to process JSON documents. </p>
   <p>Due to their simplicity, KV operations execute with extremely low latency, often sub-millisecond. While the Query service is accessed by a defined query language (N1QL), the KV store is accessed using simple CRUD (Create, Read, Update, Delete) APIs, and thus provides a simpler interface when accessing documents using their IDs (primary keys).</p>
   <p>The KV store contains the authoritative, most up-to-date state for each item. In order to
    perform better, query and MapReduce services provide eventually consistent indexes that, by
    default, use a potentially slightly out of date version of the data. However, they can instead
    elect to wait slightly to make sure they have had a chance to update before responding to a
    query. Querying the KV store directly however will always access the latest version of data.</p>
   
   <p>While N1QL may often provide a richer query interface, applications will use the KV store when speed, consistency,  and simplified access patterns are preferred over flexible query options.</p>
   
   <p>All KV operations are atomic, which means that Read and Update are individual operations. In order to avoid conflicts that might arise with multiple concurrent updates to the same document, applications may make use of CAS, which is a per-document version number that Couchbase modifies each time a document is changed), called CAS, to avoid conflicts with multiple concurrent updates to the same document.
  </p>
  </section>
  <section> <title> MapReduce views</title>
   <p> Programmers can write JavaScript MapReduce programs that create views of items stored in
    Couchbase, called MapReduce views for short. MapReduce is a programming model for distributed
    data processing on highly parallelizable data: the map function reads all documents across the
    cluster, filters them to select the relevant information, and then emits the results; reduce
    function sorts and aggregates the results. Once created, MapReduce views are incrementally
    updated automatically as their underlying data undergoes mutations. MapReduce views can be
    queried using REST API endpoints, client SDKs, or N1QL queries. </p>
   <p>The main strength of MapReduce views compared to other indexes is that their customizability and flexibility allow them to handle complex computations and very large datasets. Once created, they are incrementally updated automatically. When MapReduce views contain keys in their outputs, they can serve as indexes and are discussed further in the indexes section.
   </p></section>
  <section> <title> Spatial views</title>
   <p> Spatial Views are a special type of MapReduce View, and like MapReduce views, their output is
    typically leveraged as an index. Spatial views enable queries about geometries, such as whether
    a point is located within a bounding box. They take as input geometric data in the form of
    GeoJSON, n-dimensional numeric data (hyper-cubes), or a combination of the two. </p></section>
  <section> <title> Full text search</title>
   <p> Couchbase Server performs search queries using <xref
     href="https://github.com/couchbaselabs/cbft" format="html" scope="external">Couchbase
     FTS</xref> (developer preview), an integrated full text search engine. With CBFT, developers
    can easily add full-text search capabilities to their application without deploying additional
    components, which reduces operational complexity. Alternatively, customers who use external
    search engines such as Elasticsearch or Lucidworks can leverage the available connectors to
    continuously replicate data from the Couchbase Server cluster to the search engines. </p></section>
  
 </conbody>
</concept>
