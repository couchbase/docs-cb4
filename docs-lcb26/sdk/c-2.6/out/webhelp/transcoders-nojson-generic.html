
<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
<head><meta name="description" content="Couchbase is a document database and functions best when document contents are JSON. Nevertheless Couchbase may be used to store non-JSON data for various use cases. Non-JSON formats may be more ..."></meta><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta><meta name="copyright" content="(C) Copyright 2005"></meta><meta name="DC.rights.owner" content="(C) Copyright 2005"></meta><meta name="DC.Type" content="topic"></meta><meta name="DC.Title" content="Non-JSON Documents"></meta><meta name="DC.Relation" scheme="URI" content="managing-data.html"></meta><meta name="DC.Format" content="XHTML"></meta><meta name="DC.Identifier" content="devguide_nonjson"></meta><link rel="stylesheet" type="text/css" href="oxygen-webhelp/resources/css/commonltr.css"><!----></link><title>Non-JSON Documents</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta><link rel="stylesheet" type="text/css" href="oxygen-webhelp/resources/css/webhelp_topic.css"><!----></link><link rel="stylesheet" type="text/css" href="oxygen-webhelp/resources/skins/skin.css"><!----></link><script type="text/javascript"><!--
          
          var prefix = "index.html";
          
          --></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery-1.8.2.min.js"><!----></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery.cookie.js"><!----></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery-ui.custom.min.js"><!----></script><script type="text/javascript" src="oxygen-webhelp/resources/js/jquery.highlight-3.js"><!----></script><script type="text/javascript" charset="utf-8" src="oxygen-webhelp/resources/js/webhelp_topic.js"><!----></script></head>
<body onload="highlightSearchTerm()" class="frmBody" id="devguide_nonjson">
<table class="nav"><tbody><tr><td colspan="2"><div id="printlink"><a href="javascript:window.print();" title="Print this page"></a></div><div id="permalink"><a href="#" title="Link to this page"></a></div></td></tr><tr><td width="75%"><a class="navheader_parent_path" href="c-intro.html" title="C SDK 2.6">C SDK 2.6</a> / <a class="navheader_parent_path" href="managing-data.html" title="Managing Data">Managing Data</a></td><td><div class="navheader">
<span class="navparent"><a class="link" href="managing-data.html" title="Managing Data"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">Managing Data</span></a></span>  </div></td></tr></tbody></table>

  <h1 class="title topictitle1">Non-JSON Documents</h1>

  <div class="body">
        <p class="p">Couchbase is a document database and functions best when document contents are JSON.
            Nevertheless Couchbase may be used to store non-JSON data for various use cases.</p>

        <p class="p">Non-JSON formats may be more efficient in terms of memory and processing power (for
            example, if storing only flat strings, JSON adds an additional syntactical overhead of
            two bytes per string). Non-JSON documents may be desirable if migrating a legacy
            application which is using a customized binary format.</p>

        <p class="p">Note that only JSON documents can be accessed using Query (N1QL). Limited support for
            non-JSON documents is available for MapReduce views. Additionally, non-JSON documents
            will not be accessible using the <a class="xref" href="webui.html#concept_j3z_zhm_zs">Web
                UI</a> (the contents will be shown in their Base64 equivalent).</p>

        <div class="section"><h2 class="title sectiontitle">Using non-JSON documents</h2>
            
            <div class="p">It's important to note that a JSON document can also refer to a simple integer
                    (<samp class="ph codeph">42</samp>), string (<samp class="ph codeph">"hello"</samp>), array
                    (<samp class="ph codeph">[1,2,3]</samp>), boolean (<samp class="ph codeph">true</samp>,
                    <samp class="ph codeph">false</samp>) and the JSON <samp class="ph codeph">null</samp> value. Nevertheless
                if your application requires a non-JSON format, the SDK may still support it
                natively. <div class="note note"><span class="notetitle">Note:</span> See: Supported formats</div>
If there is no native support for your
                format, you can write a <em class="ph i">transcoder</em> which handles the encoding and decoding of
                your documents to and from the server.</div>

        </div>

        <div class="section" id="devguide_nonjson__devguide_nonjson_itmflags"><h2 class="title sectiontitle">Item flags</h2>
            
            <p class="p">Every item (record) in Couchbase contains metadata stored along with it in the
                server. One of the metadata fields is a 32 bit "flag" value.</p>

            <p class="p">Couchbase SDKs accept native object types (integers, strings, arrays, dictionaries)
                as valid inputs for a Document and internally convert them to JSON before sending
                them to the server to be stored. When the SDK serializes the Document, it notes the
                type of serialization performed (JSON) and sends a corresponding type code along
                with the serialized document to the server to be stored. This type code is stored in
                the flags field within the item’s metadata.</p>

            <p class="p">Later, when retrieving the document from the server, the SDK checks the type code
                which informs it about the type of serialization used to encode the document, and
                thus how the SDK should de-serialize the document.</p>

            <p class="p">By default, SDKs will only accept document types which can serialize to JSON and will
                only serialize them to JSON. However applications can configure the SDK to use
                non-JSON serialization and accept other types of inputs as documents. Note that
                using non-JSON serialization will prevent the document from being accessible via
                Query and MapReduce.</p>

            <p class="p">The table below shows the built-in formats available in most SDKs. The <em class="ph i">name</em>
                column displays the format name; the <em class="ph i">native type</em> column displays the native
                language type which is used as input and output for the document, the
                    <em class="ph i">description</em> contains the properties of such a type, and the <em class="ph i">flags
                    value</em> contains the actual code used for the format. The format code is
                discussed more in depth below.</p>

            <div class="p">
                
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="devguide_nonjson__table_wrc_2nb_bt" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 1. Built-in format types</span></caption>
                        
                        
                        
                        
                        <thead class="thead" align="left">
                            <tr class="row">
                                <th class="entry" valign="top" width="11.1731843575419%" id="d28754e115">Name</th>

                                <th class="entry" valign="top" width="19.553072625698324%" id="d28754e118">Native Type</th>

                                <th class="entry" valign="top" width="57.54189944134078%" id="d28754e121">Description</th>

                                <th class="entry" valign="top" width="11.731843575418994%" id="d28754e124">Flags value (see below)</th>

                            </tr>

                        </thead>

                        <tbody class="tbody">
                            <tr class="row">
                                <td class="entry" valign="top" width="11.1731843575419%" headers="d28754e115 ">JSON</td>

                                <td class="entry" valign="top" width="19.553072625698324%" headers="d28754e118 ">Dictionary, Array, Number, String, Integer</td>

                                <td class="entry" valign="top" width="57.54189944134078%" headers="d28754e121 ">Default serialization. Serializes document to JSON. Document
                                    can be used with Query</td>

                                <td class="entry" valign="top" width="11.731843575418994%" headers="d28754e124 ">0x02 &lt;&lt; 24</td>

                            </tr>

                            <tr class="row">
                                <td class="entry" valign="top" width="11.1731843575419%" headers="d28754e115 ">UTF-8</td>

                                <td class="entry" valign="top" width="19.553072625698324%" headers="d28754e118 ">Unicode or String</td>

                                <td class="entry" valign="top" width="57.54189944134078%" headers="d28754e121 ">Indicates the document is a UTF-8 string. This may be more
                                    space-efficient than JSON for documents that are a simple
                                    string, as JSON requires strings to be encapsulated by quotes.
                                    Using this serialization format may save two bytes for each
                                    string value</td>

                                <td class="entry" valign="top" width="11.731843575418994%" headers="d28754e124 ">0x04 &lt;&lt; 24</td>

                            </tr>

                            <tr class="row">
                                <td class="entry" valign="top" width="11.1731843575419%" headers="d28754e115 ">RAW</td>

                                <td class="entry" valign="top" width="19.553072625698324%" headers="d28754e118 ">ByteArray, buffer, etc.</td>

                                <td class="entry" valign="top" width="57.54189944134078%" headers="d28754e121 ">Indicates this value is a raw sequence of bytes. It is the
                                    simplest encoding form and indicates that the application will
                                    process and interpret its contents as it sees fit.</td>

                                <td class="entry" valign="top" width="11.731843575418994%" headers="d28754e124 ">0x03 &lt;&lt; 24</td>

                            </tr>

                            <tr class="row">
                                <td class="entry" valign="top" width="11.1731843575419%" headers="d28754e115 ">PRIVATE</td>

                                <td class="entry" valign="top" width="19.553072625698324%" headers="d28754e118 ">SDK/Language dependent</td>

                                <td class="entry" valign="top" width="57.54189944134078%" headers="d28754e121 ">This indicates that a language-specific serialization format
                                    is being used. The serialization format depends on the language
                                    (for example, Pickle for Python, Marshal for Ruby, Java
                                    Serialization for Java, etc). <em class="ph i">Using this format will make
                                        your documents inaccessible from other-language
                                    SDKs</em>.</td>

                                <td class="entry" valign="top" width="11.731843575418994%" headers="d28754e124 ">0x01 &lt;&lt; 24</td>

                            </tr>

                        </tbody>

                    </table>
</div>

            </div>

        </div>

        <div class="section"><h2 class="title sectiontitle">Custom formats</h2>
            
            <p class="p">If your application must store data that cannot be handled by any of the built-in SDK
                formats (for example, if the application wishes to store data as UTF-16), there are
                generally two options:</p>

        </div>

        <div class="section"><h2 class="title sectiontitle">Using the <em class="ph i">RAW</em> format</h2>
            
            <div class="p">Manually serialize your document to a raw buffer, store the document using the
                    <em class="ph i">RAW</em> format, and manually deserialize your document upon retrieval,
                reading and decoding the retrieved buffer manually. Here is an example in Python of
                manually encoding and decoding a UTF-16 string (note that the Python SDK names the
                    <em class="ph i">RAW</em> format as
                <span class="keyword parmname">FMT_BYTES</span>):<pre class="pre codeblock">&gt;&gt;&gt; from couchbase import FMT_BYTES
&gt;&gt;&gt; cb.upsert('utf16_doc',
              'Hello, UTF-16 World!'.encode('utf16'),
              format=FMT_BYTES)
OperationResult&lt;RC=0x0, Key=u'utf16_doc', CAS=0x35cc17c7f213&gt;
&gt;&gt;&gt; raw_buf = cb.get('utf16_doc').value
&gt;&gt;&gt; raw_buf
'\xff\xfeH\x00e\x00l\x00l\x00o\x00,\x00 \x00U\x00T\x00F\x00-\x001\x006\x00 \x00W\x00o\x00r\x00l\x00d\x00!\x00'
&gt;&gt;&gt; utf16_doc = raw_buf.decode('utf16')
&gt;&gt;&gt; utf16_doc
u'Hello, UTF-16 World!'</pre>
</div>

        </div>

        <div class="section"><h2 class="title sectiontitle">Using transcoders</h2>
            
            <div class="p">
                <div class="note note"><span class="notetitle">Note:</span> Not all SDKs support transcoders. Refer to your SDK documentation to determine
                    whether and how transcoders are supported.</div>

            </div>

            <p class="p">A Transcoder refers to a pair of functions which are responsible for serializing
                (encoding) a document before sending it to the server and de-serializing (decoding)
                a document to a suitable application type when it is retrieved.</p>

            <p class="p">Using transcoders is preferred over RAW serialization when possible, as it provides a
                cleaner interface as well as allows it to work in a mixed type environment (if there
                are multiple custom types) without having to encode the document type within the
                document itself.</p>

            <p class="p">The <em class="ph i">encoding</em> function in the transcoder accepts a native Document type as
                input (as created by your application), encodes it as a byte buffer, and returns the
                byte buffer along with a type code.</p>

            <p class="p">The <em class="ph i">decoding</em> function accepts a buffer (as fetched from the server) and a type
                code (the flags from the metadata) and returns the intended type to be used for the
                Document within the application.</p>

            <div class="p">The following shows an implementation of the encoding
                    (<span class="keyword apiname">encode_value</span>) and decoding (<span class="keyword apiname">decode_value</span>)
                functions in
                Python:<pre class="pre codeblock">from couchbase.transcoder import Transcoder
UTF16_TYPECODE = 0x0A000000
class Utf16Transcoder(Transcoder):
    def encode_value(self, value, format):
        if (format == UTF16_TYPECODE):
            return value.encode('utf16'), UTF16_TYPECODE
        else:  # Call default implementation
            return super(Utf16Transcoder, self).encode_value(value, format)

    def decode_value(self, value, flags):
        if flags == UTF16_TYPECODE:
            return value.decode('utf16')
        else:  # Call default implementation
            return super(Utf16Transcoder, self).decode_value(value, flags)

cb.transcoder = Utf16Transcoder()
cb.upsert('utf16_doc', 'Hello, UTF-16 World!', format=UTF16_TYPECODE)
cb.get('utf16_doc')</pre>
</div>

        </div>

        <div class="section"><h2 class="title sectiontitle">Format flags (type codes) and SDK interoperability</h2>
            
            <p class="p">Modern Couchbase SDKs have standardized type codes for the various built-in document
                formats. This has not always been the case however, and older, legacy SDKs would use
                different flag values for typecodes (so for example, the code for a string value
                could be 100 or 4 depending on the SDK used).</p>

            <p class="p">In order to remain backwards-compatible with legacy SDKs and to retain
                interoperability with current SDKs, the standard typecodes follow the following
                format. Note that typecodes are stored under the flags field in the server’s
                metadata, which is a 32 bit field.</p>

            <p class="p">Current SDKs set the flags value using these two factors:</p>

            <div class="p">
                <ul class="ul" id="devguide_nonjson__ul_zfw_34b_bt">
                    <li class="li">The <em class="ph i">modern</em> or <em class="ph i">common</em> typecode: This is the modern SDK code for
                        a given type, and is standard across all SDKs.</li>

                    <li class="li">The legacy or compat typecode: This is the code which was used by older
                        versions of a given SDK. It is valid only for that language’s SDK. It is
                        important to note that all legacy typecodes (regardless of language) are
                        under 24 bits in width. Legacy SDKs will also often have a mask value
                        (typically no wider than 16 bits).</li>

                </ul>

            </div>

            <div class="p">The resultant typecode (actually stored as the <em class="ph i">flags</em> value is a bitwise OR of
                the modern typecode and the legacy typecode. For example, the older legacy Python
                code for <em class="ph i">JSON</em> was <samp class="ph codeph">0x00</samp> and the unified typecode for
                    <em class="ph i">JSON</em> is <samp class="ph codeph">0x02</samp>. The resultant typecode is
                thus:<pre class="pre screen">(0x02 &lt;&lt; 24) | (0x00)
0x02000000</pre>
Another example: The
                legacy typecode for the <em class="ph i">RAW</em> format in Python is <samp class="ph codeph">0x02</samp>, and
                the common type code is <samp class="ph codeph">0x03</samp>. The resultant typecode
                is:<pre class="pre screen">(0x03 &lt;&lt; 24) | (0x02)
0x03000002</pre>
</div>

            <p class="p">When defining a new type code using the transcoder, ensure to keep the above
                information in mind, so as not to clash with any existing ones.</p>

        </div>

    </div>

<div class="related-links"></div>
<div class="navfooter"><!---->
<span class="navparent"><a class="link" href="managing-data.html" title="Managing Data"><span class="navheader_label">Parent topic</span><span class="navheader_separator">: </span><span class="navheader_linktext">Managing Data</span></a></span>  </div><div class="footer">WebHelp output generated by<a href="http://www.oxygenxml.com" target="_blank"><span class="oXygenLogo"><img src="oxygen-webhelp/resources/img/LogoOxygen100x22.png" alt="Oxygen"></img></span><span class="xmlauthor">XML Author</span></a> - Trial Edition</div>
</body>
</html>